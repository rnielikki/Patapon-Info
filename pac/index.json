{
  "addItem.html": {
    "href": "addItem.html",
    "title": "addItem",
    "keywords": "addItem There are few functions with the same name: addItem (25166100) (Global) : Adds item to the obtain status. addItem (250a0900) (Global) : Adds item to the player slot."
  },
  "addStage.html": {
    "href": "addStage.html",
    "title": "addStage",
    "keywords": "addStage There are few functions with the same name: addStage (25165d00) (Global) addStage (251c1300) (Azito)"
  },
  "addabnormalstatus.html": {
    "href": "addabnormalstatus.html",
    "title": "addAbnormalStatus",
    "keywords": "addAbnormalStatus Sets status effect as status ID. Works with unit, squad or troop. Check status ID table for the status effect. Code Information Name: addAbnormalStatus Scope: Global PAC Instruction (Binary): 25 17 4f 00 Assembly Address in Memory : 0x8916778 Parameters (int *)handle_id (8 bytes) : Unit or squad handle, obtained from getUnitHandle or getUnitSquadHandle. If the handle is squad, this is applied to the whole squad. (int)status_ID (8 bytes) : The status effedt ID to apply to the unit. (float)duration (8 bytes) : Duration of the status as seconds. (bool)is_apply_effect (8 bytes) : If this is zero, applies actual status effect to the unit. Otherwise, set status flag only. Remarks For tumble, use addAbnormalStatusSlip instead! For knockback, use addAbnormalStatusBlowOff instead! Example Here is one example in hex: 25 17 4f 00 / 04 00 00 00 / 19 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 20 41 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: addAbnormalStatus((int *)iVar25, (int)0, (float)10, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08916778(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; int iVar5; int iVar6; undefined uStack64; byte local_3f; undefined4 local_38; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); if (*piVar1 != -1) { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 != 0) { iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); if (iVar6 == 9) { iVar5 = iVar5 + 0x180; local_10 = 0; local_c = 0; local_8 = 0; local_4 = 0; Syscall::Kernel::Kernel_Memset(&uStack64,0,0x40); local_38 = 0xffffffff; local_3f = local_3f & 0xf6 | 9; switch(*puVar2) { case 0: Damage::Status::Apply_Status_Effect(*puVar3,iVar5,0,1,&uStack64,*piVar4 != 0); break; case 1: Damage::Status::Apply_Status_Effect(*puVar3,iVar5,1,1,&uStack64,*piVar4 != 0); break; case 2: Damage::Status::Apply_Status_Effect(*puVar3,iVar5,2,1,&uStack64,*piVar4 != 0); break; case 3: Damage::Status::Apply_Status_Effect(*puVar3,iVar5,3,1,&uStack64,*piVar4 != 0); break; case 4: Damage::Status::Apply_Status_Effect(*puVar3,iVar5,4,1,&uStack64,*piVar4 != 0); break; case 6: Damage::Status::Apply_Status_Effect(*puVar3,iVar5,6,1,&uStack64,*piVar4 != 0); } } else { iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); if (iVar6 == 3) { switch(*puVar2) { case 0: FUN_088c6cdc(*puVar3,iVar5,0,*piVar4 != 0); break; case 1: FUN_088c6cdc(*puVar3,iVar5,1,*piVar4 != 0); break; case 2: FUN_088c6cdc(*puVar3,iVar5,2,*piVar4 != 0); break; case 3: FUN_088c6cdc(*puVar3,iVar5,3,*piVar4 != 0); break; case 4: FUN_088c6cdc(*puVar3,iVar5,4,*piVar4 != 0); break; case 6: FUN_088c6cdc(*puVar3,iVar5,6,*piVar4 != 0); } } else { iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); if (iVar6 == 2) { switch(*puVar2) { case 0: FUN_088e361c(*puVar3,iVar5,0,*piVar4 != 0); break; case 1: FUN_088e361c(*puVar3,iVar5,1,*piVar4 != 0); break; case 2: FUN_088e361c(*puVar3,iVar5,2,*piVar4 != 0); break; case 3: FUN_088e361c(*puVar3,iVar5,3,*piVar4 != 0); break; case 4: FUN_088e361c(*puVar3,iVar5,4,*piVar4 != 0); break; case 6: FUN_088e361c(*puVar3,iVar5,6,*piVar4 != 0); } } } } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addabnormalstatusblowoff.html": {
    "href": "addabnormalstatusblowoff.html",
    "title": "addAbnormalStatusBlowOff",
    "keywords": "addAbnormalStatusBlowOff Sets knockback effect. Code Information Name: addAbnormalStatusBlowOff Scope: Global PAC Instruction (Binary): 25 17 51 00 Assembly Address in Memory : 0x8916d98 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (float)Var1 (8 bytes) (float)Var2 (8 bytes) Example Here is one example in hex: 25 17 51 00 / 04 00 00 00 / 41 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: addAbnormalStatusBlowOff((int *)iVar65, (float *)fVar0, (float *)fVar1) For more context, fVar0 was 8.5 and fVar1 was 16.5. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08916d98(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; undefined uStack64; byte local_3f; undefined4 local_38; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 9)) { local_10 = 0; local_c = 0; local_8 = 0; local_4 = 0; Syscall::Kernel::Kernel_Memset(&uStack64,0,0x40); local_38 = 0xffffffff; local_3f = local_3f & 0xf6 | 9; local_2c = *puVar3; local_30 = *puVar2; local_24 = 0x3f800000; local_28 = 0; Damage::Status::Apply_Status_Effect(0,iVar4 + 0x180,5,1,&uStack64,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addabnormalstatusslip.html": {
    "href": "addabnormalstatusslip.html",
    "title": "addAbnormalStatusSlip",
    "keywords": "addAbnormalStatusSlip Sets tumble effect. Cannassault heromode tumble uses this. Not triggered with miniboss or boss. Code Information Name: addAbnormalStatusSlip Scope: Global PAC Instruction (Binary): 25 17 50 00 Assembly Address in Memory : 0x8916bd4 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. Example Here is one example in hex: 25 17 50 00 / 04 00 00 00 / 36 00 00 00 Which is interpreted as: addAbnormalStatusSlip((int *)iVar54) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08916bd4(int origin_addr,undefined4 param_2) { bool bVar1; int *piVar2; int iVar3; int iVar4; int iVar5; undefined uStack96; byte local_5f; undefined4 local_58; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; int local_14 [5]; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); if (*piVar2 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(origin_addr + 0x14),*piVar2,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { iVar4 = *(int *)(iVar3 + 0xa14); bVar1 = true; // doppelganger check if ((*(int *)(iVar4 + 0x18c) == 0x13) && (((iVar5 = SS_Controller::Is_The_CS_or_SS(iVar3,0xab), iVar5 != 0 && (iVar5 = Get_SSCaller_1stparam(1), iVar5 != 0)) && (iVar5 = Damage::Status::Is_Attacking_Or_Defending(iVar5,iVar3), iVar5 != 0)))) { bVar1 = false; } // can be pdeer? if (((bVar1) && ((iVar4 = FUN_088f7920(iVar4 + 0x1f0), iVar4 == 0 || (iVar4 = SS_Controller::Is_The_CS_or_SS(iVar3,0x19), iVar4 == 0)))) && (Command::CommandStatus_Index_Get(local_14,iVar3 + 0x170), local_14[0] != 6)) { local_30 = 0; local_2c = 0; local_28 = 0; local_24 = 0; Syscall::Kernel::Kernel_Memset(&uStack96,0,0x40); local_58 = 0xffffffff; local_5f = local_5f & 0xf6 | 9; Damage::Status::Apply_Status_Effect(0,iVar3 + 0x180,4,1,&uStack96,0); } else { Set_StatusChecked_Flag(iVar3,7); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addabnormaltroopp.html": {
    "href": "addabnormaltroopp.html",
    "title": "addAbnormalTroopP",
    "keywords": "addAbnormalTroopP Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addAbnormalTroopP Scope: Global PAC Instruction (Binary): 25 21 1a 00 Assembly Address in Memory : 0x89b30c0 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 21 1a 00 / 04 00 00 00 / 14 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 80 3f Which is interpreted as: addAbnormalTroopP((int *)iVar20, (int)0, (float)1, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b30c0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar5 != 0) { if (*piVar2 == 4) { FUN_0897d6b4(*puVar4,*puVar3,iVar5); } else if (*piVar2 == 0) { FUN_0897da4c(*puVar4,*puVar3,iVar5); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addarea.html": {
    "href": "addarea.html",
    "title": "addArea",
    "keywords": "addArea Enables specific field/dungeon area. Code Information Name: addArea Scope: Azito PAC Instruction (Binary): 25 1c 12 00 Assembly Address in Memory : 0x8b4e250 Parameters (int)group_id (8 bytes) : ID of the area, in range of 0~16. ID Group Name 0x0 Pataon training ground 0x1 Field of Angry Giants 0x2 Arena of Valour 0x3 Cave of Valour & Depths of Rage 0x4 Snow Field of Sullid Tears 0x5 Racing Alley of Purity 0x6 Tower of Purity & Heights of Lust 0x7 Plateau of Pompous Wings 0x8 Range of Justice 0x9 Castle of Justice & Dungeon of Pride 0xA Greedy Mask Jungle 0xB Arena of Earnestness 0xC Estate of Earnestness & Basement of Greed 0xD Bottomless Stomach Desert 0xE Racing Alley of Restraint 0xF Labyrinth of Restraint & Depths of Gluttony 0x10 Depths of Gluttony 0x11 ??? 0x12 Range of Adamance & Evilmass of Adamance 0x13 Savannah of Envious Eyes 0x14 Arena of Tolerance 0x15 Tomb of Tolerance & Depths of Jealousy 0x16 Volcano Zone of the Lazy Demon Example Here is one example in hex: 25 1c 12 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: addArea((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4e250(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = *puVar1; if (((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar2 != 0)) && (iVar2 = FUN_Azito__08b5a738(*(undefined4 *)(iVar2 + 0x38),0,uVar3,0xffffffff), iVar2 != 0)) { Save::Get_Save_BaseAddr(1); *(undefined4 *)(iVar2 + 0x98) = 0; *(undefined *)(iVar2 + 0x94) = 1; *(undefined4 *)(iVar2 + 0x9c) = 0xffffffff; *(undefined4 *)(iVar2 + 0x9c) = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addautocommandkey.html": {
    "href": "addautocommandkey.html",
    "title": "addAutoCommandKey",
    "keywords": "addAutoCommandKey Manually sets key for command sequence. This does nothing until startAutoCommandKey is called. This performs command like setAutoCommand, except the command is manually set. Code Information Name: addAutoCommandKey Scope: Global PAC Instruction (Binary): 25 0c 0f 00 Assembly Address in Memory : 0x8970a58 Parameters (float)timing (8 bytes) : Time as seconds. Normal non-miracle drum hit is every 0.5 seconds without chant turn. (int)drum_id (8 bytes) : Drum ID to perform. (int)Var2 (8 bytes) : Please describe what this does. Example Here is one example in hex: 25 0c 0f 00 / 10 00 00 00 / 00 00 00 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: addAutoCommandKey((float)0, (int)3, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970a58(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (iVar4 != 0) { func_0x08b74690(*puVar1,iVar4 + 8,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addcancelmotion.html": {
    "href": "addcancelmotion.html",
    "title": "addCancelMotion",
    "keywords": "addCancelMotion Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addCancelMotion Scope: Global PAC Instruction (Binary): 25 21 29 00 Assembly Address in Memory : 0x89b3b98 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3b98(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar4 != 0) { FUN_0897e570(*puVar3,iVar4,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addchara.html": {
    "href": "addchara.html",
    "title": "addChara",
    "keywords": "addChara Adds a character (unit) to a squad. Used for adding hatapon. Requires readArcFile and requestActor to load the character. Code Information Name: addChara Scope: Global PAC Instruction (Binary): 25 16 24 00 Assembly Address in Memory : 0x891bc80 Parameters (int *)destination (8 bytes) : Variable to store the character handle. (int *)squad_handle (8 bytes) : Handle of the squad. (int)charaparam_id (8 bytes) : Character ID in charaparam. Example Here is one example in hex: 25 16 24 00 / 04 00 00 00 / 36 00 00 00 / 04 00 00 00 / 35 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: addChara((int *)iVar54, (int *)iVar53, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891bc80(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if (((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) && (iVar4 = Param::ReadCharaParam(iVar4,*puVar3), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addcharin.html": {
    "href": "addcharin.html",
    "title": "addCharin",
    "keywords": "addCharin Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addCharin Scope: Global PAC Instruction (Binary): 25 0a 0a 00 Assembly Address in Memory : 0x8949e8c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0a 0a 00 / 02 00 00 00 / a0 86 01 00 Which is interpreted as: addCharin((int)100000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949e8c(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_089457dc(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addcharineffect.html": {
    "href": "addcharineffect.html",
    "title": "addCharinEffect",
    "keywords": "addCharinEffect Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addCharinEffect Scope: Global PAC Instruction (Binary): 25 16 5a 00 Assembly Address in Memory : 0x891fbd8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (undefined4)Var5 (8 bytes) (undefined4)Var6 (8 bytes) (undefined4)Var7 (8 bytes) Example Here is one example in hex: 25 16 5a 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 04 00 00 00 / 02 00 00 00 / 06 00 00 00 / 10 00 00 00 / 00 00 80 41 / 10 00 00 00 / 00 00 f0 41 / 40 00 00 00 / cf 00 00 00 / 40 00 00 00 / d0 00 00 00 Which is interpreted as: addCharinEffect((int)1, (int)1, (int)4, (int)6, (float)16, (float)30, ((global)float *)gfVar207, ((global)float *)gfVar208) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891fbd8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; undefined4 *puVar8; int iVar9; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); iVar9 = *(int *)(param_1 + 0x10); if (iVar9 == 0) { iVar9 = 0; } else { if (iVar9 == 0) { iVar9 = 0; } iVar9 = *(int *)(iVar9 + 0x188); if (iVar9 == 0) { iVar9 = 0; } } if (iVar9 != 0) { local_4 = *puVar8; local_8 = *puVar7; FUN_08952d2c(*puVar5,*puVar6,iVar9,&local_8,*puVar1,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "adddamage.html": {
    "href": "adddamage.html",
    "title": "addDamage",
    "keywords": "addDamage This supposed to deal damage, but it doesn't work. Code Information Name: addDamage Scope: Global PAC Instruction (Binary): 25 17 5b 00 Assembly Address in Memory : 0x89178a8 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)damage (8 bytes) : Damage amount to inflict. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089178a8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; byte local_40; byte local_3f; undefined4 local_3c; undefined4 local_38; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { local_10 = 0; local_c = 0; local_8 = 0; local_4 = 0; Syscall::Kernel::Kernel_Memset(&local_40,0,0x40); local_38 = 0xffffffff; local_3f = local_3f & 0xf6 | 9; local_40 = local_40 & 0xfe | 1; local_3c = *puVar2; (**(code **)(*(int *)(iVar3 + 4) + 200))(iVar3,&local_40); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addeffect.html": {
    "href": "addeffect.html",
    "title": "addEffect",
    "keywords": "addEffect Adds an effect. After this, use setModelInfo to set position. Code Information Name: addEffect Scope: Global PAC Instruction (Binary): 25 16 08 00 Assembly Address in Memory : 0x8919610 Parameters (int *)destination (8 bytes) : Variable to store the Handle. -1 if failed to create the effect. (int)effect_id (8 bytes) : ID of the effect in effectparam. (int)troop_type (8 bytes) : The troop type to set. (float)scale (8 bytes) : Scale multiplier for the effect. Usually this is 1. (bool)Var4 (8 bytes) : Please describe what this does. Mostly 0 or 1, this can be kept as 0. Remarks The desired effect must be preloaded through readArcFile before calling this. Example Here is one example in hex: 25 16 08 00 / 04 00 00 00 / 04 00 00 00 / 02 00 00 00 / f6 00 00 00 / 02 00 00 00 / 04 00 00 00 / 10 00 00 00 / 00 00 80 3f / 02 00 00 00 / 00 00 00 00 Which is interpreted as: addEffect((int *)iVar4, (int)246, (int)4, (float)1, (int)0) ...which plants grasses. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919610(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; uint *puVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (uint *)Pac_Get_Param(param_2,4,1,4); *piVar1 = -1; iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x128); if ((iVar6 != 0) && (iVar6 = Call_Effect(*puVar4,iVar6,*puVar2,*puVar3,0), iVar6 != 0)) { *piVar1 = (int)*(short *)(iVar6 + 0x78); *(byte *)(iVar6 + 0x325) = *(byte *)(iVar6 + 0x325) & 0xef | (byte)((*puVar5 & 1) << 4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addequip.html": {
    "href": "addequip.html",
    "title": "addEquip",
    "keywords": "addEquip Sets equipment to a class. This sets equipment with lvl 0. Code Information Name: addEquip Scope: Global PAC Instruction (Binary): 25 16 2a 00 Assembly Address in Memory : 0x891c06c Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)weaponparam_id (8 bytes) : weaponparam ID of the equipment to apply. Example Here is one example in hex: 25 16 2a 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / e4 00 00 00 Which is interpreted as: addEquip((int *)iVar54, (int)228) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891c06c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { AddEquipment(iVar3,*puVar2,0,0,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addequipsubmodel.html": {
    "href": "addequipsubmodel.html",
    "title": "addEquipSubModel",
    "keywords": "addEquipSubModel Places equipment (possibly in specific node, please check and describe here). This adds equipment with lvl 0. Code Information Name: addEquipSubModel Scope: Global PAC Instruction (Binary): 25 16 2b 00 Assembly Address in Memory : 0x891c130 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)weaponparam_id (8 bytes) : weaponparam ID of the equipment to apply. (int)node_id (8 bytes) : Please describe, this can be ID of the node to attach. Setting this to 0 does same thing as addEquip. Example Here is one example in hex: 25 16 2b 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / ac 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: addEquipSubModel((int *)iVar54, (int)172, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891c130(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 9)) { AddEquipment(iVar4,*puVar2,*puVar3,0,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addgimmick.html": {
    "href": "addgimmick.html",
    "title": "addGimmick",
    "keywords": "addGimmick Adds a gimmick and gets handle of it. Code Information Name: addGimmick Scope: Global PAC Instruction (Binary): 25 16 06 00 Assembly Address in Memory : 0x8919324 Parameters (int *)gimmick_handle (8 bytes) : Variable to store the gimmick handle. (int)gimmick_id (8 bytes) : Gimmick ID of the gimmick in gimmickparam. (int)troop_type (8 bytes) : Troop type of the gimmick. (int)gimmick_identifier (8 bytes) : User defined any gimmick identifier. Keep 0 if this will not used. Can be used in gimmick_getHandle. Example Here is one example in hex: 25 16 06 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / b1 02 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / b1 02 00 00 Which is interpreted as: addGimmick((int *)iVar0, (int)689, (int)0, (int)689) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919324(int param_1,undefined4 param_2) { int *piVar1; undefined4 *gimmick_id; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); gimmick_id = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); *piVar1 = -1; iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if ((iVar4 != 0) && (iVar4 = Place_Gimmick_Caller(iVar4,*gimmick_id,*puVar2,*puVar3,0), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addgimmickmodelname.html": {
    "href": "addgimmickmodelname.html",
    "title": "addGimmickModelName",
    "keywords": "addGimmickModelName Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addGimmickModelName Scope: Global PAC Instruction (Binary): 25 16 07 00 Assembly Address in Memory : 0x891940c Parameters (int *)gimmick_handle (8 bytes) : Variable to store the gimmick handle. (int)gimmick_id (8 bytes) : ID of the gimmick in gimmickparam. (int)troop_type (8 bytes) : Troop type of the gimmick. (int)gimmick_identifier (8 bytes) : User defined any gimmick identifier. Keep 0 if this will not used. Can be used in gimmick_getHandle. (String)Var4 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891940c(int param_1,undefined4 param_2) { undefined *puVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined *puVar6; undefined *puVar7; int iVar8; undefined local_100 [256]; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar6 = &DAT_00000100; puVar7 = local_100; puVar1 = puVar7; while (puVar1 != (undefined *)0x0) { *puVar7 = 0; puVar7 = puVar7 + 1; puVar6 = puVar6 + -1; puVar1 = puVar6; } Pac_Get_StringParam(param_2,local_100); *piVar2 = -1; iVar8 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if ((iVar8 != 0) && (iVar8 = Place_Gimmick_Caller(iVar8,*puVar3,*puVar4,*puVar5,local_100), iVar8 != 0)) { *piVar2 = (int)*(short *)(iVar8 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addgimmickpowergauge.html": {
    "href": "addgimmickpowergauge.html",
    "title": "addGimmickPowerGauge",
    "keywords": "addGimmickPowerGauge Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addGimmickPowerGauge Scope: Global PAC Instruction (Binary): 25 16 12 00 Assembly Address in Memory : 0x891a238 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (undefined4)Var5 (8 bytes) (int)Var6 (8 bytes) (int)Var7 (8 bytes) Example Here is one example in hex: 25 16 12 00 / 04 00 00 00 / 28 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 c8 c2 / 10 00 00 00 / 00 00 70 42 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: addGimmickPowerGauge((int *)iVar40, (float)0, (float)-100, (float)60, (int)0, (float)1, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a238(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; int *piVar7; int *piVar8; int iVar9; int iVar10; int iVar11; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); piVar7 = (int *)Pac_Get_Param(param_2,6,1,4); piVar8 = (int *)Pac_Get_Param(param_2,7,1,4); iVar9 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar9 != 0) && (iVar10 = (**(code **)(*(int *)(iVar9 + 4) + 0x34))(iVar9), iVar10 == 10)) && (*(int *)(param_1 + 0x10) != 0)) { iVar11 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x4c); iVar10 = func_0x08b30510(iVar11); if (iVar10 != 0) { local_4 = *puVar3; local_8 = *puVar2; (**(code **)(*(int *)(iVar10 + 0x10) + 0x10)) (*puVar4,*puVar6,(float)*piVar7,(float)*piVar8,iVar10,*(undefined4 *)(iVar11 + 0x14) ,iVar9,&local_8,*puVar5); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addhit.html": {
    "href": "addhit.html",
    "title": "addHit",
    "keywords": "addHit Adds a hitbox to a node. Code Information Name: addHit Scope: Global PAC Instruction (Binary): 25 17 3f 00 Assembly Address in Memory : 0x8915308 Parameters (int *)handle_id (8 bytes) : The target handle. (int *)destination (8 bytes) : Variable to store the hitbox ID. -1 if failed to add the hitbox. If the handle is invalid, this is zero. (float)x_offset (8 bytes) : X Offset from the node. (float)y_offset (8 bytes) : Y Offset from the node. (float)x_size (8 bytes) : X Size of the hitbox. (float)y_size (8 bytes) : Y Size of the hitbox. (int *)node_id (8 bytes) : ID of the node, obtained from getNodeIndex. Example Here is one example in hex: 25 17 3f 00 / 04 00 00 00 / 15 00 00 00 / 04 00 00 00 / 31 00 00 00 / 10 00 00 00 / 00 00 80 c1 / 10 00 00 00 / 00 00 20 41 / 10 00 00 00 / 00 00 00 42 / 10 00 00 00 / 00 00 f0 41 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: addHit((int *)iVar21, (int *)iVar49, (float)-16, (float)10, (float)32, (float)30, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915308(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; int iVar8; undefined4 uVar9; int iVar10; int iVar11; undefined *local_30; int local_2c; undefined4 local_28; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_10; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); *puVar2 = 0; if (*piVar1 != -1) { iVar8 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar8 == 0) { iVar8 = 0; } iVar11 = *(int *)(iVar8 + 200); if (iVar11 != 0) { local_28 = 0; local_30 = &LAB_088e4e24; local_1c = *puVar4; local_20 = *puVar3; local_14 = *puVar6; local_18 = *puVar5; local_10 = *puVar7; iVar10 = *(int *)(iVar8 + 0xd0); local_2c = iVar8; if (iVar10 != 0) { if (*(int *)(iVar10 + 0xa4) == 0) { *(int *)(iVar10 + 0x10) = iVar8; (**(code **)(*(int *)(*(int *)(iVar8 + 0xd0) + 4) + 0x2c))(); uVar9 = FUN_088dd198(*(undefined4 *)(iVar8 + 0xd0),local_10,&local_18,&local_20,local_30, local_2c,local_28,0); } else { uVar9 = Set_Hitbox(iVar10 + 0xa0,&local_30); iVar8 = Set_Collision(iVar10 + 0xa0,uVar9); *(int *)(iVar8 + 0x28) = iVar11; *(undefined4 *)(iVar8 + 0x2c) = local_10; *(undefined4 *)(iVar8 + 0x30) = 0; *(undefined4 *)(iVar8 + 0x34) = 0; } *puVar2 = uVar9; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "additem_250a0900.html": {
    "href": "additem_250a0900.html",
    "title": "addItem (250a0900)",
    "keywords": "addItem (250a0900) Other functions have the same name. Check the Disambiguation page to find them. Adds item directly to the inventory. Code Information Name: addItem Scope: Global PAC Instruction (Binary): 25 0a 09 00 Assembly Address in Memory : 0x8949dfc Parameters (int)item_id (8 bytes) : ID of the item. (int)item_amount (8 bytes) : Amount of item to add to the inventory. Example Here is one example in hex: 25 0a 09 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: addItem((int *)iVar0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949dfc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { Item::Add_Material(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34),*puVar1, *puVar2,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "additem_25166100.html": {
    "href": "additem_25166100.html",
    "title": "addItem (25166100)",
    "keywords": "addItem (25166100) Other functions have the same name. Check the Disambiguation page to find them. Adds item to the obtained item list. This should be called in mission. Code Information Name: addItem Scope: Global PAC Instruction (Binary): 25 16 61 00 Assembly Address in Memory : 0x8920154 Parameters (int)item_id (8 bytes) : ID of the item. (int)item_amount (8 bytes) : Amount of the item to obtain. Does not affect to the chest if this is not zero. (int)item_level (8 bytes) : Level of the item. (int)Var3 (8 bytes) : Keep 0. This affects visibility, 0 makes the obtain status visible, otherwise it is invisible (also can't obtain chest somehow) According to code, this can be 3 or 4. Please describe (int *)handle_id (8 bytes) : The target handle. Can keep -1. Example Here is one example in hex: 25 16 61 00 / 02 00 00 00 / a8 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: addItem((int)168, (int)1, (int)1, (int)0, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920154(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; int *piVar5; int iVar6; undefined auStack32 [24]; int local_8 [2]; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); if (*piVar1 == 0x32) { iVar6 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 100); local_8[0] = *(int *)(iVar6 + 0x2ae0) + *piVar2; if (local_8[0] < DAT_08a6fca4) { piVar1 = &DAT_08a6fca4; } else { piVar1 = local_8; } *(int *)(iVar6 + 0x2ae0) = *piVar1; } else if (*piVar5 < 1) { Syscall::Kernel::Kernel_Memset(auStack32,0,0x10); Loot::Load_New_Item_Data (*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 100),*piVar1,*piVar2, *puVar3,*puVar4,auStack32); } else { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar5,1); Loot::Load_New_Item_Data (*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 100),*piVar1,*piVar2, *puVar3,*puVar4,*(int *)(iVar6 + 200) + 0xc0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "additemeffect.html": {
    "href": "additemeffect.html",
    "title": "addItemEffect",
    "keywords": "addItemEffect Creates an obtainable item in a specific position. Code Information Name: addItemEffect Scope: Global PAC Instruction (Binary): 25 16 59 00 Assembly Address in Memory : 0x891fa48 Parameters (int *)destination (8 bytes) : Variable to store the item handle. (int)gravity_status (8 bytes) : If this is set to 2, the object doesn't fall to the ground. (int)item_id (8 bytes) : ID of the item. (int)item_level (8 bytes) : Level of the item. (int)troop_type (8 bytes) : The troop type of the item. (float)pos_x (8 bytes) : X position of the item as PSP pixels. (float)pos_y (8 bytes) : Y position of the item as PSP pixels. Example Here is one example in hex: 25 16 59 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 02 00 00 00 / 01 00 00 00 / 20 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: addItemEffect((int *)iVar0, (int)0, (int *)iVar1, (int *)iVar2, (int)1, (float *)fVar0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891fa48(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; int iVar8; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); *piVar1 = -1; iVar8 = *(int *)(param_1 + 0x10); if (iVar8 == 0) { iVar8 = 0; } else { if (iVar8 == 0) { iVar8 = 0; } iVar8 = *(int *)(iVar8 + 0x188); if (iVar8 == 0) { iVar8 = 0; } } if (iVar8 != 0) { local_c = *puVar7; local_10 = *puVar6; local_4 = 0x3f800000; local_8 = 0; iVar8 = FUN_08952610(iVar8,*puVar2,*puVar3,*puVar4,0xffffffff,*puVar5,&local_10); if (iVar8 != 0) { *piVar1 = (int)*(short *)(iVar8 + 0x78); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addlevelupitemparam.html": {
    "href": "addlevelupitemparam.html",
    "title": "addLevelUpItemParam",
    "keywords": "addLevelUpItemParam Loads level-up requirement Ka-chings and materials of an equipment for Blacksmith. Code Information Name: addLevelUpItemParam Scope: Azito PAC Instruction (Binary): 25 1c 1a 00 Assembly Address in Memory : 0x8b4f308 Parameters (int)item_id (8 bytes) : ID of the item, possibly obtained from getMaterialItemId, or 0x32 for Ka-ching. (int)amount (8 bytes) : Amount of requirement to set. Example Here is one example in hex: 25 1c 1a 00 / 04 00 00 00 / 0f 00 00 00 / 04 00 00 00 / 0b 00 00 00 Which is interpreted as: addLevelUpItemParam((int *)iVar15, (int *)iVar11) In blacksmith, this is used with getMaterialItemId: 00041264 25001B00:cmd_ifLS(4:B, 5.0, 1:412E4) //Level < 5 requirement 000412E4 250A0E00:getMaterialItemId(4:F, 4:D, 2:0) //tier 1 material 00041300 251C1A00:addLevelUpItemParam(4:F, 2:1) //requires 1 of it 00041314 25000100:cmd_end() 0004127C 25001B00:cmd_ifLS(4:B, 10.0, 1:41318) //Level < 10 requirement ... 00041294 25001B00:cmd_ifLS(4:B, 15.0, 1:4134C) //Level < 15 requirement ... 000412AC 25001B00:cmd_ifLS(4:B, 20.0, 1:413B0) //Level < 20 requirement ... 000412C4 25001B00:cmd_ifLS(4:B, 30.0, 1:41444) //Level < 30 requirement ... 000412DC 25000200:cmd_jmp(1:41508) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f308(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int amount; undefined4 item_id; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); item_id = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); amount = *piVar2; if ((*(int *)(param_1 + 0x10) != 0) && (0 < amount)) { iVar3 = Get_Some_Flag(1); BS::Write_Request_Amount(*(int *)(iVar3 + 0x34) + 0x2c,item_id,amount); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addlinkobject.html": {
    "href": "addlinkobject.html",
    "title": "addLinkObject",
    "keywords": "addLinkObject Connects a new gimmick to an existing object. The resource of the new object must be preloaded. Code Information Name: addLinkObject Scope: Global PAC Instruction (Binary): 25 17 1c 00 Assembly Address in Memory : 0x8912a00 Parameters (int *)handle_id (8 bytes) : Variable to store the attached object handle. (int)gimmickparam_id (8 bytes) : The gimmickparam ID of the new gimmick to create. (int *)parent_handle (8 bytes) : The parent handle. (int)unique_id (8 bytes) : Unique ID of the new gimmick to give. (String)node : The parent handle node name to attach the object. Example Here is one example in hex: 25 17 1c 00 / 04 00 00 00 / 0a 00 00 00 / 02 00 00 00 / 44 02 00 00 / 04 00 00 00 / 0f 00 00 00 / 02 00 00 00 / 15 00 00 00 / 61 74 74 61 / 63 68 00 00 Which is interpreted as: addLinkObject((int *)iVar10, (int)580, (int *)iVar15, (int)21, \"attach\") This is how to apply the VS turret when the fortress is occupied: 0005B56C 25170600:setActive(8:8B, 2:1) 0005B580 25171C00:addLinkObject(8:7F, 2:244, 8:8B, 2:8, \"attach\") 0005B5AC 25173600:setModelColor(8:7F, 0.0, 2:67, 2:84, 2:FF, 2:FF) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912a00(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined *puVar6; int iVar7; undefined4 uVar8; undefined *puVar9; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar6 = &DAT_00000100; puVar9 = local_100; puVar1 = puVar9; while (puVar1 != (undefined *)0x0) { *puVar9 = 0; puVar9 = puVar9 + 1; puVar6 = puVar6 + -1; puVar1 = puVar6; } Pac_Get_StringParam(param_2,local_100); *puVar2 = 0xffffffff; iVar7 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar4,1); if (iVar7 == 0) { iVar7 = 0; } if (iVar7 != 0) { uVar8 = (**(code **)(*(int *)(iVar7 + 4) + 0xac))(iVar7,*puVar3,local_100,*puVar5); *puVar2 = uVar8; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addlockdgimmick.html": {
    "href": "addlockdgimmick.html",
    "title": "addLockdGimmick",
    "keywords": "addLockdGimmick Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addLockdGimmick Scope: Global PAC Instruction (Binary): 25 16 16 01 Assembly Address in Memory : 0x8919528 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 16 16 01 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 2e 01 00 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: addLockdGimmick((int *)iVar0, (int)302, (int)3, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919528(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); *piVar1 = -1; iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if ((iVar5 != 0) && (iVar5 = FUN_088b4d68(iVar5,*puVar2,*puVar3,*puVar4,0), iVar5 != 0)) { *piVar1 = (int)*(short *)(iVar5 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addpoint.html": {
    "href": "addpoint.html",
    "title": "addPoint",
    "keywords": "addPoint Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addPoint Scope: Global PAC Instruction (Binary): 25 20 04 00 Assembly Address in Memory : 0x89b0ee8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 20 04 00 / 02 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: addPoint((int)0, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b0ee8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x14) != 0) { FUN_0898e03c(*puVar2,*(int *)(param_1 + 0x14),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addquest.html": {
    "href": "addquest.html",
    "title": "addQuest",
    "keywords": "addQuest Adds a quest on a map. Called in a world map. Code Information Name: addQuest Scope: Azito PAC Instruction (Binary): 25 1c 14 00 Assembly Address in Memory : 0x8b4e958 Parameters (int)mission_id (8 bytes) : ID of the mission, the id is unique in the map. The mission ID can be duplicated in different world map. (int)group_id (8 bytes) : Group of the mission. Same group ID will be placed in same category in the world map. See details below. Note this is different from given ID in addArea, and this considers \"depths\" dungeon as separated group. (int)name_msg (8 bytes) : Message ID of the mission name. (int)description_msg (8 bytes) : Message ID of the description. The message IDs are ID in loadinggroup/azitolocal/localize/(language)/worldmapdata/scriptlist(non-dlc) or inside 98D1E9D2 (dlc), the message IDs are NOT defined in the PAC file. (int)theme_id (8 bytes) : Default theme ID. Custom (selected) theme or setMssionBgmId overwrites this. (int)vs_type (8 bytes) : Affects VS rule screen. 0: PVE Mission, 1: Head-on, 2: Missile, 3:Racing, 4: Hellgate (unused). (bool)optional_mission (8 bytes) : If this is 0, it means this is necessary story mission for story progress. (bool)Var7 (8 bytes) : Keep this as 1. Please describe what this actually does. (bool)new_mission (8 bytes) : Mark the mission as new mission. (bool)is_replayable (8 bytes) : If this is not zero, the mission can be played again after finishing it. (String)Pac_file_name : Name of the PAC file. group_id index ID Group Name 0x1 Pataon training ground 0x2 Field of Angry Giants 0x3 Arena of Valour 0x4 Cave of Valour 0x5 Depths of Rage 0x6 Snow Field of Sullid Tears 0x7 Racing Alley of Purity 0x8 Tower of Purity 0x9 Heights of Lust 0xA Plateau of Popmous Wings 0xB Range of Justice 0xC Castle of Justice 0xD Dungeon of Pride 0xE Greedy Mask Jungle 0xF Arena of Earnestness 0x10 Estate of Earnestness 0x11 Basement of Greed 0x12 Bottomless Stomach Desert 0x13 Racing Alley of Restraint 0x14 Labyrinth of Restraint 0x15 Depths of Gluttony 0x16 Volcano Zone of the Lazy Demon 0x17 Range of Adamance 0x18 Evilmass of Adamance 0x19 Heights of Indolence 0x1A Savannah of Envious Eyes 0x1B Arena of Tolerance 0x1C Tomb of Tolerance 0x1D Depths of Jealousy 0x3E DLC Mission selector Example Here is one example in hex: 25 1c 14 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 3c 00 00 00 / 02 00 00 00 / 3d 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 08 00 00 00 / 39 00 00 00 / 08 00 00 00 / 3a 00 00 00 / 4d 69 73 73 / 69 6f 6e 5f / 30 31 5f 30 / 30 2e 70 61 / 63 00 00 00 Which is interpreted as: addQuest((int)1, (int)1, (int)60, (int)61, (int)1, (int)0, (int)1, (int)1, ((global)int *)giVar57, ((global)int *)giVar58, \"Mission_01_00.pac\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4e958(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; int *piVar6; int iVar7; int iVar8; undefined4 uVar9; int iVar10; int iVar11; undefined4 uVar12; undefined4 uVar13; undefined4 uVar14; undefined4 uVar15; undefined4 uVar16; undefined auStack256 [256]; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar14 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar13 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar16 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar15 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); uVar2 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); uVar3 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); uVar5 = *puVar1; piVar6 = (int *)Pac_Get_Param(param_2,8,1,4); iVar7 = *piVar6; piVar6 = (int *)Pac_Get_Param(param_2,9,1,4); iVar8 = *piVar6; uVar9 = FUN_0883bc34(param_2); Pac_Get_StringParam(param_2,auStack256); if (((*(int *)(param_1 + 0x10) != 0) && (iVar10 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar10 != 0)) && (iVar10 = FUN_Azito__08b5a738(*(undefined4 *)(iVar10 + 0x38),2,uVar14,uVar13), iVar10 != 0)) { iVar11 = Save::Get_Save_BaseAddr(1); *(undefined4 *)(iVar10 + 0x98) = 2; *(undefined *)(iVar10 + 0x94) = 1; uVar12 = FUN_Azito__08b50680(param_1); uVar15 = Message::Get_Message(iVar11 + 0x98,uVar12,uVar15); uVar12 = FUN_Azito__08b50680(param_1); uVar16 = Message::Get_Message(iVar11 + 0x98,uVar12,uVar16); *(undefined4 *)(iVar10 + 0x9c) = 0xffffffff; *(undefined4 *)(iVar10 + 0xa0) = 0xffffffff; *(undefined4 *)(iVar10 + 0xa4) = 1; *(undefined4 *)(iVar10 + 0xa8) = 0; *(undefined4 *)(iVar10 + 0xac) = 0; *(undefined4 *)(iVar10 + 0xb0) = 0; *(undefined4 *)(iVar10 + 0xb4) = 0; *(undefined4 *)(iVar10 + 0xb8) = 0; *(undefined4 *)(iVar10 + 0xbc) = 0xffffffff; *(undefined4 *)(iVar10 + 0xc0) = 0; *(undefined4 *)(iVar10 + 0xc4) = 0; *(undefined4 *)(iVar10 + 200) = 1; *(undefined *)(iVar10 + 0xcc) = 0; *(undefined *)(iVar10 + 0xcd) = 1; *(undefined4 *)(iVar10 + 0x9c) = uVar14; *(undefined4 *)(iVar10 + 0xa0) = uVar13; *(undefined4 *)(iVar10 + 0xa4) = uVar2; *(undefined4 *)(iVar10 + 0xa8) = uVar3; *(undefined4 *)(iVar10 + 0xac) = uVar9; *(undefined4 *)(iVar10 + 0xb0) = uVar16; *(undefined4 *)(iVar10 + 0xb4) = uVar15; *(undefined4 *)(iVar10 + 0xb8) = 0; *(undefined4 *)(iVar10 + 0xbc) = 0xffffffff; *(undefined4 *)(iVar10 + 0xc0) = 0; // story or non-story mission? 0x1: non-story *(undefined4 *)(iVar10 + 0xc4) = uVar4; *(undefined4 *)(iVar10 + 200) = uVar5; // \"new mission\" *(bool *)(iVar10 + 0xcc) = iVar7 != 0; // \"if Mission finished\" flag *(bool *)(iVar10 + 0xcd) = iVar8 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addquestcompensationdata.html": {
    "href": "addquestcompensationdata.html",
    "title": "addQuestCompensationData",
    "keywords": "addQuestCompensationData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addQuestCompensationData Scope: Global PAC Instruction (Binary): 25 0a 19 00 Assembly Address in Memory : 0x894af38 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 0a 19 00 / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: addQuestCompensationData((int)-1, (int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894af38(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; int iVar5; undefined4 uVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar7 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar6 = *puVar2; piVar1 = (int *)Pac_Get_Param(param_2,2,1,4); iVar3 = *piVar1; uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); if (iVar3 == 0) { iVar3 = *(int *)(iVar5 + 0x44) + 2000; } else { iVar3 = *(int *)(iVar5 + 0x44) + 0x788; } if (iVar7 == -1) { FUN_08a15500(iVar3); } else if (iVar7 == -2) { FUN_08a15674(iVar3,uVar6); } else { FUN_08a15550(iVar3,iVar7,uVar6); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addskill.html": {
    "href": "addskill.html",
    "title": "addSkill",
    "keywords": "addSkill Applies set skill or class skill to a unit. Code Information Name: addSkill Scope: Global PAC Instruction (Binary): 25 16 2d 00 Assembly Address in Memory : 0x891c500 Parameters (int *)handle_id (8 bytes) : Unit handle to apply the skill. (int)skill_id (8 bytes) : Set skill or Class skill ID to apply to a unit. Example Here is one example in hex: 25 16 2d 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / 84 00 00 00 Which is interpreted as: addSkill((int *)iVar54, (int)132) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891c500(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { SS_Controller::Select_SS(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addsquad.html": {
    "href": "addsquad.html",
    "title": "addSquad",
    "keywords": "addSquad Adds squad to a troop. Shouldn't be used much except adding player team. For adding enemy units, consider reqActor with getUnitSquadHandle. Code Information Name: addSquad Scope: Global PAC Instruction (Binary): 25 16 22 00 Assembly Address in Memory : 0x891bacc Parameters (int *)destination (8 bytes) : Variable to store the squad handle. (int *)troop_handle (8 bytes) : The troop handle. Example Here is one example in hex: 25 16 22 00 / 04 00 00 00 / 35 00 00 00 / 04 00 00 00 / 34 00 00 00 Which is interpreted as: addSquad((int *)iVar53, (int *)iVar52) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891bacc(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 2)) && (iVar3 = FUN_088deaa0(iVar3), iVar3 != 0)) { *piVar1 = (int)*(short *)(iVar3 + 0x78); FUN_088c45f0(iVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addstage_25165d00.html": {
    "href": "addstage_25165d00.html",
    "title": "addStage (25165d00)",
    "keywords": "addStage (25165d00) Other functions have the same name. Check the Disambiguation page to find them. Defines the stage. This requires readArcFile and setStageParam being called before. More information in How To: Setup Stages. Code Information Name: addStage Scope: Global PAC Instruction (Binary): 25 16 5d 00 Assembly Address in Memory : 0x891fdfc Parameters Warning Not all layers can be controlled with this. (int)background_index (8 bytes) : Decides what to render in the place of the misc layer. (int)back_object_index (8 bytes) : Decides what to render in the place of back of the back object layer. (int)middle_object_index (8 bytes): Decides what to render in the place of the middle object layer. (int)top_object_index (8 bytes): Decides what to render in the place of e.g. grass layer of the stage (topmost layer). (int)other_top_object_index (8 bytes): Decides what to render in the place of other topmost layer, not used in most casees. (String)stage_name : Name of the stage. If doubt, set all index to zero. Each scene might or might not contain the layer. The index is index in the each different layer. If the object index does not exist, it does not render anything in that layer. In many cases, a stage contain 0~1 image per layer, but sometimes it has multiple layers (e.g. in middle of the layer might contain structure images in index 1). For more information, check Understanding the Stage Layers. Remarks The *skip\" booleans also affect to the resource loading. The maximum stage that can be loaded in one mission is 21. Otherwise mission won't be loaded. Example Here is one example in hex: 25 16 5d 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 73 74 67 30 / 34 34 00 00 Which is interpreted as: addStage((int)0, (int)0, (int)0, (int)0, (int)0, \"stg044\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891fdfc(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined *puVar7; undefined *puVar8; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar7 = &DAT_00000100; puVar8 = local_100; puVar1 = puVar8; while (puVar1 != (undefined *)0x0) { *puVar8 = 0; puVar8 = puVar8 + 1; puVar7 = puVar7 + -1; puVar1 = puVar7; } Pac_Get_StringParam(param_2,local_100); FUN_088b0404(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118),local_100,*puVar2,*puVar3,*puVar4, *puVar5,*puVar6); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addstage_251c1300.html": {
    "href": "addstage_251c1300.html",
    "title": "addStage (251c1300)",
    "keywords": "addStage (251c1300) Other functions have the same name. Check the Disambiguation page to find them. Setups stages to the world map to make them selectable. Code Information Name: addStage Scope: Azito PAC Instruction (Binary): 25 1c 13 00 Assembly Address in Memory : 0x8b4e310 Parameters (int)group_id (8 bytes) : Mission Group ID, 0x3E is DLC mission. (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (int)title_msg (8 bytes) : Title message index in worldmapmsg.msg. This is not PAC instruction message table. (int)description_msg (8 bytes) : Description message index in worldmapmsg.msg. This is not PAC instruction message table. (int)left_nav_id (8 bytes) : Mission Group ID to select when being moved left. Keep -1 to move left normally. (int)right_nav_id (8 bytes) : Mission Group ID to select when being moved right. Keep -1 to move right normally. (int)up_nav_id (8 bytes) : Mission Group ID to select when being moved up. Keep -1 for default value. (int)down_nav_id (8 bytes) : Mission Group ID to select when being moved down. Keep -1 for default value. (undefined4)Var9 (8 bytes) (float)Var10 (8 bytes) (float)Var11 (8 bytes) (int)Var12 (8 bytes) (String)nav_icon_name1 : Icon name 1 (String)nav_icon_name2 : Icon name 2 (String)nav_icon_name3 : Icon name 3 (String)nav_icon_name4 : Icon name 4 Example Here is one example in hex: 25 1c 13 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 04 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 40 00 00 00 / dc 00 00 00 / 02 00 00 00 / 00 00 00 00 / 6d 69 63 6f / 6e 5f 30 31 / 30 00 00 00 / 63 6f 6e 5f / 30 31 30 00 / 6d 69 63 6f / 6e 5f 30 31 / 30 00 00 00 / 63 6f 6e 5f / 30 31 30 00 Which is interpreted as: addStage((int)1, (int)0, (int)0, (int)0, (int)1, (int *)iVar1, (int *)iVar2, (int *)iVar3, (int *)iVar4, (int)0, (float)1, ((global)float *)gfVar220, (int)0, \"micon_010\", \"con_010\", \"micon_010\", \"con_010\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4e310(int param_1,undefined4 param_2) { bool bVar1; char cVar2; undefined4 *puVar3; undefined4 uVar4; undefined4 uVar5; undefined4 uVar6; undefined4 uVar7; undefined4 uVar8; undefined4 uVar9; undefined4 uVar10; undefined4 uVar11; undefined4 uVar12; undefined4 uVar13; int iVar14; int iVar15; undefined4 uVar16; uint uVar17; int iVar18; undefined4 uVar19; undefined4 uVar20; undefined4 uVar21; undefined4 uVar22; undefined4 uVar23; undefined4 uVar24; undefined auStack284 [4]; undefined auStack280 [4]; undefined auStack276 [4]; undefined auStack272 [4]; undefined auStack268 [4]; undefined auStack264 [4]; undefined local_104 [4]; undefined auStack256 [256]; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar20 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar19 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar4 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar22 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); uVar21 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); uVar5 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); uVar6 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); uVar7 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,8,1,4); uVar8 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,9,1,4); uVar9 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,10,1,4); uVar23 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0xb,1,4); uVar24 = *puVar3; Pac_Get_Param(param_2,0xc,1,4); uVar10 = FUN_0883bc34(param_2); Pac_Get_StringParam(param_2,auStack256); uVar11 = FUN_0883bc34(param_2); Pac_Get_StringParam(param_2,auStack256); uVar12 = FUN_0883bc34(param_2); Pac_Get_StringParam(param_2,auStack256); uVar13 = FUN_0883bc34(param_2); Pac_Get_StringParam(param_2,auStack256); if (((*(int *)(param_1 + 0x10) != 0) && (iVar14 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar14 != 0)) && (iVar14 = FUN_Azito__08b5a738(*(undefined4 *)(iVar14 + 0x38),1,uVar20,uVar19), iVar14 != 0)) { iVar15 = Save::Get_Save_BaseAddr(1); *(undefined4 *)(iVar14 + 0x98) = 1; *(undefined *)(iVar14 + 0x94) = 1; uVar16 = FUN_Azito__08b50680(param_1); uVar21 = Message::Get_Message(iVar15 + 0x98,uVar16,uVar21); uVar16 = FUN_Azito__08b50680(param_1); uVar22 = Message::Get_Message(iVar15 + 0x98,uVar16,uVar22); FUN_Azito__08b4e908(iVar14 + 0x9c); *(undefined4 *)(iVar14 + 0x9c) = uVar20; *(undefined4 *)(iVar14 + 0xa0) = uVar19; *(undefined4 *)(iVar14 + 0xa4) = uVar4; *(undefined4 *)(iVar14 + 0xa8) = uVar10; *(undefined4 *)(iVar14 + 0xb0) = uVar11; *(undefined4 *)(iVar14 + 0xb4) = uVar12; *(undefined4 *)(iVar14 + 0xb8) = uVar13; *(undefined4 *)(iVar14 + 0xbc) = uVar22; *(undefined4 *)(iVar14 + 0xc0) = uVar21; *(undefined4 *)(iVar14 + 0xc4) = uVar5; *(undefined4 *)(iVar14 + 200) = uVar6; *(undefined4 *)(iVar14 + 0xcc) = uVar7; *(undefined4 *)(iVar14 + 0xd0) = uVar8; *(undefined4 *)(iVar14 + 0xd4) = uVar9; *(undefined4 *)(iVar14 + 0xd8) = uVar23; *(undefined4 *)(iVar14 + 0xdc) = uVar24; iVar14 = *(int *)(iVar14 + 0x3c) + 0x18; local_104[0] = 0; uVar17 = FUN_Azito__08b4e900(iVar14); if (1 < uVar17) { do { FUN_Azito__08b4e8f0(auStack264,iVar14); FUN_Azito__08b4e8e0(auStack268,auStack264); bVar1 = false; while( true ) { FUN_Azito__08b4e8d0(auStack268,auStack264); FUN_Azito__08b4e8a8(auStack272,auStack268,0); FUN_Azito__08b4e8a0(auStack276,iVar14); iVar15 = FUN_Azito__08b4e860(auStack264,auStack276); if (iVar15 != 0) break; FUN_Azito__08b4e8a0(auStack280,iVar14); iVar15 = FUN_Azito__08b4e860(auStack268,auStack280); if ((iVar15 != 0) || (iVar15 = FUN_Azito__08b4e860(auStack264,auStack268), iVar15 != 0)) break; iVar15 = FUN_Azito__08b4e858(auStack264); iVar18 = FUN_Azito__08b4e858(auStack268); cVar2 = FUN_Azito__08b4e848(local_104,*(undefined4 *)(iVar15 + 8), *(undefined4 *)(iVar18 + 8)); if (cVar2 == '\\0') { FUN_Azito__08b4e8a8(auStack284,auStack264,0); } else { uVar4 = FUN_Azito__08b4e840(auStack264); uVar5 = FUN_Azito__08b4e840(auStack268); FUN_Azito__08b4e768(uVar4,uVar5); bVar1 = true; } } } while (bVar1); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addsybolmarkgimmick.html": {
    "href": "addsybolmarkgimmick.html",
    "title": "addSybolMarkGimmick",
    "keywords": "addSybolMarkGimmick Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addSybolMarkGimmick Scope: Global PAC Instruction (Binary): 25 16 e1 00 Assembly Address in Memory : 0x8926740 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 16 e1 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 01 00 00 00 / 08 00 00 00 / 8a 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: addSybolMarkGimmick((int *)iVar3, (int *)iVar1, ((global)int *)giVar138, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926740(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4, undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8) { undefined *puVar1; int *piVar2; int *piVar3; undefined4 *puVar4; undefined *puVar5; int iVar6; undefined *puVar7; undefined4 discpath; undefined4 filepath; undefined4 uVar8; undefined4 uVar9; int iVar10; undefined local_40 [64]; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); piVar3 = (int *)Pac_Get_Param(param_2,1,1,4); iVar10 = *piVar3; puVar4 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar8 = *puVar4; discpath = 1; filepath = 4; puVar4 = (undefined4 *)Pac_Get_Param(param_2,3); uVar9 = *puVar4; *piVar2 = -1; puVar5 = (undefined *)0x40; puVar7 = local_40; puVar1 = puVar7; while (puVar1 != (undefined *)0x0) { *puVar7 = 0; puVar7 = puVar7 + 1; puVar5 = puVar5 + -1; puVar1 = puVar5; } if (iVar10 == -1) { Data::Load_from_path (local_40,s_TeamFlagMissionDefault_08a5fd70,discpath,filepath,param_5,param_6,param_7, param_8); iVar10 = *(int *)(param_1 + 0x10); } else { Data::Load_from_path (local_40,s_TeamFlagMission_04d_08a5fd88,iVar10,filepath,param_5,param_6,param_7, param_8); iVar10 = *(int *)(param_1 + 0x10); } if (iVar10 == 0) { iVar10 = 0; } iVar10 = Find_Target_By_HandleID(*(undefined4 *)(iVar10 + 0xe8),uVar8,1); if (iVar10 != 0) { iVar6 = *(int *)(param_1 + 0x10); if (iVar6 == 0) { iVar6 = 0; } iVar6 = Place_Gimmick_Caller (*(undefined4 *)(iVar6 + 0x108),599,(int)*(char *)(iVar10 + 0x98),0,local_40); Gimmick::Gimmick_Set_Position(iVar6,iVar10,uVar9,0); *(uint *)(iVar6 + 0x120) = *(uint *)(iVar6 + 0x120) | 8; *piVar2 = (int)*(short *)(iVar6 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addtimer.html": {
    "href": "addtimer.html",
    "title": "addTimer",
    "keywords": "addTimer Adds time to the existing timer. Need to activate counter first with startTimer. Code Information Name: addTimer Scope: Global PAC Instruction (Binary): 25 16 9e 00 Assembly Address in Memory : 0x89226b0 Parameters (float)time (8 bytes) : Time as seconds to add. Example Here is one example in hex: 25 16 9e 00 / 10 00 00 00 / 00 00 20 41 Which is interpreted as: addTimer((float)10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089226b0(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (*(int *)(iVar2 + 100) != 0)) { func_0x08b32e60(*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addtroop.html": {
    "href": "addtroop.html",
    "title": "addTroop",
    "keywords": "addTroop Adds sides for the team. For PVE, 0 is player side. Hatapon is unaffected to this. For VS, it is blue team (0) and red team (1). In normal PVE field, local int 34 tends to be player troop. Code Information Name: addTroop Scope: Global PAC Instruction (Binary): 25 16 1f 00 Assembly Address in Memory : 0x891b8dc Parameters (int *)troop_handle (8 bytes) : Variable to store the troop handle. (int)team_side (8 bytes) : 0 is player side, 1 is enemy side. Example Here is one example in hex: 25 16 1f 00 / 08 00 00 00 / 68 00 00 00 / 08 00 00 00 / 67 00 00 00 Which is interpreted as: addTroop(((global)int *)giVar104, ((global)int *)giVar103) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b8dc(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *piVar1 = -1; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((iVar3 != 0) && (iVar3 = FUN_088a858c(iVar3,*puVar2), iVar3 != 0)) { *piVar1 = (int)*(short *)(iVar3 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addvector.html": {
    "href": "addvector.html",
    "title": "addVector",
    "keywords": "addVector Adds force to the model. For consistent velocity, consider using another method. Code Information Name: addVector Scope: Global PAC Instruction (Binary): 25 17 14 00 Assembly Address in Memory : 0x891208c Parameters (int *)handle_id (8 bytes) : The target handle to give the force. (float)scale (8 bytes) : The power, how much force will give to the target. (float)direction_x (8 bytes) : X direction of the force. (float)direction_y (8 bytes) : Y Direction of the force. Example Here is one example in hex: 25 17 14 00 / 04 00 00 00 / 41 00 00 00 / 10 00 00 00 / 00 00 00 3f / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 bf Which is interpreted as: addVector((int *)iVar65, (float)0.5, (float)0, (float)-0.5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891208c(int param_1,undefined4 param_2) { undefined4 *puVar1; float *pfVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; float fVar6; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (param_1 == 0) { iVar5 = 0; } else { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 == 0) { iVar5 = 0; } else { iVar5 = *(int *)(iVar5 + 200); if (iVar5 == 0) { iVar5 = 0; } } } if (iVar5 != 0) { fVar6 = *pfVar2; *(float *)(iVar5 + 0xe0) = *(float *)(iVar5 + 0xe0) * fVar6; *(float *)(iVar5 + 0xe4) = *(float *)(iVar5 + 0xe4) * fVar6; *(undefined4 *)(iVar5 + 0xec) = 0; local_c = *puVar4; local_10 = *puVar3; local_4 = 0x3f800000; local_8 = 0; FUN_0888e460(iVar5,&local_10,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "addvectroopp.html": {
    "href": "addvectroopp.html",
    "title": "addVecTroopP",
    "keywords": "addVecTroopP Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: addVecTroopP Scope: Global PAC Instruction (Binary): 25 21 19 00 Assembly Address in Memory : 0x89b2e4c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 21 19 00 / 04 00 00 00 / 14 00 00 00 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: addVecTroopP((int *)iVar20, (float *)fVar1, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2e4c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; int iVar6; int iVar7; int iVar8; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; undefined auStack24 [4]; undefined auStack20 [4]; undefined auStack16 [4]; undefined auStack12 [4]; undefined auStack8 [4]; undefined auStack4 [4]; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar4 != 0) { local_2c = *puVar3; local_30 = *puVar2; local_24 = 0x3f800000; local_28 = 0; iVar6 = *(int *)(iVar4 + 0x80); FUN_088ccd30(auStack4); uVar5 = FUN_0887de78(iVar6 + 0x40); FUN_0887b8d0(auStack12,uVar5); FUN_0887dd44(auStack4,auStack12); uVar5 = FUN_0887de78(iVar6 + 0x40); FUN_0887b8c8(auStack24,uVar5); iVar4 = FUN_0887b7f4(auStack4,auStack24); while (iVar4 != 0) { iVar4 = FUN_0887dcfc(auStack4); iVar8 = *(int *)(iVar4 + 8); iVar4 = (**(code **)(*(int *)(iVar8 + 4) + 0x34))(iVar8); if (iVar4 == 3) { FUN_088ccd30(auStack8); uVar5 = FUN_0887de78(iVar8 + 0x40); FUN_0887b8d0(auStack16,uVar5); FUN_0887dd44(auStack8,auStack16); uVar5 = FUN_0887de78(iVar8 + 0x40); FUN_0887b8c8(auStack20,uVar5); iVar4 = FUN_0887b7f4(auStack8,auStack20); while (iVar4 != 0) { iVar4 = FUN_0887dcfc(auStack8); iVar7 = *(int *)(iVar4 + 8); iVar4 = (**(code **)(*(int *)(iVar7 + 4) + 0x34))(iVar7); if (iVar4 == 9) { FUN_089b3074(&local_30,iVar7); } FUN_088ccd10(auStack8); uVar5 = FUN_0887de78(iVar8 + 0x40); FUN_0887b8c8(auStack20,uVar5); iVar4 = FUN_0887b7f4(auStack8,auStack20); } } FUN_088ccd10(auStack4); uVar5 = FUN_0887de78(iVar6 + 0x40); FUN_0887b8c8(auStack24,uVar5); iVar4 = FUN_0887b7f4(auStack4,auStack24); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "allclearactorwindow.html": {
    "href": "allclearactorwindow.html",
    "title": "allClearActorWindow",
    "keywords": "allClearActorWindow Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: allClearActorWindow Scope: Global PAC Instruction (Binary): 25 17 61 00 Assembly Address in Memory : 0x8917dbc Parameters This function is parameterless. Example Here is one example in hex: 25 17 61 00 Which is interpreted as: allClearActorWindow() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917dbc(int param_1,undefined4 param_2) { FUN_0887c324(*(undefined4 *)(param_1 + 0x14)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "allreset.html": {
    "href": "allreset.html",
    "title": "allReset",
    "keywords": "allReset Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: allReset Scope: Global PAC Instruction (Binary): 25 0b 07 00 Assembly Address in Memory : 0x896fbe4 Parameters This function is parameterless. Example Here is one example in hex: 25 0b 07 00 Which is interpreted as: allReset() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896fbe4(int param_1,undefined4 param_2) { FUN_088e6e30(*(undefined4 *)(param_1 + 0x14)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "appeardeaditems.html": {
    "href": "appeardeaditems.html",
    "title": "appearDeadItems",
    "keywords": "appearDeadItems Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: appearDeadItems Scope: Global PAC Instruction (Binary): 25 21 1f 00 Assembly Address in Memory : 0x89b34ec Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b34ec(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { FUN_08975b6c(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "appearitem.html": {
    "href": "appearitem.html",
    "title": "appearItem",
    "keywords": "appearItem Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: appearItem Scope: Global PAC Instruction (Binary): 25 17 46 00 Assembly Address in Memory : 0x8915bfc Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 17 46 00 / 04 00 00 00 / 14 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: appearItem((int *)iVar20, (float *)fVar0, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915bfc(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if ((*piVar1 != -1) && (iVar4 = FUN_08910c4c(param_1), iVar4 != 0)) { local_c = *puVar3; local_10 = *puVar2; local_4 = 0x3f800000; local_8 = 0; FUN_0896e240(iVar4,1,&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "appearstaggeritems.html": {
    "href": "appearstaggeritems.html",
    "title": "appearStaggerItems",
    "keywords": "appearStaggerItems Force drop the staggered item from a boss. Code Information Name: appearStaggerItems Scope: Global PAC Instruction (Binary): 25 21 1e 00 Assembly Address in Memory : 0x89b3484 Parameters (int *)squad_handle (8 bytes): Squad Handle ID of the boss. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3484(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { FUN_08975c00(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "applyconstgimmick.html": {
    "href": "applyconstgimmick.html",
    "title": "applyConstGimmick",
    "keywords": "applyConstGimmick Applies all const gimmick defined from registConstGimmick. Code Information Name: applyConstGimmick Scope: Global PAC Instruction (Binary): 25 16 c0 00 Assembly Address in Memory : 0x8923fa8 Parameters This function is parameterless. Example Here is one example in hex: 25 16 c0 00 Which is interpreted as: applyConstGimmick() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923fa8(int param_1,undefined4 param_2) { FUN_089f077c(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x7e44); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "applystage.html": {
    "href": "applystage.html",
    "title": "applyStage",
    "keywords": "applyStage Applies a stage in given index. The index is decided in startSetupStage. Code Information Name: applyStage Scope: Global PAC Instruction (Binary): 25 16 5f 00 Assembly Address in Memory : 0x8920078 Parameters (int)stage_index (8 bytes) : Stage index from startSetupStage. Example Here is one example in hex: 25 16 5f 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: applyStage((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920078(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_088b03fc(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118)); FUN_088b0624(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118),*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "applyunit.html": {
    "href": "applyunit.html",
    "title": "applyUnit",
    "keywords": "applyUnit Applies the unit setup. Affects e.g. character action. Code Information Name: applyUnit Scope: Global PAC Instruction (Binary): 25 16 31 00 Assembly Address in Memory : 0x891cbbc Parameters This function is parameterless. Example Here is one example in hex: 25 16 31 00 Which is interpreted as: applyUnit() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891cbbc(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(param_1 + 0x10); if (iVar1 == 0) { iVar1 = 0; } else { if (iVar1 == 0) { iVar1 = 0; } iVar1 = *(int *)(iVar1 + 0xf8); if (iVar1 == 0) { iVar1 = 0; } } if (iVar1 != 0) { FUN_088a94d4(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "beginappearitem.html": {
    "href": "beginappearitem.html",
    "title": "beginAppearItem",
    "keywords": "beginAppearItem Declares start of the item table with the given ID. Code Information Name: beginAppearItem Scope: Global PAC Instruction (Binary): 25 08 02 00 Assembly Address in Memory : 0x896e808 Parameters (int)item_table_id (8 bytes) : ID of the Item table, will be used by e.g. setReqActorItemTable later. Example Here is one example in hex: 25 08 02 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: beginAppearItem((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896e808(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x188); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_08952fdc(iVar2,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "calccommonparam.html": {
    "href": "calccommonparam.html",
    "title": "calcCommonParam",
    "keywords": "calcCommonParam Settles some squad handle values to squadlineparam. Please describe the detail. Code Information Name: calcCommonParam Scope: Global PAC Instruction (Binary): 25 16 45 00 Assembly Address in Memory : 0x891e180 Parameters (int *)squad_handle (8 bytes) : ID of the Squad handle to set the values. (int)squadlineparam_id (8 bytes) : ID of the squadlineparam_id to apply to the handle. Example Here is one example in hex: 25 16 45 00 / 04 00 00 00 / 14 00 00 00 / 02 00 00 00 / 43 04 00 00 Which is interpreted as: calcCommonParam((int *)iVar20, (int)1091) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e180(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { FUN_088f7da4(iVar3 + 0x1f0,*puVar2,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "calcvolumerate.html": {
    "href": "calcvolumerate.html",
    "title": "calcVolumeRate",
    "keywords": "calcVolumeRate Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: calcVolumeRate Scope: Global PAC Instruction (Binary): 25 0b 09 00 Assembly Address in Memory : 0x896fe60 Parameters (undefined4)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Here is one example in hex: 25 0b 09 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 04 00 00 00 / 20 00 00 00 / 05 00 00 00 Which is interpreted as: calcVolumeRate((float *)fVar0, (float *)fVar4, (float *)fVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896fe60(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_Param(param_2,2,1,4); FUN_088e7114(*puVar1,*(undefined4 *)(param_1 + 0x14),uVar2,uVar3); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callActorScript.html": {
    "href": "callActorScript.html",
    "title": "callActorScript",
    "keywords": "callActorScript There are few functions with the same name: callActorScript (25172b00) (Global) callActorScript (25160300) (Global) callActorScript (251c0300) (Azito)"
  },
  "callactoreffect.html": {
    "href": "callactoreffect.html",
    "title": "callActorEffect",
    "keywords": "callActorEffect Cast effect originated from an actor/handle. Code Information Name: callActorEffect Scope: Global PAC Instruction (Binary): 25 17 2c 00 Assembly Address in Memory : 0x89138f8 Parameters (int *)handle_id (8 bytes) : The target handle. (int)effect_id (8 bytes) : ID of the effect. (int)parent_node (8 bytes) : Parent node ID to append. (float)Var3_x (8 bytes) (float)Var4_y (8 bytes) (float)Var5_x (8 bytes) (float)Var6_y (8 bytes) Remarks The desired effect must be preloaded through readArcFile before calling this. The effect created with this can't deal actual damage. Consider using addEffect for dealing damage. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089138f8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; int iVar8; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); if (*piVar1 != -1) { iVar8 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar8 == 0) { iVar8 = 0; } if (iVar8 != 0) { local_1c = *puVar7; local_20 = *puVar6; local_18 = 0; local_14 = 0x3f800000; local_c = *puVar5; local_10 = *puVar4; local_4 = 0x3f800000; local_8 = 0; Action::Trigger_Effect(0x3f800000,iVar8,*puVar2,*puVar3,&local_10,&local_20,0xffffffff,0,4,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callactorscript_25160300.html": {
    "href": "callactorscript_25160300.html",
    "title": "callActorScript (25160300)",
    "keywords": "callActorScript (25160300) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: callActorScript Scope: Global PAC Instruction (Binary): 25 16 03 00 Assembly Address in Memory : 0x8919120 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919120(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int *piVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (piVar5 = *(int **)(*(int *)(param_1 + 0x10) + 0x168), piVar5 = (int *)(**(code **)(*piVar5 + 0xc))(piVar5,*puVar1,*puVar2,1,0,*puVar3,*puVar4), piVar5 != (int *)0x0)) { (**(code **)(*piVar5 + 0x10))(piVar5,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callactorscript_25172b00.html": {
    "href": "callactorscript_25172b00.html",
    "title": "callActorScript (25172b00)",
    "keywords": "callActorScript (25172b00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: callActorScript Scope: Global PAC Instruction (Binary): 25 17 2b 00 Assembly Address in Memory : 0x891378c Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891378c(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; undefined auStack24 [24]; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); if (*piVar1 != -1) { if (param_1 == 0) { iVar6 = 0; } else { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar6 == 0) { iVar6 = 0; } if (iVar6 == 0) { iVar6 = 0; } else { iVar6 = *(int *)(iVar6 + 0xd4); if (iVar6 == 0) { iVar6 = 0; } } } if (iVar6 != 0) { FUN_0890949c(auStack24); FUN_089094c8(auStack24,*puVar2,*puVar3,*puVar4,*puVar5,1,0); (**(code **)(*(int *)(iVar6 + 0x7c) + 0x14))(iVar6 + 0x10,auStack24); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callactorscript_251c0300.html": {
    "href": "callactorscript_251c0300.html",
    "title": "callActorScript (251c0300)",
    "keywords": "callActorScript (251c0300) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: callActorScript Scope: Azito PAC Instruction (Binary): 25 1c 03 00 Assembly Address in Memory : 0x8b4d2a0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d2a0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int *piVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (piVar5 = *(int **)(*(int *)(param_1 + 0x10) + 0x1a4), piVar5 = (int *)(**(code **)(*piVar5 + 0xc))(piVar5,*puVar1,*puVar2,1,0,*puVar3,*puVar4), piVar5 != (int *)0x0)) { (**(code **)(*piVar5 + 0x10))(piVar5,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callbossretreatendinit.html": {
    "href": "callbossretreatendinit.html",
    "title": "callBossRetreatEndInit",
    "keywords": "callBossRetreatEndInit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: callBossRetreatEndInit Scope: Global PAC Instruction (Binary): 25 21 14 00 Assembly Address in Memory : 0x89b283c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 21 14 00 / 04 00 00 00 / 14 00 00 00 Which is interpreted as: callBossRetreatEndInit((int *)iVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b283c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { (**(code **)(*(int *)(iVar2 + 0xc) + 0x2c))(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "calllocalizemessagewindow.html": {
    "href": "calllocalizemessagewindow.html",
    "title": "callLocalizeMessageWindow",
    "keywords": "callLocalizeMessageWindow Makes speech bubble on a specific target, but the message ID is NOT from the PAC message table. Please add detail description if you know what this does. See also How To: Set Speech Bubble Code Information Name: callLocalizeMessageWindow Scope: Global PAC Instruction (Binary): 25 17 62 00 Assembly Address in Memory : 0x8917df0 Parameters (int *)handle_id (8 bytes) : Handle to set thue bubble above. (int *)destination (8 bytes) : Destination to store message handle. (float)position_x (8 bytes) : X offset to move the bubble, as PSP screen pixels. (float)position_y (8 bytes) : Y offset to move the bubble, as PSP screen pixels. (float)Var4 (8 bytes) : ??? (If this is smaller than zero, the text is \"typed\"), it is usually -1, 0, 3, 4. (undefined4)Var5 (8 bytes) (undefined4)Var6 (8 bytes) (int)local_msg_value (8 bytes) : Affects Message ID. Example Here is one example in hex: 25 17 62 00 / 08 00 00 00 / 1f 00 00 00 / 08 00 00 00 / 37 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 8c 42 / 10 00 00 00 / 00 00 80 bf / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: callLocalizeMessageWindow(((global)int *)giVar31, ((global)int *)giVar55, (float)0, (float)70, (float)-1, (int)-1, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917df0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; int *piVar8; int iVar9; uint uVar10; undefined4 uVar11; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); piVar8 = (int *)Pac_Get_Param(param_2,7,1,4); if (*piVar8 == 0) { _DAT_08ab951c = 0; PAC::PAC_setCmdId(param_2,0); } else { iVar9 = Save::Get_Save_BaseAddr(1); uVar10 = FUN_08a0c324(iVar9 + 0x98,0); uVar11 = Message::Get_MsgAddr_With_FullID(iVar9 + 0x98,_DAT_08ab951c); if (*piVar1 != -1) { iVar9 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar9 == 0) { iVar9 = 0; } if (iVar9 != 0) { uVar11 = (**(code **)(*(int *)(iVar9 + 4) + 0xec)) (*puVar3,*puVar4,*puVar5,iVar9,uVar11,*puVar6,*puVar7,1,1); *puVar2 = uVar11; } } if ((int)(_DAT_08ab951c + *piVar8) < 0) { _DAT_08ab951c = uVar10 - 1; } else { _DAT_08ab951c = (_DAT_08ab951c + *piVar8) % uVar10; if (uVar10 == 0) { trap(7); } } PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "callmessagewindow.html": {
    "href": "callmessagewindow.html",
    "title": "callMessageWindow",
    "keywords": "callMessageWindow Makes speech bubble on a specific target. See also How To: Set Speech Bubble Code Information Name: callMessageWindow Scope: Global PAC Instruction (Binary): 25 17 2d 00 Assembly Address in Memory : 0x8913aa0 Parameters (int *)handle_id (8 bytes) : Handle to set thue bubble above. (int *)destination (8 bytes) : Destination to store message handle. (float)position_x (8 bytes) : X offset to move the bubble, as PSP screen pixels. (float)position_y (8 bytes) : Y offset to move the bubble, as PSP screen pixels. (float)duratoin (8 bytes) : Time as seconds to show the message. If this is smaller than zero, this functions like keyCloseMessageWindow, except the window can't be closed without closeMessageWindow. (int)node_id (8 bytes) : Node ID to put the speech bubble, keep -1 for root (default) node. (int)Var6 (8 bytes) : Seems like it does not do anything, but keep this as 0. (Address)message_address (4 bytes) : Message ID from message address table in the PAC file. Details on: about message table. (int)hide_long_message (8 bytes) : The value is is 1 or not. If this is 1, Long message will be invisible. Note that PSP screen size is 480 x 272. Example Here is one example in hex: 25 17 2d 00 / 04 00 00 00 / 0a 00 00 00 / 08 00 00 00 / 5b 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 48 42 / 10 00 00 00 / 00 00 80 bf / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / 00 00 00 00 / 0c e6 05 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: callMessageWindow((int *)iVar10, ((global)int *)giVar91, (float)0, (float)50, (float)-1, (int)-1, (int)0, 0x5e60c, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913aa0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int *piVar6; undefined4 *puVar7; undefined4 *puVar8; int *piVar9; undefined4 uVar10; int iVar11; int iVar12; int iVar13; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,7,0,4); piVar9 = (int *)Pac_Get_Param(param_2,8,1,4); uVar10 = Get_FullMessage(param_2,*puVar8); if (*piVar1 != -1) { iVar11 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar11 == 0) { iVar11 = 0; } if (iVar11 != 0) { iVar13 = *piVar6; if (iVar13 == -2) { piVar1 = *(int **)(*(int *)(iVar11 + 200) + 0x60); if (piVar1 == (int *)0x0) { iVar13 = -1; } else { iVar13 = (**(code **)(*piVar1 + 0x48))(piVar1,s_body_08a5c9b8); } iVar12 = *piVar9; } else { iVar12 = *piVar9; } uVar10 = (**(code **)(*(int *)(iVar11 + 4) + 0xec)) (*puVar3,*puVar4,*puVar5,iVar11,uVar10,iVar13,*puVar7,iVar12 == 1,1); *puVar2 = uVar10; (**(code **)(*(int *)(iVar11 + 4) + 0xf8))(iVar11,1); if (*piVar6 == -2) { (**(code **)(*(int *)(iVar11 + 4) + 0xfc))(iVar11,1); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callscript.html": {
    "href": "callscript.html",
    "title": "callScript",
    "keywords": "callScript Unimplemented. Code Information Name: callScript Scope: Global PAC Instruction (Binary): 25 0a 01 00 Assembly Address in Memory : 0x89496bc Parameters (Undefined)Var0 (8 bytes) : This parameter is unused. (Undefined)Var1 (4 bytes) : This parameter is unused. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089496bc(undefined4 param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,0,4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callscriptlabel.html": {
    "href": "callscriptlabel.html",
    "title": "callScriptLabel",
    "keywords": "callScriptLabel Unimplemented. Code Information Name: callScriptLabel Scope: Global PAC Instruction (Binary): 25 10 03 00 Assembly Address in Memory : 0x890a1d8 Parameters (Undefined)Var0 (4 bytes) (Undefined)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a1d8(undefined4 param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,0,4); Pac_Get_Param(param_2,1,1,4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callscriptlabelid.html": {
    "href": "callscriptlabelid.html",
    "title": "callScriptLabelId",
    "keywords": "callScriptLabelId Unimplemented. Code Information Name: callScriptLabelId Scope: Global PAC Instruction (Binary): 25 10 04 00 Assembly Address in Memory : 0x890a22c Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a22c(undefined4 param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callsysmsg.html": {
    "href": "callsysmsg.html",
    "title": "callSysMsg",
    "keywords": "callSysMsg Display information message above/below the screen. Unlike dialog, this doesn't interrupt key input. For using message ID inside PAC instruction, use callSysMsgLabel instead. Code Information Name: callSysMsg Scope: Global PAC Instruction (Binary): 25 0a 21 00 Assembly Address in Memory : 0x894b668 Parameters (int)message_id (8 bytes) : The text message ID, as Full Message ID. The ID is NOT from PAC instruction table. (float)position_x (8 bytes) : X Posiiton of the message. (float)position_y (8 bytes) : Y Posiiton of the message. (float)duration (8 bytes) : Display time for the message, as seconds. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b668(int param_1,undefined4 param_2) { undefined4 *puVar1; float *pfVar2; undefined4 uVar3; float fVar4; float fVar5; float local_8; float local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = *puVar1; pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); fVar4 = *pfVar2; pfVar2 = (float *)Pac_Get_Param(param_2,2,1,4); fVar5 = *pfVar2; pfVar2 = (float *)Pac_Get_Param(param_2,3,1,4); if (*(int *)(param_1 + 0x10) != 0) { local_8 = (float)(int)fVar4; local_4 = (float)(int)fVar5; FUN_089ceae4((float)(int)*pfVar2, *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x74),uVar3,&local_8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "callsysmsglabel.html": {
    "href": "callsysmsglabel.html",
    "title": "callSysMsgLabel",
    "keywords": "callSysMsgLabel Display information message above/below the screen. Unlike dialog, this doesn't interrupt key input. For real message full ID, use callSysMsgLabel instead. Code Information Name: callSysMsgLabel Scope: Global PAC Instruction (Binary): 25 0a 22 00 Assembly Address in Memory : 0x894b76c Parameters (int)message_id (8 bytes) : The text message ID. This is message ID from message address table in the PAC file. Details on: about message table. (float)position_x (8 bytes) : X Posiiton of the message. (float)position_y (8 bytes) : Y Posiiton of the message. (float)duration (8 bytes) : Display time for the message, as seconds. Example Here is one example in hex: 25 0a 22 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 f0 43 / 10 00 00 00 / 00 00 00 41 / 10 00 00 00 / 00 00 60 40 Which is interpreted as: callSysMsgLabel((int *)iVar0, (float)480, (float)8, (float)3.5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b76c(int param_1,undefined4 param_2) { undefined4 *message; float *pfVar1; undefined4 uVar2; float xpos; float ypos; float duration; float local_8; float local_4; message = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = *message; pfVar1 = (float *)Pac_Get_Param(param_2,1,1,4); xpos = *pfVar1; pfVar1 = (float *)Pac_Get_Param(param_2,2,1,4); ypos = *pfVar1; pfVar1 = (float *)Pac_Get_Param(param_2,3,1,4); duration = *pfVar1; if (*(int *)(param_1 + 0x10) != 0) { uVar2 = Get_FullMessage(param_2,uVar2); local_8 = (float)(int)xpos; local_4 = (float)(int)ypos; FUN_089ceb50((float)(int)duration, *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x74),uVar2,&local_8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameraactuate.html": {
    "href": "cameraactuate.html",
    "title": "cameraActuate",
    "keywords": "cameraActuate Shakes the camera. Tumble effect uses this. Code Information Name: cameraActuate Scope: Global PAC Instruction (Binary): 25 16 93 00 Assembly Address in Memory : 0x892201c Parameters (float)x_scale (8 bytes) : How much the camera will be shaked in x direction (float)y_scale (8 bytes) : How much the camera will be shaked in y direction (for reference, tumble uses 0.5) (float)delay (8 bytes) : Delay before the camera being shaked, as seconds. (float)duration (8 bytes) : How long the camear will be shaked, as seconds. (int)Var4 (8 bytes) : Can keep 1, please describe. Example Here is one example in hex: 25 16 93 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 a0 40 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 3f / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cameraActuate((float)0, (float)5, (float)0, (float)0.5, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892201c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int *piVar5; int iVar6; int iVar7; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); iVar7 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar7 == 0) goto LAB_08922160; iVar6 = *piVar5; if (iVar6 == 2) { iVar6 = *(int *)(iVar7 + 4); LAB_08922148: iVar7 = (**(code **)(iVar6 + 0x24))(iVar7); FUN_08898c64(iVar7 + 0x10); } else { if (iVar6 == 1) { local_4 = *puVar2; } else { if (iVar6 != 0) { iVar6 = *(int *)(iVar7 + 4); goto LAB_08922148; } iVar6 = (**(code **)(*(int *)(iVar7 + 4) + 0x24))(iVar7); FUN_08898c64(iVar6 + 0x10); local_4 = *puVar2; } local_8 = *puVar1; iVar7 = (**(code **)(*(int *)(iVar7 + 4) + 0x24))(iVar7); FUN_08898fc8(*puVar3,*puVar4,iVar7 + 0x10,&local_8); } LAB_08922160: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameraenablecontrol.html": {
    "href": "cameraenablecontrol.html",
    "title": "cameraEnableControl",
    "keywords": "cameraEnableControl Please describe what this exactly does. For controlling with L/R button, use cameraEnableControll. Code Information Name: cameraEnableControl Scope: Global PAC Instruction (Binary): 25 16 bb 00 Assembly Address in Memory : 0x8923ae4 Parameters (bool)Var0 (8 bytes) : Either 0 or not, please describe what is this. (bool)enable_control (8 bytes) : 0 disables moving camera, 1 enables camera moving. Example Here is one example in hex: 25 16 bb 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cameraEnableControl((int)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923ae4(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 != 0) { if (*piVar2 == 0) { iVar3 = *piVar1; iVar4 = FUN_0890fa6c(*(undefined4 *)(iVar4 + 0xd8)); *(bool *)(iVar4 + 0x4d6) = iVar3 != 0; } else { iVar3 = *piVar1; iVar4 = FUN_0890fa6c(*(undefined4 *)(iVar4 + 0xd8)); *(bool *)(iVar4 + 0x4d7) = iVar3 != 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameraenablecontroll.html": {
    "href": "cameraenablecontroll.html",
    "title": "cameraEnableControll",
    "keywords": "cameraEnableControll Enables or disables camera controlling with L/R button. Code Information Name: cameraEnableControll Scope: Global PAC Instruction (Binary): 25 16 8a 00 Assembly Address in Memory : 0x89219f0 Parameters (bool)enable_control (8 bytes) : 0 disables moving camera with L/R button, 1 enables camera moving by player. Example Here is one example in hex: 25 16 8a 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: cameraEnableControll((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089219f0(int param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar3 != 0) { *(uint *)(iVar3 + 0x5d4) = (uint)(*piVar1 != 0); uVar2 = FUN_0890fa6c(); FUN_0890d71c(uVar2,*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameragetoffsety.html": {
    "href": "cameragetoffsety.html",
    "title": "cameraGetOffsetY",
    "keywords": "cameraGetOffsetY Gets Y Position of the camera in the world. Code Information Name: cameraGetOffsetY Scope: Global PAC Instruction (Binary): 25 16 92 00 Assembly Address in Memory : 0x8921f98 Parameters (float *)pos_y (8 bytes) : Variable to store the Y position of the camera in the world, as PSP pixels. Example Here is one example in hex: 25 16 92 00 / 20 00 00 00 / 04 00 00 00 Which is interpreted as: cameraGetOffsetY((float *)fVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921f98(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar2 != 0) { iVar2 = (**(code **)(*(int *)(iVar2 + 4) + 0x24))(); *puVar1 = *(undefined4 *)(iVar2 + 0x4b4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameragetpos.html": {
    "href": "cameragetpos.html",
    "title": "cameraGetPos",
    "keywords": "cameraGetPos Gets the world position of the camera. Called e.g. when NPC is selected in hideout. Code Information Name: cameraGetPos Scope: Global PAC Instruction (Binary): 25 16 8f 00 Assembly Address in Memory : 0x8921d48 Parameters (bool)Var0 (8 bytes) : Either 0 or not, please describe what is this. (float *)pos_x (8 bytes) : Variable to store the X position of the camera in the world, as PSP pixels. (float *)pos_y (8 bytes) : Variable to store the Y position of the camera in the world, as PSP pixels. (float *)pos_z (8 bytes) : Variable to store the Z position of the camera in the world, as PSP pixels. Example Here is one example in hex: 25 16 8f 00 / 02 00 00 00 / 00 00 00 00 / 40 00 00 00 / ff 01 00 00 / 40 00 00 00 / ff 01 00 00 / 20 00 00 00 / 0a 00 00 00 Which is interpreted as: cameraGetPos((int)0, ((global)float *)gfVar511, ((global)float *)gfVar511, (float *)fVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921d48(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined4 local_10; undefined4 local_c; undefined4 local_8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); *puVar2 = 0; *puVar3 = 0; *puVar4 = 0; iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar5 != 0) { if (*piVar1 == 0) { iVar5 = (**(code **)(*(int *)(iVar5 + 4) + 0x24))(); *puVar2 = *(undefined4 *)(iVar5 + 0x480); *puVar3 = *(undefined4 *)(iVar5 + 0x484); *puVar4 = *(undefined4 *)(iVar5 + 0x488); } else { iVar5 = (**(code **)(*(int *)(iVar5 + 4) + 0x24))(); (**(code **)(*(int *)(iVar5 + 4) + 0x20))(&local_10,iVar5); *puVar2 = local_10; *puVar3 = local_c; *puVar4 = local_8; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameragetposx.html": {
    "href": "cameragetposx.html",
    "title": "cameraGetPosX",
    "keywords": "cameraGetPosX Gets X Position of the camera in the world. Code Information Name: cameraGetPosX Scope: Global PAC Instruction (Binary): 25 16 90 00 Assembly Address in Memory : 0x8921e8c Parameters (float *)pos_x (8 bytes) : Variable to store the X position of the camera in the world, as PSP pixels. Example Here is one example in hex: 25 16 90 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: cameraGetPosX((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921e8c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar2 != 0) { iVar2 = (**(code **)(*(int *)(iVar2 + 4) + 0x24))(); *puVar1 = *(undefined4 *)(iVar2 + 0x480); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameramove.html": {
    "href": "cameramove.html",
    "title": "cameraMove",
    "keywords": "cameraMove Move the camera to the certain position in the world. Code Information Name: cameraMove Scope: Global PAC Instruction (Binary): 25 16 8e 00 Assembly Address in Memory : 0x8921bc4 Parameters (float)pos_x (8 bytes) : X Position to move the camera in the world, as PSP pixels. (float)pos_y (8 bytes) : Y Position to move the camera in the world, as PSP pixels. 0 is normal position. (float)pos_z (8 bytes) : Z Position (Camera distance) in the world. For refrence, around 150~200 looks natural. (bool)enable_x (8 bytes) : Decides if the camera moves in X direction or not. In speed based, 0 does not move. (bool)enable_y (8 bytes) : Decides if the camera moves in Y direction or not. In speed based, 0 does not move. (bool)enable_z (8 bytes) : Decides if the camera moves in Z direction or not. In speed based, 0 does not move. Remarks For determining the speed of the camera, see description in camerMoveType. Example Here is one example in hex: 25 16 8e 00 / 20 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: cameraMove((float *)fVar0, (float)0, (float)0, (int)1, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921bc4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; int *piVar5; int *piVar6; int iVar7; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); iVar7 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar7 != 0) { if (*piVar6 == 0) { local_4 = *(undefined4 *)(iVar7 + 0x4b8); } else { local_4 = *puVar3; } if (*piVar5 == 0) { local_8 = *(undefined4 *)(iVar7 + 0x4b4); } else { local_8 = *puVar2; } if (*piVar4 == 0) { local_c = *(undefined4 *)(iVar7 + 0x4b0); } else { local_c = *puVar1; } /* use time or speed? 0 for time 1 for speed */ if (*(int *)(param_1 + 0x1c) == 1) { FUN_0890ece0(*(undefined4 *)(param_1 + 0x24),*(undefined4 *)(param_1 + 0x28), *(undefined4 *)(param_1 + 0x2c),iVar7 + 0x30,&local_c); } else { FUN_0890ea24(*(undefined4 *)(param_1 + 0x20),iVar7 + 0x30,&local_c,0,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameramovespeedset.html": {
    "href": "cameramovespeedset.html",
    "title": "cameraMoveSpeedSet",
    "keywords": "cameraMoveSpeedSet Sets time to camera to move while using cameraMove. Works only cameraMoveType is set to 1. Does not affect player camera control with L/R. Code Information Name: cameraMoveSpeedSet Scope: Global PAC Instruction (Binary): 25 16 8d 00 Assembly Address in Memory : 0x8921b20 Parameters (float)speed_x (8 bytes) : Camera speed in X direction. (float)speed_y (8 bytes) : Camera speed in Y direction. (float)speed_z (8 bytes) : Camera speed in Z direction. Example Here is one example in hex: 25 16 8d 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 89 88 88 3e / 10 00 00 00 / 89 88 88 3e Which is interpreted as: cameraMoveSpeedSet((float)1, (float)0.26666668, (float)0.26666668) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921b20(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *(undefined4 *)(param_1 + 0x24) = *puVar1; *(undefined4 *)(param_1 + 0x28) = *puVar2; *(undefined4 *)(param_1 + 0x2c) = *puVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameramovetimeset.html": {
    "href": "cameramovetimeset.html",
    "title": "cameraMoveTimeSet",
    "keywords": "cameraMoveTimeSet Sets time to camera to move while using cameraMove. Works only cameraMoveType is set to 0. Does not affect player camera control with L/R. Code Information Name: cameraMoveTimeSet Scope: Global PAC Instruction (Binary): 25 16 8c 00 Assembly Address in Memory : 0x8921acc Parameters (float)time (8 bytes) : Moving time as seconds. Example Here is one example in hex: 25 16 8c 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: cameraMoveTimeSet((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921acc(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *(undefined4 *)(param_1 + 0x20) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cameramovetype.html": {
    "href": "cameramovetype.html",
    "title": "cameraMoveType",
    "keywords": "cameraMoveType Determines if cameraMove uses time or speed. Code Information Name: cameraMoveType Scope: Global PAC Instruction (Binary): 25 16 8b 00 Assembly Address in Memory : 0x8921a78 Parameters (bool)use_speed (8 bytes) : If this is set to 0, cameraMove will use time. Otherwise the cameraMove will use speed. Example Here is one example in hex: 25 16 8b 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: cameraMoveType((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921a78(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *(undefined4 *)(param_1 + 0x1c) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetbattleangle.html": {
    "href": "camerasetbattleangle.html",
    "title": "cameraSetBattleAngle",
    "keywords": "cameraSetBattleAngle Supposed to rotate camera, but seems this doesn't work. The default angle is 53.0 for both parameters. Code Information Name: cameraSetBattleAngle Scope: Global PAC Instruction (Binary): 25 16 96 00 Assembly Address in Memory : 0x89222a0 Parameters (float)Var0 (8 bytes) (float)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089222a0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (*(int *)(*(int *)(param_1 + 0x10) + 0xd8) != 0)) { uVar3 = FUN_0890fa6c(); FUN_0890d738(*puVar1,*puVar2,uVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetbattlez.html": {
    "href": "camerasetbattlez.html",
    "title": "cameraSetBattleZ",
    "keywords": "cameraSetBattleZ Sets camera zoom amount when enemies are in sight and out of sight. Does not affect the zoom when heromode starts. Code Information Name: cameraSetBattleZ Scope: Global PAC Instruction (Binary): 25 16 95 00 Assembly Address in Memory : 0x89221f8 Parameters (float)distance_nosight (8 bytes) : Camera distance when enemy is not on sight (zoom in). Default is 160.0. (float)distance_onsight (8 bytes) : Camera distance when enemy is on sight (zoom out). Default is 200.0. Example Here is one example in hex: 25 16 95 00 / 10 00 00 00 / 00 00 20 43 / 10 00 00 00 / 00 00 48 43 Which is interpreted as: cameraSetBattleZ((float)160, (float)200) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089221f8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (*(int *)(*(int *)(param_1 + 0x10) + 0xd8) != 0)) { uVar3 = FUN_0890fa6c(); FUN_0890d724(*puVar1,*puVar2,uVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetcontrollimit.html": {
    "href": "camerasetcontrollimit.html",
    "title": "cameraSetControlLimit",
    "keywords": "cameraSetControlLimit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cameraSetControlLimit Scope: Global PAC Instruction (Binary): 25 16 ba 00 Assembly Address in Memory : 0x8923a00 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 16 ba 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 02 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cameraSetControlLimit((float *)fVar0, (float *)fVar2, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923a00(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; int iVar4; undefined4 uVar5; undefined4 uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 != 0) { if (*piVar3 == 0) { uVar6 = *puVar2; uVar5 = *puVar1; iVar4 = FUN_0890fa6c(*(undefined4 *)(iVar4 + 0xd8)); *(undefined4 *)(iVar4 + 0x4dc) = uVar5; *(undefined4 *)(iVar4 + 0x4e4) = uVar6; } else { uVar5 = *puVar1; uVar6 = *puVar2; iVar4 = FUN_0890fa6c(*(undefined4 *)(iVar4 + 0xd8)); *(undefined4 *)(iVar4 + 0x4d8) = uVar5; *(undefined4 *)(iVar4 + 0x4e0) = uVar6; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetdefaultbattle.html": {
    "href": "camerasetdefaultbattle.html",
    "title": "cameraSetDefaultBattle",
    "keywords": "cameraSetDefaultBattle Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cameraSetDefaultBattle Scope: Global PAC Instruction (Binary): 25 16 94 00 Assembly Address in Memory : 0x892218c Parameters This function is parameterless. Example Here is one example in hex: 25 16 94 00 Which is interpreted as: cameraSetDefaultBattle() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892218c(int param_1,undefined4 param_2) { int iVar1; if (*(int *)(param_1 + 0x10) != 0) { if (*(int *)(*(int *)(param_1 + 0x10) + 0xd8) == 0) { iVar1 = *(int *)(param_1 + 0x10); } else { FUN_0890f85c(); iVar1 = *(int *)(param_1 + 0x10); } if (*(int *)(iVar1 + 0x118) != 0) { FUN_088b21ec(*(int *)(iVar1 + 0x118),1); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetoffsety.html": {
    "href": "camerasetoffsety.html",
    "title": "cameraSetOffsetY",
    "keywords": "cameraSetOffsetY Sets the Y offset of the camera position. Code Information Name: cameraSetOffsetY Scope: Global PAC Instruction (Binary): 25 16 91 00 Assembly Address in Memory : 0x8921f10 Parameters (float)position (8 bytes) : Y offset value of the camera. Example Here is one example in hex: 25 16 91 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: cameraSetOffsetY((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921f10(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar3 != 0) { uVar2 = (**(code **)(*(int *)(iVar3 + 4) + 0x24))(); FUN_088499e4(0,*puVar1,uVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetposz.html": {
    "href": "camerasetposz.html",
    "title": "cameraSetPosZ",
    "keywords": "cameraSetPosZ Sets Z position (zoom) of the camera in the world. Code Information Name: cameraSetPosZ Scope: Azito PAC Instruction (Binary): 25 1c 24 00 Assembly Address in Memory : 0x8b4fcb8 Parameters (float)value (8 bytes) : Z position of camera to be set. Example Here is one example in hex: 25 1c 24 00 / 20 00 00 00 / 0a 00 00 00 Which is interpreted as: cameraSetPosZ((float *)fVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fcb8(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x1b4); uVar3 = *puVar1; *(undefined4 *)(iVar2 + 0x5e0) = *(undefined4 *)(iVar2 + 0x5e0); *(undefined4 *)(iVar2 + 0x5e4) = *(undefined4 *)(iVar2 + 0x5e4); *(undefined4 *)(iVar2 + 0x5e8) = uVar3; *(undefined4 *)(iVar2 + 0x5ec) = *(undefined4 *)(iVar2 + 0x5ec); *(undefined4 *)(iVar2 + 0x5ec) = 0x3f800000; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "camerasetscriptcmaera.html": {
    "href": "camerasetscriptcmaera.html",
    "title": "cameraSetScriptCmaera",
    "keywords": "cameraSetScriptCmaera Sets if the camera follows player or not. Not following (1) can used in cutscene. Code Information Name: cameraSetScriptCmaera Scope: Global PAC Instruction (Binary): 25 16 89 00 Assembly Address in Memory : 0x892196c Parameters (bool)script_controlled (8 bytes) : If this is set to 0, the camera auto follows the player. Otherwise the camera movement is deciede by scripts. Example Here is one example in hex: 25 16 89 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cameraSetScriptCmaera((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892196c(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0xd8); if (iVar2 != 0) { if (*piVar1 == 0) { FUN_0890f8a0(iVar2,*(undefined4 *)(iVar2 + 0x25ec),1); } else { FUN_0890f8a0(iVar2,0,1); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cancel.html": {
    "href": "cancel.html",
    "title": "cancel",
    "keywords": "cancel Cancels currently playing sound/music. Code Information Name: cancel Scope: Global PAC Instruction (Binary): 25 0b 04 00 Assembly Address in Memory : 0x896f9c0 Parameters (int)sgd_id (8 bytes) : ID of the Atrac or the Sound Effect. (float)fade_time (8 bytes) : Crossfade time, as seconds (float)Var2 (8 bytes) : Please describe what this does. Seems like value between 0 and 1. Example Here is one example in hex: 25 0b 04 00 / 02 00 00 00 / f6 00 50 50 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: cancel((int)1347420406, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896f9c0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); FUN_088eb218(*puVar2,*puVar3,*(int *)(param_1 + 0x14) + 0x60,*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "catlink.html": {
    "href": "catlink.html",
    "title": "catLink",
    "keywords": "catLink Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: catLink Scope: Global PAC Instruction (Binary): 25 17 60 00 Assembly Address in Memory : 0x8917d20 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 17 60 00 / 04 00 00 00 / 40 00 00 00 Which is interpreted as: catLink((int *)iVar64) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917d20(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar2 == 0) { iVar2 = 0; } if (iVar2 != 0) { *(undefined4 *)(*(int *)(iVar2 + 200) + 0x1b4) = 0; if (*(int *)(iVar2 + 0x100) != 0) { uVar3 = FUN_0887de78(); FUN_0887b57c(uVar3,iVar2 + 0xec); *(undefined4 *)(iVar2 + 0x100) = 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "changelanguage.html": {
    "href": "changelanguage.html",
    "title": "changeLanguage",
    "keywords": "changeLanguage Changes current language and goes to EULA and title page. Code Information Name: changeLanguage Scope: Global PAC Instruction (Binary): 25 0a 04 00 Assembly Address in Memory : 0x8949794 Parameters (int)language_code (8 bytes) : Language code to change. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949794(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = *puVar1; iVar2 = Save::Get_Save_BaseAddr(1); *(undefined4 *)(iVar2 + 0x20) = uVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "changemodel.html": {
    "href": "changemodel.html",
    "title": "changeModel",
    "keywords": "changeModel Changes the model of the given unit. Works only with unit. Code Information Name: changeModel Scope: Global PAC Instruction (Binary): 25 16 57 00 Assembly Address in Memory : 0x891f8c0 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)model_index (8 bytes) : 0 is usually base model. For player, 1 is Event model. Remakrs If the model is the controllable player, setUnitCtrlEnable must be called after this. Example Here is one example in hex: 25 16 57 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: changeModel((int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891f8c0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { FUN_088b9d44(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "changephase_gimmickuid.html": {
    "href": "changephase_gimmickuid.html",
    "title": "changePhase_GimmickUID",
    "keywords": "changePhase_GimmickUID Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: changePhase_GimmickUID Scope: Global PAC Instruction (Binary): 25 16 d3 00 Assembly Address in Memory : 0x8925cfc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925cfc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if ((iVar3 != 0) && (iVar3 = Get_Gimmick(iVar3,*puVar1), iVar3 != 0)) { FUN_088cc98c(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "changescene.html": {
    "href": "changescene.html",
    "title": "changeScene",
    "keywords": "changeScene Change the scene, potentially between overlay. Code Information Name: changeScene Scope: Global PAC Instruction (Binary): 25 0a 02 00 Assembly Address in Memory : 0x8949710 Parameters (int)scene_id (8 bytes) : Expected to be 0, 1, 3, 4, 5, 6. scene_id action Loaded Overlay 0 No change Mission 1 Title menu Title 3 Loading screen Title (???) 4 Hideout Azito 5 Ending Screen Title Example Here is one example in hex: 25 0a 02 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: changeScene((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949710(int param_1,undefined4 param_2) { /* see also 0x088fd118 */ undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_0884f334(*(int *)(param_1 + 0x10),*puVar1,3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checkequalheroname.html": {
    "href": "checkequalheroname.html",
    "title": "checkEqualHeroName",
    "keywords": "checkEqualHeroName Checks if the hero name is same as certain name. This is used for special hairstyle. Code Information Name: checkEqualHeroName Scope: Global PAC Instruction (Binary): 25 0a 15 00 Assembly Address in Memory : 0x894a874 Parameters (int *)result (8 bytes) : Variable to store if the hero name is identical to the given value. 1 if the hero name is same as hero_name, otherwise 0. (String)hero_name : Name of the hero to compare. Example Here is one example in hex: 25 0a 15 00 / 04 00 00 00 / 01 00 00 00 / 52 6f 6c 69 / 74 6f 00 00 Which is interpreted as: checkEqualHeroName((int *)iVar1, \"Rolito\") 00000514 250A1500:checkEqualHeroName(4:1, \"AAA\") 00000524 25001700:cmd_ifEQ(4:1, 1.0, 1:56C) 0000056C 250A1400:setAccessoryIdFileIndex(2:3, 4:0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a874(undefined4 param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined *puVar3; int iVar4; short *psVar5; undefined *puVar6; short *psVar7; short local_a0 [16]; undefined local_80 [128]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = &DAT_00000080; puVar6 = local_80; puVar1 = puVar6; while (puVar1 != (undefined *)0x0) { *puVar6 = 0; puVar6 = puVar6 + 1; puVar3 = puVar3 + -1; puVar1 = puVar3; } Pac_Get_StringParam(param_2,local_80); *puVar2 = 0; Syscall::Kernel::Kernel_Memset(local_a0,0,0x20); Message::Write_Value_Final(local_a0,0x20,local_80); iVar4 = Save::Get_Save_BaseAddr(1); psVar5 = (short *)Message::GetMagicWord(*(int *)(iVar4 + 0x50) + 0x2b408,0xc); *puVar2 = 0; iVar4 = 0; psVar7 = local_a0; do { if (*psVar5 != *psVar7) break; if (*psVar5 == 0) { *puVar2 = 1; break; } iVar4 = iVar4 + 1; psVar7 = psVar7 + 1; psVar5 = psVar5 + 1; } while (iVar4 < 0x10); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checknetworklost.html": {
    "href": "checknetworklost.html",
    "title": "checkNetworkLost",
    "keywords": "checkNetworkLost Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: checkNetworkLost Scope: Global PAC Instruction (Binary): 25 16 0e 01 Assembly Address in Memory : 0x8928ed0 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (uint)Var2 (8 bytes) Example Here is one example in hex: 25 16 0e 01 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: checkNetworkLost((int)0, (int *)iVar2, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928ed0(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; uint *puVar3; int iVar4; int iVar5; int iVar6; uint uVar7; int iVar8; int iVar9; int iVar10; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0; iVar8 = *piVar1; iVar10 = 0; if (iVar8 == 2) { iVar8 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar2,1); if ((iVar8 != 0) && (iVar6 = (**(code **)(*(int *)(iVar8 + 4) + 0x34))(iVar8), iVar6 == 3)) { iVar10 = Is_HeroUnit(iVar8); } } else if (iVar8 == 1) { iVar8 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar2); if ((iVar8 != 0) && (iVar6 = (**(code **)(*(int *)(iVar8 + 4) + 0x34))(iVar8), iVar6 == 9)) { iVar10 = iVar8; } } else if (iVar8 == 0) { iVar8 = *(int *)(param_1 + 0x10); if (iVar8 == 0) { iVar8 = 0; } else { if (iVar8 == 0) { iVar8 = 0; } iVar8 = *(int *)(iVar8 + 0xf8); if (iVar8 == 0) { iVar8 = 0; } } if (iVar8 != 0) { iVar6 = 0; do { iVar4 = FUN_088a8650(iVar8,iVar6); if (iVar4 != 0) { iVar9 = 0; do { iVar5 = FUN_088df588(iVar4,iVar9); if ((iVar5 != 0) && (*piVar2 == *(int *)(iVar5 + 0x188))) { iVar10 = Is_HeroUnit(iVar5); } iVar9 = iVar9 + 1; } while (iVar9 < 4); } iVar6 = iVar6 + 1; } while (iVar6 < 2); } } if (iVar10 != 0) { uVar7 = FUN_088b8d8c(iVar10); *puVar3 = uVar7 & 0xff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checkrangepriority_isinside.html": {
    "href": "checkrangepriority_isinside.html",
    "title": "checkRangePriority_isInside",
    "keywords": "checkRangePriority_isInside Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: checkRangePriority_isInside Scope: Global PAC Instruction (Binary): 25 16 22 01 Assembly Address in Memory : 0x892a470 Parameters (float)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a470(int param_1,undefined4 param_2) { float *pfVar1; int iVar2; undefined4 uVar3; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x118); if (*(char *)(iVar2 + 0x864c) == '\\0') { uVar3 = 0; } else if ((*pfVar1 <= *(float *)(iVar2 + 0x8650)) || (*(float *)(iVar2 + 0x8654) <= *pfVar1)) { uVar3 = 0; } else { uVar3 = 1; } FUN_0883c04c(param_2,uVar3); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checkrangepriority_isinsideh.html": {
    "href": "checkrangepriority_isinsideh.html",
    "title": "checkRangePriority_isInsideH",
    "keywords": "checkRangePriority_isInsideH Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: checkRangePriority_isInsideH Scope: Global PAC Instruction (Binary): 25 16 23 01 Assembly Address in Memory : 0x892a518 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 23 01 / 04 00 00 00 / 0b 00 00 00 Which is interpreted as: checkRangePriority_isInsideH((int *)iVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a518(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; int iVar3; undefined4 uVar4; float fVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_0883c04c(param_2,0); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar2 != 0) && (iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2), iVar3 == 9)) && (*(int *)(iVar2 + 200) != 0)) { fVar5 = *(float *)(*(int *)(iVar2 + 200) + 0xc0); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x118); if (*(char *)(iVar2 + 0x864c) == '\\0') { uVar4 = 0; } else if ((fVar5 <= *(float *)(iVar2 + 0x8650)) || (*(float *)(iVar2 + 0x8654) <= fVar5)) { uVar4 = 0; } else { uVar4 = 1; } FUN_0883c04c(param_2,uVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checkrangepriority_setpos.html": {
    "href": "checkrangepriority_setpos.html",
    "title": "checkRangePriority_setPos",
    "keywords": "checkRangePriority_setPos Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: checkRangePriority_setPos Scope: Global PAC Instruction (Binary): 25 16 21 01 Assembly Address in Memory : 0x892a3dc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 21 01 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: checkRangePriority_setPos((float *)fVar1, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a3dc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar2; uVar5 = *puVar1; iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x118); *(undefined *)(iVar3 + 0x864c) = 1; *(undefined4 *)(iVar3 + 0x8650) = uVar5; *(undefined4 *)(iVar3 + 0x8654) = uVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checkshopitemunlock.html": {
    "href": "checkshopitemunlock.html",
    "title": "checkShopItemUnlock",
    "keywords": "checkShopItemUnlock Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: checkShopItemUnlock Scope: Global PAC Instruction (Binary): 25 0a 3e 00 Assembly Address in Memory : 0x894d07c Parameters (int)Var0 (8 bytes) (int)Var1 (4 bytes) (uint...)Vars2 (>= 4 bytes) ... means any amounts of parameter. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d07c(undefined4 param_1,undefined4 param_2) { bool bVar1; int *piVar2; int iVar3; uint *puVar4; uint uVar5; int iVar6; int iVar7; int iVar8; FUN_0883c04c(param_2,0); piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); iVar6 = *piVar2; iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x285a8(*(undefined4 *)(iVar3 + 0x50)); if (iVar6 == 0) { iVar3 = iVar3 + 0x1554; } else { iVar3 = iVar3 + 0x1598; } piVar2 = (int *)Pac_Get_Param(param_2,1,0,1); iVar6 = *piVar2; iVar8 = 0; iVar7 = 0; if (0 < iVar6) { do { puVar4 = (uint *)Pac_Get_Param(param_2,1,0,4); uVar5 = *puVar4; if ((int)uVar5 < 0) { iVar6 = *piVar2; } else { if (uVar5 >> 5 < 0x11) { bVar1 = (1 << (uVar5 & 0x1f) & *(uint *)(iVar3 + (uVar5 >> 5) * 4)) >> (uVar5 & 0x1f) != 0; } else { bVar1 = false; } if (bVar1) { iVar8 = iVar8 + 1; } iVar6 = *piVar2; } iVar7 = iVar7 + 1; } while (iVar7 < iVar6); } FUN_0883c04c(param_2,iVar8 == iVar6); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checktipsunlock.html": {
    "href": "checktipsunlock.html",
    "title": "checkTipsUnlock",
    "keywords": "checkTipsUnlock Check if a tip is unlocked. Code Information Name: checkTipsUnlock Scope: Global PAC Instruction (Binary): 25 0a 29 00 Assembly Address in Memory : 0x894baf0 Parameters (uint)tip_id (>= 4 bytes) : ID of the tip to check if it is unlocked. Saved in cmd_res value, use with e.g. cmd_resJmp Example Here is one example in hex: 25 0a 29 00 / 01 00 00 00 / 00 00 00 00 Which is interpreted as: checkTipsUnlock((int)0) This jumps to 0x707c if the tip is unlocked. 00002B08 250A2900:checkTipsUnlock(15) 00002B14 25000500:cmd_resJmp(2:1, 1:707C) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894baf0(undefined4 param_1,undefined4 param_2) { bool bVar1; int *piVar2; int iVar3; uint *puVar4; int iVar5; uint uVar6; int iVar7; int iVar8; FUN_0883c04c(param_2,0); piVar2 = (int *)Pac_Get_Param(param_2,0,0,1); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = *(int *)(iVar3 + 0x50); iVar5 = *piVar2; iVar8 = 0; iVar7 = 0; if (0 < iVar5) { do { puVar4 = (uint *)Pac_Get_Param(param_2,1,0,4); uVar6 = *puVar4; if ((int)uVar6 < 0) { iVar5 = *piVar2; } else { if (uVar6 >> 5 < 4) { bVar1 = (1 << (uVar6 & 0x1f) & *(uint *)(iVar3 + 0x2b808 + (uVar6 >> 5) * 4)) >> (uVar6 & 0x1f) != 0; } else { bVar1 = false; } if (bVar1) { iVar8 = iVar8 + 1; } iVar5 = *piVar2; } iVar7 = iVar7 + 1; } while (iVar7 < iVar5); } FUN_0883c04c(param_2,iVar8 == iVar5); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "checkunkoname.html": {
    "href": "checkunkoname.html",
    "title": "checkUnkoName",
    "keywords": "checkUnkoName Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: checkUnkoName Scope: Global PAC Instruction (Binary): 25 0a 16 00 Assembly Address in Memory : 0x894a96c Parameters (undefined4)Var0 (8 bytes) (String)Var1 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a96c(undefined4 param_1,undefined4 param_2) { undefined uVar1; bool bVar2; undefined4 *puVar3; short *psVar4; int iVar5; undefined *puVar6; undefined1 *puVar7; short *psVar8; uint uVar9; undefined4 uVar10; short local_a0 [16]; undefined local_80 [128]; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar7 = &DAT_08a714d8; puVar6 = local_80; iVar5 = 0x40; do { uVar1 = puVar7[1]; iVar5 = iVar5 + -1; *puVar6 = *puVar7; puVar6[1] = uVar1; puVar7 = puVar7 + 2; puVar6 = puVar6 + 2; } while (0 < iVar5); Pac_Get_StringParam(param_2,local_80); *puVar3 = 0; Syscall::Kernel::Kernel_Memset(local_a0,0,0x20); Message::Write_Value_Final(local_a0,0x20,local_80); iVar5 = Save::Get_Save_BaseAddr(1); psVar4 = (short *)Message::GetMagicWord(*(int *)(iVar5 + 0x50) + 0x2b408,0xc); uVar10 = 1; if (*psVar4 == 0) { uVar10 = 0; } else { iVar5 = 0; do { if (*psVar4 == 0) break; bVar2 = false; uVar9 = 0; psVar8 = local_a0; do { if (*psVar8 == 0) break; if (*psVar4 == *psVar8) { bVar2 = true; break; } uVar9 = uVar9 + 1; psVar8 = psVar8 + 1; } while (uVar9 < 0x10); if (!bVar2) { uVar10 = 0; break; } iVar5 = iVar5 + 1; psVar4 = psVar4 + 1; } while (iVar5 < 0x10); } *puVar3 = uVar10; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearabnormalstatus.html": {
    "href": "clearabnormalstatus.html",
    "title": "clearAbnormalStatus",
    "keywords": "clearAbnormalStatus Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: clearAbnormalStatus Scope: Global PAC Instruction (Binary): 25 17 4d 00 Assembly Address in Memory : 0x8916194 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 17 4d 00 / 04 00 00 00 / 02 00 00 00 / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / 00 00 00 00 Which is interpreted as: clearAbnormalStatus((int *)iVar2, (int)-1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08916194(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; int iVar4; int iVar5; undefined uStack64; byte local_3f; undefined4 local_38; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 9) { iVar4 = iVar4 + 0x180; local_10 = 0; local_c = 0; local_8 = 0; local_4 = 0; Syscall::Kernel::Kernel_Memset(&uStack64,0,0x40); local_38 = 0xffffffff; local_3f = local_3f & 0xf6 | 9; switch(*puVar2) { case 0: Damage::Status::Cure_StatusEffect_From(iVar4,0,*piVar3 != 0); break; case 1: Damage::Status::Cure_StatusEffect_From(iVar4,1,*piVar3 != 0); break; case 2: Damage::Status::Cure_StatusEffect_From(iVar4,2,*piVar3 != 0); break; case 3: Damage::Status::Cure_StatusEffect_From(iVar4,3,*piVar3 != 0); break; case 4: Damage::Status::Cure_StatusEffect_From(iVar4,4,*piVar3 != 0); break; case 6: Damage::Status::Cure_StatusEffect_From(iVar4,6,*piVar3 != 0); break; case 0xffffffff: Damage::Status::Cure_StatusEffect_From(iVar4,8,*piVar3 != 0); } } else { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 3) { switch(*puVar2) { case 0: FUN_088c6e60(iVar4,0,*piVar3 != 0); break; case 1: FUN_088c6e60(iVar4,1,*piVar3 != 0); break; case 2: FUN_088c6e60(iVar4,2,*piVar3 != 0); break; case 3: FUN_088c6e60(iVar4,3,*piVar3 != 0); break; case 4: FUN_088c6e60(iVar4,4,*piVar3 != 0); break; case 6: FUN_088c6e60(iVar4,6,*piVar3 != 0); break; case 0xffffffff: FUN_088c6e60(iVar4,8,*piVar3 != 0); } } else { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 2) { switch(*puVar2) { case 0: FUN_088e3740(iVar4,0,*piVar3 != 0); break; case 1: FUN_088e3740(iVar4,1,*piVar3 != 0); break; case 2: FUN_088e3740(iVar4,2,*piVar3 != 0); break; case 3: FUN_088e3740(iVar4,3,*piVar3 != 0); break; case 4: FUN_088e3740(iVar4,4,*piVar3 != 0); break; case 6: FUN_088e3740(iVar4,6,*piVar3 != 0); break; case 0xffffffff: FUN_088e3740(iVar4,8,*piVar3 != 0); } } } } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearautocommand.html": {
    "href": "clearautocommand.html",
    "title": "clearAutoCommand",
    "keywords": "clearAutoCommand Stops all command immediately sent from setAutoCommand or startAutoCommandKey, making drum input possible. Code Information Name: clearAutoCommand Scope: Global PAC Instruction (Binary): 25 0c 0e 00 Assembly Address in Memory : 0x8970a18 Parameters This function is parameterless. Example Here is one example in hex: 25 0c 0e 00 Which is interpreted as: clearAutoCommand() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970a18(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar1 != 0) { func_0x08b74618(iVar1 + 8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cleardisableherovoice.html": {
    "href": "cleardisableherovoice.html",
    "title": "clearDisableHeroVoice",
    "keywords": "clearDisableHeroVoice Resets drum shout status. Works only when drum shout is enabled in system setting. Code Information Name: clearDisableHeroVoice Scope: Global PAC Instruction (Binary): 25 0c 24 00 Assembly Address in Memory : 0x8971514 Parameters (int)drum_id (8 bytes) : Drum ID to reset (enable) the drum shout status, 0 targets all drums. (bool)is_clear (8 bytes) : 1 to make it functional. 0 will preserve the state. Example Here is one example in hex: 25 0c 24 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: clearDisableHeroVoice((int)3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08971514(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { func_0x08b7f218(iVar3 + 0x1e8,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cleardisablepercussionflag.html": {
    "href": "cleardisablepercussionflag.html",
    "title": "clearDisablePercussionFlag",
    "keywords": "clearDisablePercussionFlag Clears enable/disable status of the drums. Code Information Name: clearDisablePercussionFlag Scope: Global PAC Instruction (Binary): 25 0c 19 00 Assembly Address in Memory : 0x8970f54 Parameters (int)drum_id (8 bytes) : Drum ID to reset (enable) the hit enabled status, 0 targets all drums. (bool)is_clear (8 bytes) : 1 to make it functional. 0 will preserve the state. Example Here is one example in hex: 25 0c 19 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: clearDisablePercussionFlag((int)3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970f54(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); func_0x08b5f900(*puVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cleardisablepercussionview.html": {
    "href": "cleardisablepercussionview.html",
    "title": "clearDisablePercussionView",
    "keywords": "clearDisablePercussionView Clears the drum visual status. Works only when drum view is enabled in system setting. Code Information Name: clearDisablePercussionView Scope: Global PAC Instruction (Binary): 25 0c 1c 00 Assembly Address in Memory : 0x89710b8 Parameters (int)drum_id (8 bytes) : Drum ID to reset (enable) the visualising status, 0 targets all drums. (bool)is_clear (8 bytes) : 1 to make it functional. 0 will preserve the state. Example Here is one example in hex: 25 0c 1c 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: clearDisablePercussionView((int)3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089710b8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { func_0x08b5f710(iVar3,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearisfirst.html": {
    "href": "clearisfirst.html",
    "title": "clearIsFirst",
    "keywords": "clearIsFirst Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: clearIsFirst Scope: Global PAC Instruction (Binary): 25 0a 0d 00 Assembly Address in Memory : 0x894a014 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0a 0d 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: clearIsFirst((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a014(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_08945778(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearitem.html": {
    "href": "clearitem.html",
    "title": "clearItem",
    "keywords": "clearItem Clears item obtain statistics. This does not delete item. Code Information Name: clearItem Scope: Global PAC Instruction (Binary): 25 0a 0c 00 Assembly Address in Memory : 0x8949fac Parameters (int)item_id (8 bytes) : ID of the item to clear the status. Example Here is one example in hex: 25 0a 0c 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: clearItem((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949fac(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_08945748(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearloadinggroup.html": {
    "href": "clearloadinggroup.html",
    "title": "clearLoadingGroup",
    "keywords": "clearLoadingGroup Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: clearLoadingGroup Scope: Global PAC Instruction (Binary): 25 09 0c 00 Assembly Address in Memory : 0x8949074 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 09 0c 00 / 02 00 00 00 / 0b 00 00 00 Which is interpreted as: clearLoadingGroup((int)11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949074(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = FUN_0884a440(1); FUN_0884b590(uVar2,*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearmedenshopitem.html": {
    "href": "clearmedenshopitem.html",
    "title": "clearMedenShopItem",
    "keywords": "clearMedenShopItem Deletes all items from meden shop. Code Information Name: clearMedenShopItem Scope: Global PAC Instruction (Binary): 25 0a 44 00 Assembly Address in Memory : 0x894d4b4 Parameters This function is parameterless. Example Here is one example in hex: 25 0a 44 00 Which is interpreted as: clearMedenShopItem() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d4b4(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = 0; do { FUN_088515c8(uVar1,iVar2); iVar2 = iVar2 + 1; } while (iVar2 < 0x14); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearsysmsg.html": {
    "href": "clearsysmsg.html",
    "title": "clearSysMsg",
    "keywords": "clearSysMsg Closes the \"sysmsg\" from calledSysMsgLabel or callSysMsg. Code Information Name: clearSysMsg Scope: Global PAC Instruction (Binary): 25 0a 23 00 Assembly Address in Memory : 0x894b888 Parameters This function is parameterless. Example Here is one example in hex: 25 0a 23 00 Which is interpreted as: clearSysMsg() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b888(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { FUN_089cec94(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x74)); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cleartipsselectmask.html": {
    "href": "cleartipsselectmask.html",
    "title": "clearTipsSelectMask",
    "keywords": "clearTipsSelectMask Clears tip status before loading all available tips. Used by labo.pac. This does not remove tip unlock status. Code Information Name: clearTipsSelectMask Scope: Global PAC Instruction (Binary): 25 0a 2c 00 Assembly Address in Memory : 0x894bd18 Parameters This function is parameterless. Example Here is one example in hex: 25 0a 2c 00 Which is interpreted as: clearTipsSelectMask() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bd18(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Save::Get_Save_BaseAddr(1); Syscall::Kernel::Kernel_Memset(*(int *)(iVar1 + 0x58) + 0x14,0,0x10); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearunit.html": {
    "href": "clearunit.html",
    "title": "clearUnit",
    "keywords": "clearUnit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: clearUnit Scope: Global PAC Instruction (Binary): 25 16 28 00 Assembly Address in Memory : 0x891bf74 Parameters This function is parameterless. Example Here is one example in hex: 25 16 28 00 Which is interpreted as: clearUnit() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891bf74(int param_1,undefined4 param_2) { int iVar1; int iVar2; iVar1 = FUN_088a8650(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xf8),0); if (((iVar1 != 0) && (iVar1 = FUN_088df588(iVar1,0), iVar1 != 0)) && (iVar2 = FUN_088c5348(iVar1,0), iVar2 != 0)) { (**(code **)(*(int *)(iVar2 + 4) + 0x44))(iVar2); (**(code **)(*(int *)(iVar1 + 4) + 0x44))(iVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearversus04panelactioncount.html": {
    "href": "clearversus04panelactioncount.html",
    "title": "clearVersus04PanelActionCount",
    "keywords": "clearVersus04PanelActionCount Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: clearVersus04PanelActionCount Scope: Global PAC Instruction (Binary): 25 16 fc 00 Assembly Address in Memory : 0x8924ef8 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924ef8(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar1 != 0) && (iVar1 = *(int *)(iVar1 + 0x68), iVar1 != 0)) { *(undefined4 *)(iVar1 + 0x54) = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearversusinfo.html": {
    "href": "clearversusinfo.html",
    "title": "clearVersusInfo",
    "keywords": "clearVersusInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: clearVersusInfo Scope: Azito PAC Instruction (Binary): 25 1c 2d 00 Assembly Address in Memory : 0x8b50068 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 2d 00 Which is interpreted as: clearVersusInfo() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b50068(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; int iVar3; iVar3 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0xcdd4); uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar2 = *(int *)(iVar2 + 0x44); if (iVar2 != 0) { FUN_0898b1a0(iVar2 + 0x3c); } uVar1 = Save::Get_Save_BaseAddr(1); Save::Get_BaseAddr__0x78(uVar1,1); if (iVar2 != -0x528) { *(undefined *)(iVar2 + 0x81c) = 0; } if (iVar3 != 0) { *(undefined *)(iVar3 + 0x150) = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clearweather.html": {
    "href": "clearweather.html",
    "title": "clearWeather",
    "keywords": "clearWeather Clears weather, does not work. Code Information Name: clearWeather Scope: Global PAC Instruction (Binary): 25 16 7a 00 Assembly Address in Memory : 0x8920fb0 Parameters This function is parameterless. Example Here is one example in hex: 25 16 7a 00 Which is interpreted as: clearWeather() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920fb0(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(param_1 + 0x10); if (iVar1 == 0) { iVar1 = 0; } else { if (iVar1 == 0) { iVar1 = 0; } iVar1 = *(int *)(iVar1 + 0x118); if (iVar1 == 0) { iVar1 = 0; } } if (iVar1 != 0) { FUN_088fde20(iVar1 + 0x1d0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "clipmotion.html": {
    "href": "clipmotion.html",
    "title": "clipMotion",
    "keywords": "clipMotion Plays certain motion of a given player or object. This auto resumes from the paused status. If the character wasn't paused, it takes T-Pose. Code Information Name: clipMotion Scope: Global PAC Instruction (Binary): 25 17 39 00 Assembly Address in Memory : 0x8914ac8 Parameters (int *)handle_id (8 bytes) : The target handle. (int)action_id (8 bytes) : The Action ID to perform. (float)offset (8 bytes) : Start offset of the animation. (Maybe 1.0 represents around 0.2sec) Usual hero animation offset length seems like around 6~10. Please tell more about this parameter. (float)delay (8 bytes) : Delay before starting the animation. This can be -1. Example Here is one example in hex: 25 17 39 00 / 04 00 00 00 / 0a 00 00 00 / 02 00 00 00 / 02 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: clipMotion((int *)iVar10, (int)2, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914ac8(int param_1,undefined4 param_2) { int *piVar1; undefined2 *puVar2; undefined4 *puVar3; float *pfVar4; int iVar5; int iVar6; float fVar7; float fVar8; undefined local_c; undefined local_b; undefined local_a; undefined local_9; undefined4 local_8; uint local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined2 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); if (*piVar1 != -1) { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (((iVar5 != 0) && (iVar5 = *(int *)(iVar5 + 200), iVar5 != 0)) && (iVar6 = *(int *)(iVar5 + 0x1e8), iVar6 != 0)) { *(undefined *)(iVar5 + 0xb9) = 0; *(undefined *)(iVar6 + 0xb9) = 1; fVar8 = *pfVar4; local_8 = *puVar3; fVar7 = fVar8 * 4800.0; local_c = (undefined)*puVar2; local_b = 0; if (fVar7 < 2.147484e+09) { local_4 = (uint)fVar7; } else { local_4 = (int)(fVar7 - 2.147484e+09) | 0xffff8000; } local_a = fVar8 < 0.0; local_9 = 1; if (fVar8 < 0.0) { local_4 = 0; } FUN_08981164(iVar6,&local_c); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "closedialog.html": {
    "href": "closedialog.html",
    "title": "closeDialog",
    "keywords": "closeDialog Closes the dialog. This is called when e.g. going back to the hideout from a mission. Code Information Name: closeDialog Scope: Global PAC Instruction (Binary): 25 03 0e 00 Assembly Address in Memory : 0x892dee0 Parameters This function is parameterless. Example Here is one example in hex: 25 03 0e 00 Which is interpreted as: closeDialog() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892dee0(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; undefined4 *puVar3; if (*(int *)(param_1 + 0x1c) == 0) { PAC::PAC_setCmdId(param_2,0); } else { puVar3 = (undefined4 *)(param_1 + 0x1c); uVar1 = FUN_08a1ee38(*(int *)(param_1 + 0x1c)); FUN_08a1ee40(*puVar3); iVar2 = Get_addr_0xd20_Data(uVar1); if (iVar2 != 0) { FUN_08a1edb8(*puVar3,0,0xffffffff,0); FUN_08a1ee08(*puVar3); FUN_08a1eca8(*puVar3,0x50); } PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "closemessagewindow.html": {
    "href": "closemessagewindow.html",
    "title": "closeMessageWindow",
    "keywords": "closeMessageWindow Closes an acivte bubble speech immediately. This does not have the close button. For close button, see keyCloseMessageWindow. Code Information Name: closeMessageWindow Scope: Global PAC Instruction (Binary): 25 17 2e 00 Assembly Address in Memory : 0x8913cdc Parameters (int *)speech_bubble_id (8 bytes) : Speech Bubble window ID, obtained from callMessageWindow 2nd parameter. Example Here is one example in hex: 25 17 2e 00 / 08 00 00 00 / 35 00 00 00 Which is interpreted as: closeMessageWindow(((global)int *)giVar53) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913cdc(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); if (*piVar1 != -1) { iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar2 == 0) { iVar2 = 0; } if (iVar2 != 0) { (**(code **)(*(int *)(iVar2 + 4) + 0xf0))(iVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_abs.html": {
    "href": "cmd_abs.html",
    "title": "cmd_abs",
    "keywords": "cmd_abs Makes value absolute. If the value is negative, the value becomes positive. Code Information Name: cmd_abs Scope: Global PAC Instruction (Binary): 25 00 3a 00 Assembly Address in Memory : 0x883a92c Parameters cmd_abs((int/float)value, (int/float *)destination) (Int/Float)value (8 bytes) : Can be variable or constat value. This value will be used for reading only. (Int/Float *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. This performs destination = Math.Abs(value). Remarks If value and destination are different two variables, the origianl value from value is preserved. To modify the variable, you can set the value and the destination same. Example Here is one example in hex: 25 00 3a 00 / 20 00 00 00 / 0b 00 00 00 / 20 00 00 00 / 0b 00 00 00 Which is interpreted as: cmd_abs((float *)fVar11, (float *)fVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a92c(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; uint uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); uVar4 = Pac_Get_ParamType(param_2,1); if ((uVar3 & 0x70) == 0) { fVar5 = (float)(int)*pfVar1; } else { fVar5 = *pfVar1; } if ((uVar4 & 0x70) == 0) { *pfVar2 = (float)(int)ABS(fVar5); } else { *pfVar2 = ABS(fVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_add.html": {
    "href": "cmd_add.html",
    "title": "cmd_add",
    "keywords": "cmd_add Adds a value to the another, and stores the added value to the first parameter. Code Information Name: cmd_add Scope: Global PAC Instruction (Binary): 25 00 08 00 Assembly Address in Memory : 0x8837d18 Parameters cmd_add((int/float *)target, (int/float)value) (Int/Float *)target (8 bytes) : This value is for reading/writing, and will be modified. (Int/Float)value (8 bytes) : Can be variable or immediate value. This value is for reading. This performs target += value (or target = target + value). Example Here is one example in hex: 25 00 08 00 / 20 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 40 Which is interpreted as: cmd_add((float *)fVar0, (float)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837d18(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; uint uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); uVar4 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); if ((uVar3 & 0x70) == 0) { if ((uVar4 & 0x70) == 0) { fVar5 = *pfVar2; } else { fVar5 = (float)(int)*pfVar2; } *pfVar1 = (float)((int)*pfVar1 + (int)fVar5); } else { if ((uVar4 & 0x70) == 0) { fVar5 = (float)(int)*pfVar2; } else { fVar5 = *pfVar2; } *pfVar1 = *pfVar1 + fVar5; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_addarray.html": {
    "href": "cmd_addarray.html",
    "title": "cmd_addArray",
    "keywords": "cmd_addArray Initialises a 4-bytes array with given size. Code Information Name: cmd_addArray Scope: Global PAC Instruction (Binary): 25 00 49 00 Assembly Address in Memory : 0x883b18c Parameters (int)array_length (8 bytes) : Capacity of the array. (Int/Float *)array_id (8 bytes) : Variable to store the array ID. Can be int or float. Array with float ID stores float values and Array with int ID stores int values. Example Here is one example in hex: 25 00 49 00 / 02 00 00 00 / 08 00 00 00 / 08 00 00 00 / 18 01 00 00 Which is interpreted as: cmd_addArray((int)8, ((global)int *)giVar280) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b18c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = Get_Array_BaseAddr(param_2); uVar3 = FUN_089fee14(uVar3,*puVar1); *puVar2 = uVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_atan2f.html": {
    "href": "cmd_atan2f.html",
    "title": "cmd_atan2f",
    "keywords": "cmd_atan2f Applies atan2 function to the value and stores the result as float. Code Information Name: cmd_atan2f Scope: Global PAC Instruction (Binary): 25 00 39 00 Assembly Address in Memory : 0x883a874 Parameters cmd_atan2f((float)value, (float *)destination) (Float)value (8 bytes) : Can be variable or constat value. This value will be used for reading only. (Float *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. This performs destination = Atan2(value). Note the both values must be float. Example Here is one example in hex: 25 00 39 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 03 00 00 00 / 20 00 00 00 / 04 00 00 00 Which is interpreted as: cmd_atan2f((float *)fVar2, (float *)fVar3, (float *)fVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a874(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; float *pfVar3; float fVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); fVar4 = (float)FUN_0880e604(*puVar1,*puVar2); *pfVar3 = (fVar4 * 180.0) / 3.141593; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_break.html": {
    "href": "cmd_break.html",
    "title": "cmd_break",
    "keywords": "cmd_break Seems like for debugging purpose. Curiosuly, this does nothing. Code Information Name: cmd_break Scope: Global PAC Instruction (Binary): 25 00 32 00 Assembly Address in Memory : 0x883a568 Parameters (Undefined)Var0 (8 bytes) (String)Var1 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a568(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_Param(param_2,0,1,4); Pac_Get_StringParam(param_2,auStack256); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_call.html": {
    "href": "cmd_call.html",
    "title": "cmd_call",
    "keywords": "cmd_call Go to the other instruction (like cmd_jmp), and go back to keep executing the next instruction, if the jumped instruction meets the end (through cmd_end). It is like calling a function in programming. Code Information Name: cmd_call Scope: Global PAC Instruction (Binary): 25 00 03 00 Assembly Address in Memory : 0x88379c8 Parameters (Address)address (4 bytes) The address is hex data offset from the PAC instruction file. Example Here is one example in hex: 25 00 03 00 / 10 03 00 00 Which is interpreted as: cmd_call(0x310) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088379c8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); Param_Print_Type(param_2,0); Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar1,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_calllabel.html": {
    "href": "cmd_calllabel.html",
    "title": "cmd_callLabel",
    "keywords": "cmd_callLabel Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_callLabel Scope: Global PAC Instruction (Binary): 25 00 3f 00 Assembly Address in Memory : 0x883ac38 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 00 3f 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: cmd_callLabel((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883ac38(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar1,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_calllabelid.html": {
    "href": "cmd_calllabelid.html",
    "title": "cmd_callLabelId",
    "keywords": "cmd_callLabelId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_callLabelId Scope: Global PAC Instruction (Binary): 25 00 3d 00 Assembly Address in Memory : 0x883ab6c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883ab6c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); Param_Print_Type(param_2,0); Set_ReturnContext(param_2); uVar2 = FUN_0883bc98(param_2,*puVar1); PAC::Cmd_Jump_Or_Call(param_2,uVar2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_cosf.html": {
    "href": "cmd_cosf.html",
    "title": "cmd_cosf",
    "keywords": "cmd_cosf Applies cosine function to the value and stores the result as float. Code Information Name: cmd_cosf Scope: Global PAC Instruction (Binary): 25 00 38 00 Assembly Address in Memory : 0x883a7b0 Parameters cmd_cosf((int/float)value, (float *)destination) (Int/Float)value (8 bytes) : Can be variable or constat value. This value will be used for reading only. (Float *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. This performs destination = Math.Cos(value). Example Here is one example in hex: 25 00 38 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: cmd_cosf((float *)fVar2, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a7b0(undefined4 param_1,undefined4 param_2) { float *pfVar1; undefined4 *puVar2; uint uVar3; undefined4 uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); if ((uVar3 & 0x70) == 0) { fVar5 = (float)(int)*pfVar1; } else { fVar5 = *pfVar1; } uVar4 = FUN_0880da1c((fVar5 * 2.0 * 3.141593) / 360.0); *puVar2 = uVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_dec.html": {
    "href": "cmd_dec.html",
    "title": "cmd_dec",
    "keywords": "cmd_dec Subtracts 1 from the value and stores the value. Works both for int and float. Code Information Name: cmd_dec Scope: Global PAC Instruction (Binary): 25 00 0d 00 Assembly Address in Memory : 0x8838308 Parameters cmd_dec((int/float *)value) (Int/Float *)value (8 bytes) : The value is for reading/writing, the value will be changed. This performs value--. Example Here is one example in hex: 25 00 0d 00 / 04 00 00 00 / 19 00 00 00 Which is interpreted as: cmd_dec((int *)iVar25) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838308(undefined4 param_1,undefined4 param_2) { float *pfVar1; uint uVar2; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_ParamType(param_2,0); Param_Print_Type(param_2,0); if ((uVar2 & 0x70) == 0) { *pfVar1 = (float)((int)*pfVar1 + -1); } else { *pfVar1 = *pfVar1 - 1.0; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_div.html": {
    "href": "cmd_div.html",
    "title": "cmd_div",
    "keywords": "cmd_div Divides a value from the another, and stores the divided value to the first parameter. Code Information Name: cmd_div Scope: Global PAC Instruction (Binary): 25 00 0b 00 Assembly Address in Memory : 0x8838130 Parameters cmd_div((int/float *)target, (int/float)value) (Int/Float *)target (8 bytes) : This value is for reading/writing, and will be modified. (Int/Float)value (8 bytes) : Can be variable or immediate value. This value is for reading. This performs target /= value (or target = target / value). value must not be zero. Example Here is one example in hex: 25 00 0b 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 20 41 Which is interpreted as: cmd_div((int *)iVar0, (float)10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838130(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; uint uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); uVar4 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); if ((uVar3 & 0x70) == 0) { if ((uVar4 & 0x70) == 0) { fVar5 = *pfVar2; } else { fVar5 = (float)(int)*pfVar2; } if (fVar5 == 0.0) { trap(7); } *pfVar1 = (float)((int)*pfVar1 / (int)fVar5); } else { if ((uVar4 & 0x70) == 0) { fVar5 = (float)(int)*pfVar2; } else { fVar5 = *pfVar2; } *pfVar1 = *pfVar1 / fVar5; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_end.html": {
    "href": "cmd_end.html",
    "title": "cmd_end",
    "keywords": "cmd_end Terminates the pac instruction sequence, without performing any next instruction (next line, jump, call etc). Code Information Name: cmd_end Scope: Global PAC Instruction (Binary): 25 00 01 00 Assembly Address in Memory : 0x88378a8 Parameters This function is parameterless. Example Here is one example in hex: 25 00 01 00 Which is interpreted as: cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088378a8(int *param_1,undefined4 param_2) { int iVar1; int iVar2; iVar1 = FUN_0883ca60(param_2); iVar2 = FUN_0883be98(param_2); if (iVar2 == 0) { if (iVar1 == 0) { FUN_0883bc28(param_2,0); (**(code **)(*param_1 + 0x1c))(param_1,param_2); PAC::PAC_setCmdId(param_2,0); } else { FUN_0883ca24(param_2); } } else { FUN_0883be3c(param_2); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "cmd_f16tof32.html": {
    "href": "cmd_f16tof32.html",
    "title": "cmd_F16toF32",
    "keywords": "cmd_F16toF32 Converts from float16 to float32. Code Information Name: cmd_F16toF32 Scope: Global PAC Instruction (Binary): 25 00 4d 00 Assembly Address in Memory : 0x883b540 Parameters (float *)destination (8 bytes) : float variable to save the result. (int *)source (8 bytes) : float16 value to convert, however as varaible, int variable is expected. Remarks Patapon 3 game mostly uses float32, float16 is uncommon case but still used. Example Here is one example in hex: 25 00 4d 00 / 20 00 00 00 / 15 00 00 00 / 08 00 00 00 / ef 01 00 00 Which is interpreted as: cmd_F16toF32((float *)fVar21, ((global)int *)giVar495) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b540(undefined4 param_1,undefined4 param_2) { uint *puVar1; ushort *puVar2; uint uVar3; uint uVar4; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (ushort *)Pac_Get_Param(param_2,1,1,4); uVar3 = (uint)*puVar2; uVar4 = 0; if (uVar3 != 0) { uVar4 = (uVar3 & 0x3ff) << 0xd | (uVar3 & 0x8000) << 0x10 | (((uVar3 & 0x7c00) >> 10) + 0x70) * 0x800000; } *puVar1 = uVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_f32tof16.html": {
    "href": "cmd_f32tof16.html",
    "title": "cmd_F32toF16",
    "keywords": "cmd_F32toF16 Converts from float32 to float16. Code Information Name: cmd_F32toF16 Scope: Global PAC Instruction (Binary): 25 00 4c 00 Assembly Address in Memory : 0x883b474 Parameters (int *)destination (8 bytes) : int variable to save float16 result. (float *)source (8 bytes) : float32 value to convert. Remarks Patapon 3 game mostly uses float32, float16 is uncommon case but still used. Example Here is one example in hex: 25 00 4c 00 / 08 00 00 00 / ef 01 00 00 / 20 00 00 00 / 15 00 00 00 Which is interpreted as: cmd_F32toF16(((global)int *)giVar495, (float *)fVar21) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b474(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; uint uVar3; uint uVar4; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar2; uVar3 = 0; if (uVar4 != 0) { uVar3 = ((uVar4 & 0x7f800000) >> 0x17) - 0x70; if ((int)uVar3 < 0) { *puVar1 = 0; goto LAB_0883b520; } if (0x1f < (int)uVar3) { uVar3 = 0x1f; } uVar3 = (uVar4 & 0x7fffff) >> 0xd | (uVar4 & 0x80000000) >> 0x10 | (uVar3 & 0x1f) << 10; } *puVar1 = uVar3; LAB_0883b520: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgand.html": {
    "href": "cmd_flgand.html",
    "title": "cmd_flgAND",
    "keywords": "cmd_flgAND Performs AND operation to every other parameter, and jumps to specific address if the result is true. Check about flag to learn about the flag. Code Information Name: cmd_flgAND Scope: Global PAC Instruction (Binary): 25 00 2c 00 Assembly Address in Memory : 0x883a120 Parameters (Address)address (4 bytes) : Address to jump if the result is true. (uint...)Var1 (>= 8 bytes) : This can be one or more. If this parameter is only one, it is just about true or false for the one parameter. Example Here is one example in hex: 25 00 2c 00 / 6C 24 01 00 / 02 00 00 00 / 69 0E 00 00 / 6A 0E 00 00 Which is interpreted as: cmd_flgAND(0x1246C, 0xE69, 0xE6A) Note that 02 00 00 00 is NOT repeated, and values after it are considered as same type. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a120(undefined4 param_1,undefined4 param_2) { bool bVar1; int iVar2; undefined4 *puVar3; int *piVar4; uint *puVar5; int iVar6; int iVar7; iVar2 = FUN_0883c070(param_2); bVar1 = true; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); piVar4 = (int *)Pac_Get_Param(param_2,1,0,1); iVar7 = 0; if (0 < *piVar4) { do { puVar5 = (uint *)Pac_Get_Param(param_2,2,0,4); if (((int)(uint)*(byte *)(*(int *)(iVar2 + 4) + (*puVar5 >> 3)) >> (*puVar5 & 7) & 1U) == 0) { bVar1 = false; iVar6 = *piVar4; } else { iVar6 = *piVar4; } iVar7 = iVar7 + 1; } while (iVar7 < iVar6); } if (bVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgclr.html": {
    "href": "cmd_flgclr.html",
    "title": "cmd_flgClr",
    "keywords": "cmd_flgClr Clears one or more constant flag ID(s). Check about flag to learn about the flag. Code Information Name: cmd_flgClr Scope: Global PAC Instruction (Binary): 25 00 28 00 Assembly Address in Memory : 0x8839e3c Parameters (index...)flagID (>= 8 bytes) : Immediate that stores flag ID. This parameter can be multiple. Example Here is one example in hex: 25 00 28 00 / 01 00 00 00 / ca 03 00 00 Which is interpreted as: cmd_flgClr(0x1, 0x3ca) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839e3c(undefined4 param_1,undefined4 param_2) { int iVar1; int *piVar2; uint *puVar3; byte *pbVar4; int iVar5; iVar1 = FUN_0883c070(param_2); piVar2 = (int *)Pac_Get_Param(param_2,0,0,1); iVar5 = 0; if (0 < *piVar2) { do { puVar3 = (uint *)Pac_Get_Param(param_2,1,0,4); iVar5 = iVar5 + 1; pbVar4 = (byte *)(*(int *)(iVar1 + 4) + (*puVar3 >> 3)); *pbVar4 = *pbVar4 & ((byte)(1 << (*puVar3 & 7)) ^ 0xff); } while (iVar5 < *piVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgclrid.html": {
    "href": "cmd_flgclrid.html",
    "title": "cmd_flgClrId",
    "keywords": "cmd_flgClrId Clears the specific flag ID from variable reference. Check about flag to learn about the flag. Code Information Name: cmd_flgClrId Scope: Global PAC Instruction (Binary): 25 00 2a 00 Assembly Address in Memory : 0x8839f88 Parameters (uint *)flagID (8 bytes) : Variable that stores flag ID. Example Here is one example in hex: 25 00 2a 00 / 04 00 00 00 / 0b 00 00 00 Which is interpreted as: cmd_flgClrId((int *)iVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839f88(undefined4 param_1,undefined4 param_2) { int iVar1; uint *puVar2; byte *pbVar3; iVar1 = FUN_0883c070(param_2); puVar2 = (uint *)Pac_Get_Param(param_2,0,1,4); pbVar3 = (byte *)(*(int *)(iVar1 + 4) + (*puVar2 >> 3)); *pbVar3 = *pbVar3 & ((byte)(1 << (*puVar2 & 7)) ^ 0xff); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgmemcpy.html": {
    "href": "cmd_flgmemcpy.html",
    "title": "cmd_flgMemcpy",
    "keywords": "cmd_flgMemcpy Copies multiple flag values from one to another. Code Information Name: cmd_flgMemcpy Scope: Global PAC Instruction (Binary): 25 00 45 00 Assembly Address in Memory : 0x883af88 Parameters (int)destination (8 bytes) : Start of the destination flag ID to put the copied values. (int)source (8 bytes) : Start of the source flag ID to copy. (int)amount (8 bytes) : Amount of flags to copy from the source to the destination. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883af88(undefined4 param_1,undefined4 param_2) { int iVar1; int *piVar2; int *piVar3; int *piVar4; int iVar5; int iVar6; byte *pbVar7; uint uVar8; uint uVar9; int iVar10; iVar1 = FUN_0883c070(param_2); piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); piVar3 = (int *)Pac_Get_Param(param_2,1,1,4); piVar4 = (int *)Pac_Get_Param(param_2,2,1,4); iVar5 = 0; if (0 < *piVar4) { iVar6 = *piVar3; while( true ) { iVar10 = *(int *)(iVar1 + 4); uVar9 = *piVar2 + iVar5 & 7; uVar8 = (uint)(*piVar2 + iVar5) >> 3; if (((int)(uint)*(byte *)(iVar10 + ((uint)(iVar6 + iVar5) >> 3)) >> (iVar6 + iVar5 & 7U) & 1U) == 0) { pbVar7 = (byte *)(iVar10 + uVar8); *pbVar7 = *pbVar7 & ((byte)(1 << uVar9) ^ 0xff); } else { pbVar7 = (byte *)(iVar10 + uVar8); *pbVar7 = *pbVar7 | (byte)(1 << uVar9); } iVar5 = iVar5 + 1; if (*piVar4 <= iVar5) break; iVar6 = *piVar3; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgmemset.html": {
    "href": "cmd_flgmemset.html",
    "title": "cmd_flgMemset",
    "keywords": "cmd_flgMemset Sets multiple flag values at once. Code Information Name: cmd_flgMemset Scope: Global PAC Instruction (Binary): 25 00 44 00 Assembly Address in Memory : 0x883ae78 Parameters (int)start (8 bytes) : Starting flag ID to set the values. (bool)value (8 bytes) : Either 0 or 1, value to set to the flags. (int)amount (8 bytes) : Amount of flags to set from the start Example Here is one example in hex: 25 00 44 00 / 02 00 00 00 / 83 08 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 84 03 00 00 Which is interpreted as: cmd_flgMemset((int)2179, (int)0, (int)900) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883ae78(undefined4 param_1,undefined4 param_2) { int iVar1; int *piVar2; int *piVar3; int *piVar4; int iVar5; int iVar6; uint uVar7; byte *pbVar8; uint uVar9; iVar1 = FUN_0883c070(param_2); piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); piVar3 = (int *)Pac_Get_Param(param_2,1,1,4); piVar4 = (int *)Pac_Get_Param(param_2,2,1,4); iVar5 = 0; if (0 < *piVar4) { iVar6 = *piVar2; while( true ) { uVar9 = iVar6 + iVar5 & 7; uVar7 = (uint)(iVar6 + iVar5) >> 3; if (*piVar3 == 1) { pbVar8 = (byte *)(*(int *)(iVar1 + 4) + uVar7); *pbVar8 = *pbVar8 | (byte)(1 << uVar9); } else { pbVar8 = (byte *)(*(int *)(iVar1 + 4) + uVar7); *pbVar8 = *pbVar8 & ((byte)(1 << uVar9) ^ 0xff); } iVar5 = iVar5 + 1; if (*piVar4 <= iVar5) break; iVar6 = *piVar2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgmov.html": {
    "href": "cmd_flgmov.html",
    "title": "cmd_flgMov",
    "keywords": "cmd_flgMov Assigns an assigned flag value to another flag. Check about flag to learn about the flag. Code Information Name: cmd_flgMov Scope: Global PAC Instruction (Binary): 25 00 2b 00 Assembly Address in Memory : 0x883a00c Parameters (uint)destination (8 bytes) : Flag ID to store the value. (uint)value (8 bytes) : Flag ID that has value to move. Example Here is one example in hex: 25 00 2b 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / c5 17 00 00 Which is interpreted as: cmd_flgMov((int *)0, (int *)6085) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a00c(undefined4 param_1,undefined4 param_2) { int iVar1; uint *puVar2; uint *puVar3; byte *pbVar4; iVar1 = FUN_0883c070(param_2); puVar2 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,1,1,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); iVar1 = *(int *)(iVar1 + 4); if (((int)(uint)*(byte *)(iVar1 + (*puVar3 >> 3)) >> (*puVar3 & 7) & 1U) == 0) { pbVar4 = (byte *)(iVar1 + (*puVar2 >> 3)); *pbVar4 = *pbVar4 & ((byte)(1 << (*puVar2 & 7)) ^ 0xff); } else { pbVar4 = (byte *)(iVar1 + (*puVar2 >> 3)); *pbVar4 = *pbVar4 | (byte)(1 << (*puVar2 & 7)); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgor.html": {
    "href": "cmd_flgor.html",
    "title": "cmd_flgOR",
    "keywords": "cmd_flgOR Performs OR operation to every other parameter, and jumps to specific address if the result is true. Check about flag to learn about the flag. Code Information Name: cmd_flgOR Scope: Global PAC Instruction (Binary): 25 00 2d 00 Assembly Address in Memory : 0x883a22c Parameters (Address)address (4 bytes) : Address to jump if the result is true. (uint...)Var1 (>= 8 bytes) : This can be one or more. If this parameter is only one, it is just about true or false for the one parameter. Example Here is one example in hex: 25 00 2D 00 / 50 BE 01 00 / 04 00 00 00 / 25 0C 00 00 / 26 0C 00 00 / 27 0C 00 00 / 28 0C 00 00 Which is interpreted as: cmd_flgOR(0x1BE50, (int*)C25, (int*)C26, (int*)C27, (int*)C28) Note that 04 00 00 00 is NOT repeated, and values after it considered as same type. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a22c(undefined4 param_1,undefined4 param_2) { bool bVar1; int iVar2; undefined4 *puVar3; int *piVar4; uint *puVar5; int iVar6; int iVar7; iVar2 = FUN_0883c070(param_2); bVar1 = false; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); piVar4 = (int *)Pac_Get_Param(param_2,1,0,1); iVar7 = 0; if (0 < *piVar4) { do { puVar5 = (uint *)Pac_Get_Param(param_2,2,0,4); if (((int)(uint)*(byte *)(*(int *)(iVar2 + 4) + (*puVar5 >> 3)) >> (*puVar5 & 7) & 1U) == 1) { bVar1 = true; iVar6 = *piVar4; } else { iVar6 = *piVar4; } iVar7 = iVar7 + 1; } while (iVar7 < iVar6); } if (bVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgset.html": {
    "href": "cmd_flgset.html",
    "title": "cmd_flgSet",
    "keywords": "cmd_flgSet Sets one or more constant flag ID(s). Check about flag to learn about the flag. Code Information Name: cmd_flgSet Scope: Global PAC Instruction (Binary): 25 00 27 00 Assembly Address in Memory : 0x8839d74 Parameters (index...)flagID (>= 8 bytes) : Immediate flag ID value. This parameter can be multiple. Example Here is one example in hex: 25 00 27 00 / 01 00 00 00 / 9c 03 00 00 Which is interpreted as: cmd_flgSet(0x39c) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839d74(undefined4 param_1,undefined4 param_2) { int iVar1; int *piVar2; uint *puVar3; byte *pbVar4; int iVar5; iVar1 = FUN_0883c070(param_2); piVar2 = (int *)Pac_Get_Param(param_2,0,0,1); iVar5 = 0; if (0 < *piVar2) { do { puVar3 = (uint *)Pac_Get_Param(param_2,1,0,4); iVar5 = iVar5 + 1; pbVar4 = (byte *)(*(int *)(iVar1 + 4) + (*puVar3 >> 3)); *pbVar4 = *pbVar4 | (byte)(1 << (*puVar3 & 7)); } while (iVar5 < *piVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgsetid.html": {
    "href": "cmd_flgsetid.html",
    "title": "cmd_flgSetId",
    "keywords": "cmd_flgSetId Sets the specific flag ID from variable reference. Check about flag to learn about the flag. Code Information Name: cmd_flgSetId Scope: Global PAC Instruction (Binary): 25 00 29 00 Assembly Address in Memory : 0x8839f08 Parameters (uint *)flagID (8 bytes) : Variable that stores flag ID. Example Here is one example in hex: 25 00 29 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: cmd_flgSetId((int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839f08(undefined4 param_1,undefined4 param_2) { int iVar1; uint *puVar2; byte *pbVar3; iVar1 = FUN_0883c070(param_2); puVar2 = (uint *)Pac_Get_Param(param_2,0,1,4); pbVar3 = (byte *)(*(int *)(iVar1 + 4) + (*puVar2 >> 3)); *pbVar3 = *pbVar3 | (byte)(1 << (*puVar2 & 7)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_flgzero.html": {
    "href": "cmd_flgzero.html",
    "title": "cmd_flgZERO",
    "keywords": "cmd_flgZERO Jumps to specific address if every parameter is zero. Opposite to cmd_flgAND. Check about flag to learn about the flag. Code Information Name: cmd_flgZERO Scope: Global PAC Instruction (Binary): 25 00 2e 00 Assembly Address in Memory : 0x883a33c Parameters (Address)address (4 bytes) : Address to jump if the result is true. (index...)Var1 (>= 8 bytes) : This can be one or more. If this parameter is only one, it is just about true or false for the one parameter. Example Here is one example in hex: 25 00 2e 00 / b8 09 00 00 / 01 00 00 00 / c6 03 00 00 Which is interpreted as: cmd_flgZERO(0x9b8, 0x3c6) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a33c(undefined4 param_1,undefined4 param_2) { bool bVar1; int iVar2; undefined4 *puVar3; int *piVar4; uint *puVar5; int iVar6; int iVar7; iVar2 = FUN_0883c070(param_2); bVar1 = true; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); piVar4 = (int *)Pac_Get_Param(param_2,1,0,1); iVar7 = 0; if (0 < *piVar4) { do { puVar5 = (uint *)Pac_Get_Param(param_2,2,0,4); if (((int)(uint)*(byte *)(*(int *)(iVar2 + 4) + (*puVar5 >> 3)) >> (*puVar5 & 7) & 1U) == 1) { bVar1 = false; iVar6 = *piVar4; } else { iVar6 = *piVar4; } iVar7 = iVar7 + 1; } while (iVar7 < iVar6); } if (bVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_getarray.html": {
    "href": "cmd_getarray.html",
    "title": "cmd_getArray",
    "keywords": "cmd_getArray Gets value from a 4-bytes array. The array must be initialised through cmd_addArray first. Code Information Name: cmd_getArray Scope: Global PAC Instruction (Binary): 25 00 4b 00 Assembly Address in Memory : 0x883b350 Parameters (int)array_index (8 bytes) : Array Index. (Int/Float)array_id (8 bytes) : Array ID, obtained from cmd_initarray. can be int or float. (Int/Float *)destination (8 bytes) : Variable to store the obtained value. Array with float ID stores float values and Array with int ID stores int values. Example Here is one example in hex: 25 00 4b 00 / 08 00 00 00 / a7 00 00 00 / 08 00 00 00 / 18 01 00 00 / 08 00 00 00 / a8 00 00 00 Which is interpreted as: cmd_getArray(((global)int *)giVar167, ((global)int *)giVar280, ((global)int *)giVar168) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b350(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; float *pfVar3; uint uVar4; uint uVar5; undefined4 uVar6; float *pfVar7; float fVar8; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_ParamType(param_2,1); uVar5 = Pac_Get_ParamType(param_2,2); uVar6 = Get_Array_BaseAddr(param_2); pfVar7 = (float *)FUN_089fee24(uVar6,*puVar2,*puVar1); if ((uVar5 & 0x70) == 0) { if ((uVar4 & 0x70) == 0) { fVar8 = *pfVar7; } else { fVar8 = (float)(int)*pfVar7; } *pfVar3 = fVar8; } else { if ((uVar4 & 0x70) == 0) { fVar8 = (float)(int)*pfVar7; } else { fVar8 = *pfVar7; } *pfVar3 = fVar8; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_getelapsedtime.html": {
    "href": "cmd_getelapsedtime.html",
    "title": "cmd_getElapsedTime",
    "keywords": "cmd_getElapsedTime Gets the time between. Usually the value is 1. (Guessing this could be between frames, but not sure about this magic, please fix if you know this.) Code Information Name: cmd_getElapsedTime Scope: Global PAC Instruction (Binary): 25 00 4e 00 Assembly Address in Memory : 0x883b5e8 Parameters (float *)destination (8 bytes) : Store the time elapsed. Writing only. Example Here is one example in hex: 25 00 4e 00 / 20 00 00 00 / 03 00 00 00 Which is interpreted as: cmd_getElapsedTime((float *)fVar3) Remarks This get specific \"time divider\" value, which is 160 (0xA0) here. And the \"between time\" is also the 160 (0xA0), so dividing them results 1. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b5e8(undefined4 param_1,undefined4 param_2) { float *pfVar1; int iVar2; uint uVar3; float fVar4; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Time_Between(param_2); uVar3 = Get_TimeDivider(0x3f800000); if ((int)uVar3 < 0) { fVar4 = (float)(uVar3 >> 1 | uVar3 & 1); fVar4 = fVar4 + fVar4; } else { fVar4 = (float)uVar3; } *pfVar1 = (float)iVar2 / fVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_iand.html": {
    "href": "cmd_iand.html",
    "title": "cmd_iand",
    "keywords": "cmd_iand Performs and (&) operation to the another, and stores the added value to the first parameter. Code Information Name: cmd_iand Scope: Global PAC Instruction (Binary): 25 00 12 00 Assembly Address in Memory : 0x883867c Parameters cmd_iand((uint *)target, (uint)value) (uint *)target (8 bytes) : This value is for reading/writing, and will be modified. (uint)value (8 bytes) : This value is for reading. This performs target &= value (or target = target & value). Example Here is one example in hex: 25 00 12 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 07 00 00 00 Which is interpreted as: cmd_iand((int *)iVar0, (int)7) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883867c(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar1 = *puVar1 & *puVar2; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifand.html": {
    "href": "cmd_ifand.html",
    "title": "cmd_ifAND",
    "keywords": "cmd_ifAND Jumps to a specific instruction (without executing next) if the and calculation result is not zero. Code Information Name: cmd_ifAND Scope: Global PAC Instruction (Binary): 25 00 1d 00 Assembly Address in Memory : 0x8839130 Parameters cmd_ifAND((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs `if((value1 & value2) != 0) goto address; Example Here is one example in hex: 25 00 1d 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 10 00 00 / 40 10 00 00 Which is interpreted as: cmd_ifAND((int *)iVar0, (int)4096, 0x1040) 4096 is 0x1000, as binary it checks 12th place is one, not zero. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839130(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; undefined4 *puVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((*puVar1 & *puVar2) != 0) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcalland.html": {
    "href": "cmd_ifcalland.html",
    "title": "cmd_ifCallAND",
    "keywords": "cmd_ifCallAND Calls another instruciton line, if the and calculation result is not zero. Code Information Name: cmd_ifCallAND Scope: Global PAC Instruction (Binary): 25 00 25 00 Assembly Address in Memory : 0x8839bbc Parameters cmd_ifCallAND((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if((value1 & value2) != 0) { (address*)(); }...; Example Here is one example in hex: 25 00 25 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 80 00 00 / e4 2a 00 00 Which is interpreted as: cmd_ifCallAND((int *)iVar1, (int)32768, 0x2ae4) 32768 is 0x8000, as binary it checks 15th place is one, not zero. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839bbc(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; undefined4 *puVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((*puVar1 & *puVar2) != 0) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcalleq.html": {
    "href": "cmd_ifcalleq.html",
    "title": "cmd_ifCallEQ",
    "keywords": "cmd_ifCallEQ Compares two values and calls another instruciton line, if the value is equal to the other one. Code Information Name: cmd_ifCallEQ Scope: Global PAC Instruction (Binary): 25 00 1f 00 Assembly Address in Memory : 0x88392d8 Parameters cmd_ifCallEQ((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if(value1 == value2){ (address*)(); }...; Remarks For int/float, the function converts the type automatically Example Here is one example in hex: 25 00 1f 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 18 98 00 00 Which is interpreted as: cmd_ifCallEQ((int *)iVar0, (float)1, 0x9818) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088392d8(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if (*pfVar1 == fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 == fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcalllb.html": {
    "href": "cmd_ifcalllb.html",
    "title": "cmd_ifCallLB",
    "keywords": "cmd_ifCallLB Compares two values and calls another instruciton line, if the value is bigger than the other one. Code Information Name: cmd_ifCallLB Scope: Global PAC Instruction (Binary): 25 00 24 00 Assembly Address in Memory : 0x8839a38 Parameters cmd_ifCallLB((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be bigger than value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be smaller than value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if(value1 > value2){ (address*)(); }...; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 24 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / a0 ee 00 00 Which is interpreted as: cmd_ifCallLB((int *)iVar0, (float)0, 0xeea0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839a38(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)fVar6 < (int)*pfVar1) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (fVar6 < *pfVar1) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcalllbe.html": {
    "href": "cmd_ifcalllbe.html",
    "title": "cmd_ifCallLBE",
    "keywords": "cmd_ifCallLBE Compares two values and calls another instruciton line, if the value is bigger than or equal to the other one. Code Information Name: cmd_ifCallLBE Scope: Global PAC Instruction (Binary): 25 00 22 00 Assembly Address in Memory : 0x8839730 Parameters cmd_ifCallLBE((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be bigger than or equal to value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be smaller than or equal to value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if(value1 >= value2){ (address*)(); }...; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 22 00 / 08 00 00 00 / a8 00 00 00 / 10 00 00 00 / 00 00 00 00 / ac 3e 01 00 Which is interpreted as: cmd_ifCallLBE(((global)int *)giVar168, (float)0, 0x13eac) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839730(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)fVar6 <= (int)*pfVar1) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (fVar6 <= *pfVar1) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcallls.html": {
    "href": "cmd_ifcallls.html",
    "title": "cmd_ifCallLS",
    "keywords": "cmd_ifCallLS Compares two values and calls another instruciton line, if the value is smaller than the other one. Code Information Name: cmd_ifCallLS Scope: Global PAC Instruction (Binary): 25 00 23 00 Assembly Address in Memory : 0x88398b4 Parameters cmd_ifCallLS((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be smaller than value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be bigger than value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if(value1 < value2){ (address*)(); }...; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 23 00 / 04 00 00 00 / 19 00 00 00 / 10 00 00 00 / 00 00 00 00 / 38 24 01 00 Which is interpreted as: cmd_ifCallLS((int *)iVar25, (float)0, 0x12438) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088398b4(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)*pfVar1 < (int)fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 < fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcalllse.html": {
    "href": "cmd_ifcalllse.html",
    "title": "cmd_ifCallLSE",
    "keywords": "cmd_ifCallLSE Compares two values and calls another instruciton line, if the value is smaller than or equal to the other one. Code Information Name: cmd_ifCallLSE Scope: Global PAC Instruction (Binary): 25 00 21 00 Assembly Address in Memory : 0x88395ac Parameters cmd_ifCallLSE((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be smaller than or equal to value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be bigger than or equal to value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if(value1 <= value2){ (address*)(); }...; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 21 00 / 10 00 00 00 / 00 00 c8 42 / 08 00 00 00 / 93 00 00 00 / 04 c8 05 00 Which is interpreted as: cmd_ifCallLSE((float)100, ((global)int *)giVar147, 0x5c804) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088395ac(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)*pfVar1 <= (int)fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 <= fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcallne.html": {
    "href": "cmd_ifcallne.html",
    "title": "cmd_ifCallNE",
    "keywords": "cmd_ifCallNE Compares two values and calls another instruciton line, if the value is different from the other one. Code Information Name: cmd_ifCallNE Scope: Global PAC Instruction (Binary): 25 00 20 00 Assembly Address in Memory : 0x883942c Parameters cmd_ifCallNE((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if(value1 != value2){ (address*)(); }...; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 20 00 / 40 00 00 00 / cd 00 00 00 / 10 00 00 00 / 00 00 80 bf / e4 16 00 00 Which is interpreted as: cmd_ifCallNE(((global)float *)gfVar205, (float)-1, 0x16e4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883942c(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if (*pfVar1 != fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 != fVar6) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifcallor.html": {
    "href": "cmd_ifcallor.html",
    "title": "cmd_ifCallOR",
    "keywords": "cmd_ifCallOR Calls another instruciton line, if the or calculation result is not zero. Code Information Name: cmd_ifCallOR Scope: Global PAC Instruction (Binary): 25 00 26 00 Assembly Address in Memory : 0x8839c98 Parameters cmd_ifCallOR((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to call, the address is hex instruction offset from the PAC file. This performs if((value1 | value2) != 0) { (address*)(); }...; Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839c98(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; undefined4 *puVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((*puVar1 | *puVar2) != 0) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifeq.html": {
    "href": "cmd_ifeq.html",
    "title": "cmd_ifEQ",
    "keywords": "cmd_ifEQ Compares two values and jumps to a specific instruction (without executing next) if the value is equal to the other one. Code Information Name: cmd_ifEQ Scope: Global PAC Instruction (Binary): 25 00 17 00 Assembly Address in Memory : 0x88388ac Parameters cmd_ifEQ((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs if(value1 == value2) goto address; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 17 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 40 / 58 03 00 00 Which is interpreted as: cmd_ifEQ((int *)iVar0, (float)2, 0x358) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088388ac(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if (*pfVar1 == fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 == fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_iflb.html": {
    "href": "cmd_iflb.html",
    "title": "cmd_ifLB",
    "keywords": "cmd_ifLB Compares two values and jumps to a specific instruction (without executing next) if the value is bigger than the other one. Code Information Name: cmd_ifLB Scope: Global PAC Instruction (Binary): 25 00 1c 00 Assembly Address in Memory : 0x8838fbc Parameters cmd_ifLB((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be bigger than value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be smaller than value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs if(value1 > value2) goto address; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 1c 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 02 00 00 00 / dc 14 00 00 Which is interpreted as: cmd_ifLB((float *)fVar0, (float *)fVar2, 0x14dc) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838fbc(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)fVar6 < (int)*pfVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (fVar6 < *pfVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_iflbe.html": {
    "href": "cmd_iflbe.html",
    "title": "cmd_ifLBE",
    "keywords": "cmd_ifLBE Compares two values and jumps to a specific instruction (without executing next) if the value is bigger than or equal to the other one. Code Information Name: cmd_ifLBE Scope: Global PAC Instruction (Binary): 25 00 1a 00 Assembly Address in Memory : 0x8838cd4 Parameters cmd_ifLBE((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be bigger than or equal to value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be smaller than or equal to value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs if(value1 >= value2) goto address; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 1a 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / d8 99 00 00 Which is interpreted as: cmd_ifLBE((int *)iVar0, (int *)iVar1, 0x99d8) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838cd4(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)fVar6 <= (int)*pfVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (fVar6 <= *pfVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifls.html": {
    "href": "cmd_ifls.html",
    "title": "cmd_ifLS",
    "keywords": "cmd_ifLS Compares two values and jumps to a specific instruction (without executing next) if the value is smaller than the other one. Code Information Name: cmd_ifLS Scope: Global PAC Instruction (Binary): 25 00 1b 00 Assembly Address in Memory : 0x8838e48 Parameters cmd_ifLS((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes): The value that might be smaller than value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be bigger than value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs if(value1 < value2) goto address; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 1b 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 02 00 00 00 / 24 15 00 00 Which is interpreted as: cmd_ifLS((float *)fVar0, (float *)fVar2, 0x1524) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838e48(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)*pfVar1 < (int)fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 < fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_iflse.html": {
    "href": "cmd_iflse.html",
    "title": "cmd_ifLSE",
    "keywords": "cmd_ifLSE Compares two values and jumps to a specific instruction (without executing next) if the value is smaller than or equal to the other one. Code Information Name: cmd_ifLSE Scope: Global PAC Instruction (Binary): 25 00 19 00 Assembly Address in Memory : 0x8838b60 Parameters cmd_ifLSE((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : The value that might be smaller than or equal to value2. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The value that might be bigger than or equal to value1. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs if(value1 <= value2) goto address; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 19 00 / 20 00 00 00 / 0a 00 00 00 / 10 00 00 00 / 00 00 20 43 / 14 a7 00 00 Which is interpreted as: cmd_ifLSE((float *)fVar10, (float)160, 0xa714) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838b60(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { // get max loot level fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if ((int)*pfVar1 <= (int)fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 <= fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifne.html": {
    "href": "cmd_ifne.html",
    "title": "cmd_ifNE",
    "keywords": "cmd_ifNE Compares two values and jumps to a specific instruction (without executing next) if the value is different from the other one. Code Information Name: cmd_ifNE Scope: Global PAC Instruction (Binary): 25 00 18 00 Assembly Address in Memory : 0x88389f0 Parameters cmd_ifNE((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs if(value1 != value2) goto address; Remarks For int/float, the function converts the type automatically. Example Here is one example in hex: 25 00 18 00 / 04 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 40 / d8 99 00 00 Which is interpreted as: cmd_ifNE((int *)iVar1, (float)2, 0x99d8) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088389f0(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; undefined4 *puVar3; uint uVar4; uint uVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } if (*pfVar1 != fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } if (*pfVar1 != fVar6) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ifor.html": {
    "href": "cmd_ifor.html",
    "title": "cmd_ifOR",
    "keywords": "cmd_ifOR Jumps to a specific instruction (without executing next) if the or calculation result is not zero. Code Information Name: cmd_ifOR Scope: Global PAC Instruction (Binary): 25 00 1e 00 Assembly Address in Memory : 0x8839204 Parameters cmd_ifOR((int/float)value1, (int/float)value2, (Address)address) (Int/Float)value1 (8 bytes) : A value to compare. Can be variable or immediate. Read-only. (Int/Float)value2 (8 bytes) : The another value to compare. Can be variable or immediate. Read-only. (Address)address (4 bytes) : Address to jump, the address is hex instruction offset from the PAC file. This performs `if((value1 | value2) != 0) goto address; Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08839204(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; undefined4 *puVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); Param_Print_Type(param_2,2); if ((*puVar1 | *puVar2) != 0) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_inc.html": {
    "href": "cmd_inc.html",
    "title": "cmd_inc",
    "keywords": "cmd_inc Adds 1 to the value and stores the value. Works both for int and float. Code Information Name: cmd_inc Scope: Global PAC Instruction (Binary): 25 00 0c 00 Assembly Address in Memory : 0x883825c Parameters cmd_inc((int/float *)value) (8 bytes) (Int/Float *)value: The value is for reading/writing, the value will be changed. This performs value++. Example Here is one example in hex: 25 00 0c 00 / 04 00 00 00 / 05 00 00 00 Which is interpreted as: cmd_inc((int *)iVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883825c(undefined4 param_1,undefined4 param_2) { float *pfVar1; uint uVar2; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_ParamType(param_2,0); Param_Print_Type(param_2,0); if ((uVar2 & 0x70) == 0) { *pfVar1 = (float)((int)*pfVar1 + 1); } else { *pfVar1 = *pfVar1 + 1.0; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_initarray.html": {
    "href": "cmd_initarray.html",
    "title": "cmd_initArray",
    "keywords": "cmd_initArray Called once in very first time to initialise before setting up cmd_flgMemset etc. Code Information Name: cmd_initArray Scope: Global PAC Instruction (Binary): 25 00 48 00 Assembly Address in Memory : 0x883b150 Parameters This function is parameterless. Example Here is one example in hex: 25 00 48 00 Which is interpreted as: cmd_initArray() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b150(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; uVar1 = Get_Array_BaseAddr(param_2); FUN_089fee70(uVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_inxjmp.html": {
    "href": "cmd_inxjmp.html",
    "title": "cmd_inxJmp",
    "keywords": "cmd_inxJmp Retrieves the address from address parameters (or table) by given index, and jump to the address. Used in e.g. hideout facility selection. Code Information Name: cmd_inxJmp Scope: Global PAC Instruction (Binary): 25 00 2f 00 Assembly Address in Memory : 0x883a44c Parameters (int)index (8 bytes) (Address...)address (4 bytes) ... is multiple parameters. In here, it is jump tables. Example Here is one example in hex: c8 b2 05 00 / 98 0c 04 00 / 70 2d 04 00 / 70 2d 04 00 / 70 2d 04 00 /a8 d6 05 00 /58 a4 05 00 / 28 d6 05 00 70 2d 04 00 /94 ce 05 00 /bc d5 05 00 /70 2d 04 00 / 70 2d 04 00 ``` Which is interpreted as: ```c cmd_inxJmp((int *)iVar40, 0x5b2c8, 0x40c98, 0x42d70, 0x42d70, 0x42d70, 0x5d6a8, 0x5a458, 0x5d628, 0x42d70, 0x5ce94, 0x5d5bc, 0x42d70, 0x42d70) if iVar40 is 0, it jumps to 0x5b2c8, and if the iVar40 is 6, it goes to 0x5a458 and so on. Remarks This can be considered as having only one parameter and having jump table as next values. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a44c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); PAC::Cmd_Jump_Or_Call(param_2,*piVar1 << 2,1); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,0,4); PAC::Cmd_Jump_Or_Call(param_2,*puVar2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ior.html": {
    "href": "cmd_ior.html",
    "title": "cmd_ior",
    "keywords": "cmd_ior Performs or (|) operation to the another, and stores the added value to the first parameter. Code Information Name: cmd_ior Scope: Global PAC Instruction (Binary): 25 00 13 00 Assembly Address in Memory : 0x88386ec Parameters cmd_ior((uint *)target, (uint)value) (uint *)target (8 bytes) : This value is for reading/writing, and will be modified. (uint)value (8 bytes) : This value is for reading. This performs target |= value (or target = target & value). Example Here is one example in hex: 25 00 13 00 / 08 00 00 00 / ee 01 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: cmd_ior(((global)int *)giVar494, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088386ec(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar1 = *puVar1 | *puVar2; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_irol.html": {
    "href": "cmd_irol.html",
    "title": "cmd_irol",
    "keywords": "cmd_irol Performs left-shift calculation. Code Information Name: cmd_irol Scope: Global PAC Instruction (Binary): 25 00 15 00 Assembly Address in Memory : 0x88387cc Parameters (uint *)value (8 bytes) : Value to shift. Read and write, the result is saved here. (uint)amount (8 bytes) : Amount to shift. This performs value = value << amount. Example Here is one example in hex: 25 00 15 00 / 08 00 00 00 / f8 01 00 00 / 02 00 00 00 / 08 00 00 00 Which is interpreted as: cmd_irol(((global)int *)giVar504, (int)8) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088387cc(undefined4 param_1,undefined4 param_2) { int *piVar1; uint *puVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *piVar1 = *piVar1 << (*puVar2 & 0x1f); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_iror.html": {
    "href": "cmd_iror.html",
    "title": "cmd_iror",
    "keywords": "cmd_iror Performs right-shift calculation. Code Information Name: cmd_iror Scope: Global PAC Instruction (Binary): 25 00 16 00 Assembly Address in Memory : 0x883883c Parameters (uint)value (8 bytes) : Value to shift. Read and write, the result is saved here. (uint)amount (8 bytes) : Amount to shift. This performs value = value >> amount. Example Here is one example in hex: 25 00 16 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 08 00 00 00 Which is interpreted as: cmd_iror((int *)iVar0, (int)8) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883883c(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar1 = *puVar1 >> (*puVar2 & 0x1f); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_ixor.html": {
    "href": "cmd_ixor.html",
    "title": "cmd_ixor",
    "keywords": "cmd_ixor Performs xor (^) operation to the another, and stores the added value to the first parameter. Code Information Name: cmd_ixor Scope: Global PAC Instruction (Binary): 25 00 14 00 Assembly Address in Memory : 0x883875c Parameters cmd_ior((uint *)target, (uint)value) (uint *)target (8 bytes) : This value is for reading/writing, and will be modified. (uint)value (8 bytes) : This value is for reading. This performs target ^= value (or target = target ^ value). Example Here is one example in hex: 25 00 14 00 / 08 00 00 00 / 5b 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cmd_ixor(((global)int *)giVar91, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883875c(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar1 = *puVar1 ^ *puVar2; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_jmp.html": {
    "href": "cmd_jmp.html",
    "title": "cmd_jmp",
    "keywords": "cmd_jmp Starts reading other instruction from the specific address, instead of the next instruction. It is goto instruction. Code Information Name: cmd_jmp Scope: Global PAC Instruction (Binary): 25 00 02 00 Assembly Address in Memory : 0x8837960 Parameters (Address)address (4 bytes) The address is hex data offset from the PAC instruction file. Example Here is one example in hex: 25 00 02 00 / 14 00 00 00 Which is interpreted as: cmd_jmp(0x14) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837960(undefined4 param_1,undefined4 param_2) { undefined4 *jump_offset; jump_offset = (undefined4 *)Pac_Get_Param(param_2,0,0,4); Param_Print_Type(param_2,0); PAC::Cmd_Jump_Or_Call(param_2,*jump_offset,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_jmplabel.html": {
    "href": "cmd_jmplabel.html",
    "title": "cmd_jmpLabel",
    "keywords": "cmd_jmpLabel Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_jmpLabel Scope: Global PAC Instruction (Binary): 25 00 40 00 Assembly Address in Memory : 0x883abe8 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883abe8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); PAC::Cmd_Jump_Or_Call(param_2,*puVar1,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_jmplabelid.html": {
    "href": "cmd_jmplabelid.html",
    "title": "cmd_jmpLabelId",
    "keywords": "cmd_jmpLabelId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_jmpLabelId Scope: Global PAC Instruction (Binary): 25 00 3e 00 Assembly Address in Memory : 0x883ab10 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883ab10(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = FUN_0883bc98(param_2,*puVar1); PAC::Cmd_Jump_Or_Call(param_2,uVar2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_loop.html": {
    "href": "cmd_loop.html",
    "title": "cmd_loop",
    "keywords": "cmd_loop Repeats jumping to the address for the given amount. Code Information Name: cmd_loop Scope: Global PAC Instruction (Binary): 25 00 0e 00 Assembly Address in Memory : 0x88383b4 Parameters (int)amount (8 bytes) : How much jumping should be repeated. (Address)address (4 bytes) : Address to jump. Example Here is one example in hex: 25 00 0e 00 / 04 00 00 00 / 02 00 00 00 / f0 38 06 00 Which is interpreted as: cmd_loop((int *)iVar2, 0x638f0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088383b4(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,0,4); iVar3 = *piVar1; *piVar1 = iVar3 + -1; if (iVar3 + -1 != 0) { PAC::Cmd_Jump_Or_Call(param_2,*puVar2,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_memcpy.html": {
    "href": "cmd_memcpy.html",
    "title": "cmd_memcpy",
    "keywords": "cmd_memcpy Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_memcpy Scope: Global PAC Instruction (Binary): 25 00 43 00 Assembly Address in Memory : 0x883ade4 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (int)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883ade4(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 uVar2; int *piVar3; uVar1 = Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); syscall::Kernel::sceKernelMemCpy(uVar1,uVar2,*piVar3 << 2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_memset.html": {
    "href": "cmd_memset.html",
    "title": "cmd_memset",
    "keywords": "cmd_memset Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_memset Scope: Global PAC Instruction (Binary): 25 00 42 00 Assembly Address in Memory : 0x883ac9c Parameters (Int/Float)Var0 (8 bytes) (Int/Float)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 00 42 00 / 08 00 00 00 / 2c 01 00 00 / 10 00 00 00 / 00 00 00 00 / 02 00 00 00 / 70 00 00 00 Which is interpreted as: cmd_memset(((global)int *)giVar300, (float)0, (int)112) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883ac9c(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; int *piVar3; uint uVar4; uint uVar5; float fVar6; int iVar7; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_ParamType(param_2,0); uVar5 = Pac_Get_ParamType(param_2,1); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar6 = *pfVar2; } else { fVar6 = (float)(int)*pfVar2; } iVar7 = 0; if (0 < *piVar3) { do { *pfVar1 = fVar6; iVar7 = iVar7 + 1; pfVar1 = pfVar1 + 1; } while (iVar7 < *piVar3); } } else { if ((uVar5 & 0x70) == 0) { fVar6 = (float)(int)*pfVar2; } else { fVar6 = *pfVar2; } iVar7 = 0; if (0 < *piVar3) { do { *pfVar1 = fVar6; iVar7 = iVar7 + 1; pfVar1 = pfVar1 + 1; } while (iVar7 < *piVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_mod.html": {
    "href": "cmd_mod.html",
    "title": "cmd_mod",
    "keywords": "cmd_mod Gets a remainder of a certain value from the another, and stores the result to the first parameter. Code Information Name: cmd_mod Scope: Global PAC Instruction (Binary): 25 00 41 00 Assembly Address in Memory : 0x8837e38 Parameters cmd_mod((int/float *)target, (int/float)value) (Int/Float *)target (8 bytes) : This value is for reading/writing, and will be modified. (Int/Float)value (8 bytes) : Can be variable or immediate value. This value is for reading. This performs target %= value (or target = target % value). value must not be zero. Example Here is one example in hex: 25 00 41 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 0a 00 00 00 Which is interpreted as: cmd_mod((int *)iVar0, (int)10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837e38(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); iVar3 = *piVar2; if (iVar3 != 0) { if (iVar3 == 0) { trap(7); } *piVar1 = *piVar1 % iVar3; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_mov.html": {
    "href": "cmd_mov.html",
    "title": "cmd_mov",
    "keywords": "cmd_mov Assigns value directly without extra calculation. This can assign current value of a variable, or an immediate value. Code Information Name: cmd_mov Scope: Global PAC Instruction (Binary): 25 00 07 00 Assembly Address in Memory : 0x8837c08 Parameters cmd_mov((int/float *)destination, (int/float)value) (Int/Float *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. (Int/Float)value (8 bytes) : Can be variable or constat value. This value will be used for reading only. This performs destination = value. Remarks You can use from int to float and vice versa. In this case, the function will perform type conversion automatically. Example Here is one example in hex: 25 00 07 00 / 08 00 00 00 / 35 00 00 00 / 10 00 00 00 / 00 00 80 bf Which is interpreted as: cmd_mov(((global)int *)giVar53, (float)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837c08(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; uint uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); uVar4 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); if ((uVar3 & 0x70) == 0) { if ((uVar4 & 0x70) == 0) { fVar5 = *pfVar2; } else { fVar5 = (float)(int)*pfVar2; } *pfVar1 = fVar5; } else { if ((uVar4 & 0x70) == 0) { fVar5 = (float)(int)*pfVar2; } else { fVar5 = *pfVar2; } *pfVar1 = fVar5; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_mul.html": {
    "href": "cmd_mul.html",
    "title": "cmd_mul",
    "keywords": "cmd_mul Multiplies a value to the another, and stores the multiplied value to the first parameter. Code Information Name: cmd_mul Scope: Global PAC Instruction (Binary): 25 00 0a 00 Assembly Address in Memory : 0x883800c Parameters cmd_mul((int/float *)target, (int/float)value) (Int/Float *)target (8 bytes) : This value is for reading/writing, and will be modified. (Int/Float)value (8 bytes) : Can be variable or immediate value. This value is for reading. This performs target *= value (or target = target * value). Example Here is one example in hex: 25 00 0a 00 / 20 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 bf Which is interpreted as: cmd_mul((float *)fVar0, (float)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883800c(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; uint uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); uVar4 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); if ((uVar3 & 0x70) == 0) { if ((uVar4 & 0x70) == 0) { fVar5 = *pfVar2; } else { fVar5 = (float)(int)*pfVar2; } *pfVar1 = (float)((int)*pfVar1 * (int)fVar5); } else { if ((uVar4 & 0x70) == 0) { fVar5 = (float)(int)*pfVar2; } else { fVar5 = *pfVar2; } *pfVar1 = *pfVar1 * fVar5; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_print.html": {
    "href": "cmd_print.html",
    "title": "cmd_print",
    "keywords": "cmd_print There are few functions with the same name: cmd_print (25003400) (Global) cmd_print (25090600) (Global)"
  },
  "cmd_print_25003400.html": {
    "href": "cmd_print_25003400.html",
    "title": "cmd_print (25003400)",
    "keywords": "cmd_print (25003400) Other functions have the same name. Check the Disambiguation page to find them. Unimplemented. Code Information Name: cmd_print Scope: Global PAC Instruction (Binary): 25 00 34 00 Assembly Address in Memory : 0x883a5ec Parameters (Undefined)Var0 (8 bytes) (String)Var1 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a5ec(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_StringParam(param_2,auStack256); Pac_Get_Param(param_2,0,1,4); PAC::Pac_Return_ParamAddr(param_2,0); Pac_Get_ParamType(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_print_25090600.html": {
    "href": "cmd_print_25090600.html",
    "title": "cmd_print (25090600)",
    "keywords": "cmd_print (25090600) Other functions have the same name. Check the Disambiguation page to find them. Unimplemented. Code Information Name: cmd_print Scope: Global PAC Instruction (Binary): 25 09 06 00 Assembly Address in Memory : 0x8948c10 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (String)Var2 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948c10(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_Param(param_2,1,1,4); Pac_Get_StringParam(param_2,auStack256); Pac_Get_Param(param_2,0,1,4); PAC::Pac_Return_ParamAddr(param_2,0); Pac_Get_ParamType(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_rand.html": {
    "href": "cmd_rand.html",
    "title": "cmd_rand",
    "keywords": "cmd_rand Returns random value between zero and certain value. Code Information Name: cmd_rand Scope: Global PAC Instruction (Binary): 25 00 11 00 Assembly Address in Memory : 0x88385e0 Parameters cmd_rand((uint)maxExclusive, (uint *)destination) (uint)maxExclusive (8 bytes) : Can be variable or immediate value. This value is for reading. Note that it's Exclusive. (uint *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. This performs destination = Random() % maxExclusive. If you want to make it inclusive, add +1 to the maxExclusive with cmd_inc. Remarks If you want to set min-max, you can follow this: cmd_mov(nVar, max) cmd_sub(nVar, min) cmd_inc(nVar) cmd_rand(nVar) cmd_add(nVar, min) Which means: nVar = max; nVar -= min; nVar++; Random(nVar); nVar += min; nVar here is any variable. In this case, max must be bigger than min. Example Here is one example in hex: 25 00 11 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: cmd_rand((int)3, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088385e0(undefined4 param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; uint uVar3; // (max value+1) puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); // address to store puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if ((int)*puVar1 < 1) { *puVar2 = 0; } else { // certain rng seeds stored here uVar3 = Util::Random::Get_Rand_Value(0x8aab350); if (*puVar1 == 0) { trap(7); } *puVar2 = uVar3 % *puVar1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_rescall.html": {
    "href": "cmd_rescall.html",
    "title": "cmd_resCall",
    "keywords": "cmd_resCall Calls the given address if the \"result\" value is same as given value. The \"result\" value is only used as a condition for jumping(cmd_resJmp) or calling(cmd_resCall) function. Code Information Name: cmd_resCall Scope: Global PAC Instruction (Binary): 25 00 06 00 Assembly Address in Memory : 0x8837b50 Parameters (bool)comparer (8 bytes) : Zero or one to compare with the \"result\". (Address)address (4 bytes) : Address to call if the \"result\" is samd as 1st parameter. This performs if((bool)result == (bool)comparer) { (address *)(); } ... Example Here is one example in hex: 25 00 06 00 / 02 00 00 00 / 01 00 00 00 / 68 f8 04 00 Which is interpreted as: cmd_resCall((int)1, 0x4f868) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837b50(undefined4 param_1,undefined4 param_2) { char cVar1; int *piVar2; undefined4 *puVar3; int iVar4; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,0,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); iVar4 = *piVar2; cVar1 = FUN_0883c028(param_2); if ((iVar4 != 0) == (bool)cVar1) { Set_ReturnContext(param_2); PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_resjmp.html": {
    "href": "cmd_resjmp.html",
    "title": "cmd_resJmp",
    "keywords": "cmd_resJmp Check if the \"result\" value is same as given value. and jumps to the certain address. The \"result\" value is only used as a condition for jumping(cmd_resJmp) or calling(cmd_resCall) function. Code Information Name: cmd_resJmp Scope: Global PAC Instruction (Binary): 25 00 05 00 Assembly Address in Memory : 0x8837aa0 Parameters (bool)comparer (8 bytes) : Zero or one to compare with the \"result\". (Address)address (4 bytes) : Address to jump if the \"result\" is samd as 1st parameter. This performs if((bool)result == (bool)comparer) { goto address; } Example Here is one example in hex: 25 00 05 00 / 02 00 00 00 / 00 00 00 00 / d4 99 00 00 Which is interpreted as: cmd_resJmp((int)0, 0x99d4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837aa0(undefined4 param_1,undefined4 param_2) { char cVar1; int *piVar2; undefined4 *puVar3; int iVar4; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,0,4); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); iVar4 = *piVar2; cVar1 = FUN_0883c028(param_2); if ((iVar4 != 0) == (bool)cVar1) { PAC::Cmd_Jump_Or_Call(param_2,*puVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_result.html": {
    "href": "cmd_result.html",
    "title": "cmd_result",
    "keywords": "cmd_result Assign the given value to the special \"result\" variable. The \"result\" value is only used as a condition for jumping(cmd_resJmp) or calling(cmd_resCall) function. Code Information Name: cmd_result Scope: Global PAC Instruction (Binary): 25 00 04 00 Assembly Address in Memory : 0x8837a38 Parameters (bool)value (8 bytes) : Zero or one, Value to assign to the \"result\" variable. Example Here is one example in hex: 25 00 04 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cmd_result((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837a38(undefined4 param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); Param_Print_Type(param_2,0); Set_Result(param_2,*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_setarray.html": {
    "href": "cmd_setarray.html",
    "title": "cmd_setArray",
    "keywords": "cmd_setArray Sets value to a 4-bytes array. The array must be initialised through cmd_addArray first. Code Information Name: cmd_setArray Scope: Global PAC Instruction (Binary): 25 00 4a 00 Assembly Address in Memory : 0x883b210 Parameters (int)array_index (8 bytes) : Array Index. (Int/Float)array_id (8 bytes) : Array ID, obtained from cmd_initarray. can be int or float. (Int/Float)value (8 bytes) : Value to set to the given index in given array. Array with float ID stores float values and Array with int ID stores int values. Example Here is one example in hex: 25 00 4a 00 / 04 00 00 00 / 00 00 00 00 / 08 00 00 00 / 18 01 00 00 / 10 00 00 00 / 00 00 80 bf Which is interpreted as: cmd_setArray((int *)iVar0, ((global)int *)giVar280, (float)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b210(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; float *pfVar3; uint uVar4; uint uVar5; undefined4 uVar6; float fVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_ParamType(param_2,1); uVar5 = Pac_Get_ParamType(param_2,2); if ((uVar4 & 0x70) == 0) { if ((uVar5 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } uVar6 = Get_Array_BaseAddr(param_2); FUN_089fee38(uVar6,*puVar2,*puVar1,fVar7); } else { if ((uVar5 & 0x70) == 0) { fVar7 = (float)(int)*pfVar3; } else { fVar7 = *pfVar3; } uVar6 = Get_Array_BaseAddr(param_2); FUN_089fee54(fVar7,uVar6,*puVar2,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_setlabelid.html": {
    "href": "cmd_setlabelid.html",
    "title": "cmd_setLabelId",
    "keywords": "cmd_setLabelId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_setLabelId Scope: Global PAC Instruction (Binary): 25 00 3c 00 Assembly Address in Memory : 0x883aaa0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (4 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883aaa0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,0,4); FUN_0883bc54(param_2,*puVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_setsleep.html": {
    "href": "cmd_setsleep.html",
    "title": "cmd_setSleep",
    "keywords": "cmd_setSleep Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_setSleep Scope: Global PAC Instruction (Binary): 25 00 36 00 Assembly Address in Memory : 0x883a69c Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 00 36 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cmd_setSleep((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a69c(undefined4 param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); FUN_0883bbc0(param_2,*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_sinf.html": {
    "href": "cmd_sinf.html",
    "title": "cmd_sinf",
    "keywords": "cmd_sinf Applies sine function to the value and stores the result as float. Code Information Name: cmd_sinf Scope: Global PAC Instruction (Binary): 25 00 37 00 Assembly Address in Memory : 0x883a6ec Parameters cmd_sqrt((int/float)value, (float *)destination) (Int/Float)value (8 bytes) : Can be variable or constat value. This value will be used for reading only. (Float *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. This performs destination = Math.Sin(value). Example Here is one example in hex: 25 00 37 00 / 20 00 00 00 / 0c 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: cmd_sinf((float *)fVar12, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a6ec(undefined4 param_1,undefined4 param_2) { float *pfVar1; undefined4 *puVar2; uint uVar3; undefined4 uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); if ((uVar3 & 0x70) == 0) { fVar5 = (float)(int)*pfVar1; } else { fVar5 = *pfVar1; } uVar4 = syscall::sinf((fVar5 * 2.0 * 3.141593) / 360.0); *puVar2 = uVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_sqrt.html": {
    "href": "cmd_sqrt.html",
    "title": "cmd_sqrt",
    "keywords": "cmd_sqrt Gets square root of the value and stores the result as float. Code Information Name: cmd_sqrt Scope: Global PAC Instruction (Binary): 25 00 3b 00 Assembly Address in Memory : 0x883aa04 Parameters cmd_sqrt((float/int)value, (float *)destination) (Float/Int)value (8 bytes) : Can be variable or constat value. This value will be used for reading only. (Float *)destination (8 bytes) : Variable to store value. This value will be uesd for writing only and will be modified. This performs destination = Math.Sqrt(value). Example Here is one example in hex: 25 00 3b 00 / 20 00 00 00 / 07 00 00 00 / 20 00 00 00 / 03 00 00 00 Which is interpreted as: cmd_sqrt((float *)fVar7, (float *)fVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883aa04(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; float fVar4; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); if ((uVar3 & 0x70) == 0) { fVar4 = (float)(int)*pfVar1; } else { fVar4 = *pfVar1; } *pfVar2 = SQRT(fVar4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_srand.html": {
    "href": "cmd_srand.html",
    "title": "cmd_srand",
    "keywords": "cmd_srand Inititalises the random table. When the game gets random value (like cmd_rand or from hardcoded Assembly code), the game gets the value from random table. The random table is usually resetted between scenes, e.g. while opening the game, going to the hideout or loading a mission. The random table uses current system time as seed. Though, it seems like that the cmd_srand is not used anywhere in Patapon 3. Code Information Name: cmd_srand Scope: Global PAC Instruction (Binary): 25 00 47 00 Assembly Address in Memory : 0x883b104 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b104(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; uVar1 = syscall::Time::sceKernelGetSystemTimeLow(); Util::Random::Init_Rand_Seeds(0x8aab350,uVar1); DAT_08aabd14 = 1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_stkclr.html": {
    "href": "cmd_stkclr.html",
    "title": "cmd_stkClr",
    "keywords": "cmd_stkClr Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_stkClr Scope: Global PAC Instruction (Binary): 25 00 31 00 Assembly Address in Memory : 0x883a524 Parameters This function is parameterless. Example Here is one example in hex: 25 00 31 00 Which is interpreted as: cmd_stkClr() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a524(undefined4 param_1,undefined4 param_2) { FUN_0883ca68(param_2,0); FUN_0883bebc(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_stkdec.html": {
    "href": "cmd_stkdec.html",
    "title": "cmd_stkDec",
    "keywords": "cmd_stkDec Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_stkDec Scope: Global PAC Instruction (Binary): 25 00 30 00 Assembly Address in Memory : 0x883a4c4 Parameters This function is parameterless. Example Here is one example in hex: 25 00 30 00 Which is interpreted as: cmd_stkDec() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a4c4(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = FUN_0883be98(param_2); if (iVar1 == 0) { iVar1 = FUN_0883ca60(param_2); FUN_0883ca68(param_2,iVar1 + -1); } else { FUN_0883bee0(param_2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_string.html": {
    "href": "cmd_string.html",
    "title": "cmd_string",
    "keywords": "cmd_string There are few functions with the same name: cmd_string (25003300) (Global) cmd_string (25090500) (Global)"
  },
  "cmd_string_25003300.html": {
    "href": "cmd_string_25003300.html",
    "title": "cmd_string (25003300)",
    "keywords": "cmd_string (25003300) Other functions have the same name. Check the Disambiguation page to find them. This function does nothing. Code Information Name: cmd_string Scope: Global PAC Instruction (Binary): 25 00 33 00 Assembly Address in Memory : 0x883a5b4 Parameters (String)Var0 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a5b4(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_StringParam(param_2,auStack256); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_string_25090500.html": {
    "href": "cmd_string_25090500.html",
    "title": "cmd_string (25090500)",
    "keywords": "cmd_string (25090500) Other functions have the same name. Check the Disambiguation page to find them. This function does nothing. Code Information Name: cmd_string Scope: Global PAC Instruction (Binary): 25 09 05 00 Assembly Address in Memory : 0x8948bc4 Parameters (Undefined)Var0 (8 bytes) (String)Var1 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948bc4(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_Param(param_2,0,1,4); Pac_Get_StringParam(param_2,auStack256); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_stringenable.html": {
    "href": "cmd_stringenable.html",
    "title": "cmd_stringEnable",
    "keywords": "cmd_stringEnable Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_stringEnable Scope: Global PAC Instruction (Binary): 25 00 46 00 Assembly Address in Memory : 0x883b0b0 Parameters (int)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883b0b0(undefined4 param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); DAT_08a6df0c = *piVar1 == 1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_sub.html": {
    "href": "cmd_sub.html",
    "title": "cmd_sub",
    "keywords": "cmd_sub Subtracts a value from the another, and stores the subtracted value to the first parameter. Code Information Name: cmd_sub Scope: Global PAC Instruction (Binary): 25 00 09 00 Assembly Address in Memory : 0x8837eec Parameters cmd_sub((int/float *)target, (int/float)value) (Int/Float *)target (8 bytes) : This value is for reading/writing, and will be modified. (Int/Float)value (8 bytes) : Can be variable or value. This value is for reading. This performs target -= value (or target = target - value). Example Here is one example in hex: 25 00 09 00 / 20 00 00 00 / 0c 00 00 00 / 10 00 00 00 / 00 00 a0 40 Which is interpreted as: cmd_sub((float *)fVar12, (float)5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08837eec(undefined4 param_1,undefined4 param_2) { float *pfVar1; float *pfVar2; uint uVar3; uint uVar4; float fVar5; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_ParamType(param_2,0); uVar4 = Pac_Get_ParamType(param_2,1); Param_Print_Type(param_2,0); Param_Print_Type(param_2,1); if ((uVar3 & 0x70) == 0) { if ((uVar4 & 0x70) == 0) { fVar5 = *pfVar2; } else { fVar5 = (float)(int)*pfVar2; } *pfVar1 = (float)((int)*pfVar1 - (int)fVar5); } else { if ((uVar4 & 0x70) == 0) { fVar5 = (float)(int)*pfVar2; } else { fVar5 = *pfVar2; } *pfVar1 = *pfVar1 - fVar5; } Param_Print_Type(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_textout.html": {
    "href": "cmd_textout.html",
    "title": "cmd_textOut",
    "keywords": "cmd_textOut Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmd_textOut Scope: Global PAC Instruction (Binary): 25 00 35 00 Assembly Address in Memory : 0x883a650 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0883a650(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_0883bf24(param_2,*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmd_waitframe.html": {
    "href": "cmd_waitframe.html",
    "title": "cmd_waitFrame",
    "keywords": "cmd_waitFrame Wait for a frame before executing the next instruction. Used by e.g. Screen fading. This pauses pac instruction execution until the next frame. Code Information Name: cmd_waitFrame Scope: Global PAC Instruction (Binary): 25 00 0f 00 Assembly Address in Memory : 0x8838434 Parameters (Int)frames_to_wait (8 bytes) : Amount of frame to wait. Usually it is 1. Example Here is one example in hex: 25 00 0f 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: cmd_waitFrame((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08838434(undefined4 param_1,undefined4 param_2) { int iVar1; undefined4 *puVar2; iVar1 = Get_Execution_Pause_Phase(param_2); if (iVar1 == 0) { puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); Set_FrameTime_Counter(param_2,*puVar2); Pause_Execution(param_2,1); } iVar1 = Get_FrameTime_Counter(param_2); if (iVar1 < 1) { Set_FrameTime_Counter(param_2,0); PAC::PAC_setCmdId(param_2,0); } else { iVar1 = Get_FrameTime_Counter(param_2); Set_FrameTime_Counter(param_2,iVar1 + -1); } return; }"
  },
  "cmd_waittime.html": {
    "href": "cmd_waittime.html",
    "title": "cmd_waitTime",
    "keywords": "cmd_waitTime Wait for certain time before executing the next instruction. This pauses pac instruction execution for the given time. Code Information Name: cmd_waitTime Scope: Global PAC Instruction (Binary): 25 00 10 00 Assembly Address in Memory : 0x88384e0 Parameters (float)waiting_time (8 bytes) : Time as second to wait before executing the next instruction. Example Here is one example in hex: 25 00 10 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: cmd_waitTime((float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_088384e0(undefined4 param_1,undefined4 param_2) { int iVar1; float *pfVar2; uint uVar3; int iVar4; float fVar5; iVar1 = Get_Execution_Pause_Phase(param_2); if (iVar1 == 0) { pfVar2 = (float *)Pac_Get_Param(param_2,0,1,4); uVar3 = FUN_0883bbcc(param_2); if ((int)uVar3 < 0) { fVar5 = (float)(uVar3 >> 1 | uVar3 & 1); fVar5 = fVar5 + fVar5; } else { fVar5 = (float)uVar3; } Set_Remaining_Time(param_2,(int)(*pfVar2 * fVar5)); Pause_Execution(param_2,1); } iVar1 = Get_Remaining_Time(param_2); if (iVar1 < 1) { Set_Remaining_Time(param_2,0); PAC::PAC_setCmdId(param_2,0); } else { iVar1 = Get_Time_Between(param_2); iVar4 = Get_Remaining_Time(param_2); Set_Remaining_Time(param_2,iVar4 - iVar1); } return; }"
  },
  "cmdappearmissiledeadunitcnt.html": {
    "href": "cmdappearmissiledeadunitcnt.html",
    "title": "cmdAppearMissileDeadUnitCnt",
    "keywords": "cmdAppearMissileDeadUnitCnt Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmdAppearMissileDeadUnitCnt Scope: Global PAC Instruction (Binary): 25 16 3b 01 Assembly Address in Memory : 0x892ae4c Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) Example Here is one example in hex: 25 16 3b 01 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: cmdAppearMissileDeadUnitCnt((int)0, (int)0, (int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892ae4c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; int *piVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar5 != 0)) && (iVar5 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar5 + 0x2c) + 0x54),*puVar1), iVar5 != 0)) { if (*piVar2 == 1) { if (*piVar3 == 0) { *(short *)(iVar5 + 0x9e) = (short)*piVar4; } else { *(short *)(iVar5 + 0x9c) = (short)*piVar4; } } else if (*piVar2 == 0) { if (*piVar3 == 0) { *piVar4 = (int)*(short *)(iVar5 + 0x9e); } else { *piVar4 = (int)*(short *)(iVar5 + 0x9c); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "cmdappearmissilepoint.html": {
    "href": "cmdappearmissilepoint.html",
    "title": "cmdAppearMissilePoint",
    "keywords": "cmdAppearMissilePoint Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: cmdAppearMissilePoint Scope: Global PAC Instruction (Binary): 25 16 3a 01 Assembly Address in Memory : 0x892ad0c Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (int)Var3 (8 bytes) Example Here is one example in hex: 25 16 3a 01 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 40 00 00 00 / 33 00 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: cmdAppearMissilePoint((int)0, (int)0, ((global)float *)gfVar51, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892ad0c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; int *piVar4; int iVar5; int iVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar5 != 0)) && (iVar5 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar5 + 0x2c) + 0x54),*puVar1), iVar5 != 0)) { iVar6 = *piVar2; if (iVar6 == 2) { FUN_08a4e658(*puVar3,iVar5); } else if (iVar6 == 1) { FUN_08a4e584(*puVar3,iVar5,*piVar4); } else if (iVar6 == 0) { *puVar3 = *(undefined4 *)(iVar5 + 0xa8); *piVar4 = (int)*(short *)(iVar5 + 0x98); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "colorkeywordadd.html": {
    "href": "colorkeywordadd.html",
    "title": "colorKeywordAdd",
    "keywords": "colorKeywordAdd Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: colorKeywordAdd Scope: Global PAC Instruction (Binary): 25 03 0b 00 Assembly Address in Memory : 0x892d588 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (int)Var5 (4 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892d588(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int *piVar6; int iVar7; undefined4 uVar8; int iVar9; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,0,4); iVar9 = *piVar6; iVar7 = FUN_0883bc1c(param_2); Message::Write_Value_Final(param_1 + 0x34,0x200,iVar7 + iVar9); uVar8 = FUN_08871508(); iVar7 = FUN_088715ac(uVar8); FUN_08992bcc(iVar7 + 0x34528,*puVar1,*puVar2,*puVar3,*puVar4,*puVar5,param_1 + 0x34); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "colorkeywordclear.html": {
    "href": "colorkeywordclear.html",
    "title": "colorKeywordClear",
    "keywords": "colorKeywordClear Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: colorKeywordClear Scope: Global PAC Instruction (Binary): 25 03 0a 00 Assembly Address in Memory : 0x892d540 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892d540(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = FUN_08871508(); iVar2 = FUN_088715ac(uVar1); FUN_08992b68(iVar2 + 0x34528); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "colorkeyworddis.html": {
    "href": "colorkeyworddis.html",
    "title": "colorKeywordDis",
    "keywords": "colorKeywordDis Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: colorKeywordDis Scope: Global PAC Instruction (Binary): 25 03 0c 00 Assembly Address in Memory : 0x892d6d0 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892d6d0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; undefined4 uVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar2; iVar3 = FUN_0883bc1c(param_2); Message::Write_Value_Final(param_1 + 0x34,0x200,iVar3 + iVar5); uVar4 = FUN_08871508(); iVar3 = FUN_088715ac(uVar4); FUN_089930b8(iVar3 + 0x34528,*puVar1,param_1 + 0x34); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "create.html": {
    "href": "create.html",
    "title": "create",
    "keywords": "create Creates an empty generator. After this, objects such as units are placed here, through e.g. setReqActorType. More information on How To: Create on Enemy Target. Code Information Name: create Scope: Mission PAC Instruction (Binary): 25 1f 02 00 Assembly Address in Memory : 0x8b5bdf0 Parameters (int *)generator_handle (8 bytes) : Variable to store the generator handle. (int)generator_identifier (8 bytes) : Identifier of the generator, to obtain the handle later. The generator_size can be 1 or 1000, depends on the action. Remarks For some setups e.g. setting different level or death callback to only one object, different generator is required. In this case, the generator size can be 1. Example Here is one example in hex: 25 1f 02 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / e8 03 00 00 Which is interpreted as: create(((global)int *)giVar26, (int)1000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5bdf0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0x2c8); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { uVar3 = FUN_Mission__08b5aa18(iVar4,*puVar2); *puVar1 = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "createScript.html": {
    "href": "createScript.html",
    "title": "createScript",
    "keywords": "createScript There are few functions with the same name: createScript (25100800) (Global) createScript (25120a00) (Global)"
  },
  "createchangemodel.html": {
    "href": "createchangemodel.html",
    "title": "createChangeModel",
    "keywords": "createChangeModel Adds a model to a unit. changeModel is required after this for applying the model. Code Information Name: createChangeModel Scope: Global PAC Instruction (Binary): 25 16 56 00 Assembly Address in Memory : 0x891f7ec Parameters (int *)handle_id (8 bytes) : Variable to store the unit handle. (String)model_name : The name of the model to change. Example Here is one example in hex: 25 16 56 00 / 04 00 00 00 / 0c 00 00 00 / 63 68 72 30 / 32 5f 30 33 / 5f 30 30 32 / 00 00 00 00 Which is interpreted as: createChangeModel((int *)iVar12, \"chr02_03_002\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891f7ec(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined *puVar3; int iVar4; int iVar5; undefined *puVar6; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = &DAT_00000100; puVar6 = local_100; puVar1 = puVar6; while (puVar1 != (undefined *)0x0) { *puVar6 = 0; puVar6 = puVar6 + 1; puVar3 = puVar3 + -1; puVar1 = puVar3; } Pac_Get_StringParam(param_2,local_100); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 9)) { FUN_088b9d44(iVar4,0); FUN_088b9cf8(iVar4,local_100); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "createscript_25100800.html": {
    "href": "createscript_25100800.html",
    "title": "createScript (25100800)",
    "keywords": "createScript (25100800) Other functions have the same name. Check the Disambiguation page to find them. Creates new PAC instruction. Unlike cmd_call, this doesn't block the current instruction flow. Code Information Name: createScript Scope: Global PAC Instruction (Binary): 25 10 08 00 Assembly Address in Memory : 0x890a044 Parameters (MemoryAddress)pac_address_in_memory (8 bytes) : Obtained from getPack. The memory address where the whole PAC instructions start. (Address)address (8 bytes) : Address in the PAC file as int to execute. (int)script_id (8 bytes) : Script ID to set, can be used as reference to killScript. (undefined4)Var3 (8 bytes) : Keep 0. (undefined4)Var4 (8 bytes) : Keep 0. (int)Var5 (8 bytes) : Can be pointer to save something, but can be ignored by keeping 0. Example Here is one example in hex: 25 10 08 00 / 08 00 00 00 / 5b 00 00 00 / 08 00 00 00 / 5c 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: createScript(((global)int *)giVar91, ((global)int *)giVar92, (int)1, (int)0, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a044(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; undefined4 *puVar4; undefined4 *puVar5; int **ppiVar6; uint uVar7; int iVar8; int *piVar9; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); ppiVar6 = (int **)Pac_Get_Param(param_2,5,1,4); uVar7 = Pac_Get_ParamType(param_2,5); if (((*(int *)(param_1 + 0x10) != 0) && (piVar9 = *(int **)(*(int *)(param_1 + 0x10) + 0x4dc), piVar9 != (int *)0x0)) && (piVar9 = (int *)(**(code **)(*piVar9 + 0xc))(piVar9,*puVar1,*puVar2,1,0,*puVar4,*puVar5), piVar9 != (int *)0x0)) { piVar9[0x13f] = *piVar3; iVar8 = FUN_08909cf0(*(undefined4 *)(param_1 + 0x10)); piVar9[0x138] = iVar8; (**(code **)(*piVar9 + 0x10))(piVar9,1); if ((uVar7 & 0xc) != 0) { *ppiVar6 = piVar9; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "createscript_25120a00.html": {
    "href": "createscript_25120a00.html",
    "title": "createScript (25120a00)",
    "keywords": "createScript (25120a00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: createScript Scope: Global PAC Instruction (Binary): 25 12 0a 00 Assembly Address in Memory : 0x8a1d404 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d404(int param_1,int param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int *piVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (piVar5 = *(int **)(*(int *)(param_1 + 0x10) + 0x378), piVar5 = (int *)(**(code **)(*piVar5 + 0xc))(piVar5,*puVar1,*puVar2,1,0,*puVar3,*puVar4), piVar5 != (int *)0x0)) { (**(code **)(*piVar5 + 0x10))(piVar5,1); piVar5[0x138] = param_2; piVar5[0x13f] = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "createwindow.html": {
    "href": "createwindow.html",
    "title": "createWindow",
    "keywords": "createWindow Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: createWindow Scope: Global PAC Instruction (Binary): 25 03 03 00 Assembly Address in Memory : 0x892bbcc Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892bbcc(undefined4 param_1,undefined4 param_2) { PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "deadexit.html": {
    "href": "deadexit.html",
    "title": "deadExit",
    "keywords": "deadExit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: deadExit Scope: Global PAC Instruction (Binary): 25 21 23 00 Assembly Address in Memory : 0x89b36a4 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b36a4(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { FUN_0897555c(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "debugsoundpan.html": {
    "href": "debugsoundpan.html",
    "title": "debugSoundPan",
    "keywords": "debugSoundPan Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: debugSoundPan Scope: Global PAC Instruction (Binary): 25 0a 38 00 Assembly Address in Memory : 0x894cdd8 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 0a 38 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: debugSoundPan((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cdd8(undefined4 param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); DAT_08ab9438 = *piVar1 != 0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "decidedbossaction.html": {
    "href": "decidedbossaction.html",
    "title": "decidedBossAction",
    "keywords": "decidedBossAction Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: decidedBossAction Scope: Global PAC Instruction (Binary): 25 21 02 00 Assembly Address in Memory : 0x89b1364 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1364(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x29c) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "decitem.html": {
    "href": "decitem.html",
    "title": "decItem",
    "keywords": "decItem Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: decItem Scope: Global PAC Instruction (Binary): 25 16 62 00 Assembly Address in Memory : 0x89202f0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 62 00 / 02 00 00 00 / 31 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: decItem((int)49, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089202f0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); FUN_0896550c(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 100),*puVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "del.html": {
    "href": "del.html",
    "title": "del",
    "keywords": "del Deletes any target by given handle. Code Information Name: del Scope: Global PAC Instruction (Binary): 25 17 28 00 Assembly Address in Memory : 0x89134b4 Parameters (int *)handle (8 bytes) : target handle to delete. (bool)Var1 (8 bytes) Example Here is one example in hex: 25 17 28 00 / 04 00 00 00 / 18 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: del((int *)iVar24, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089134b4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (iVar5 = *(int *)(iVar3 + 0xcc), iVar5 != 0)) { iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); if (iVar4 == 0xb) { //effect (**(code **)(*(int *)(iVar3 + 4) + 0x88))(*puVar2,0,iVar3); } else if (iVar4 == 10) { //gimmick (**(code **)(*(int *)(iVar3 + 4) + 0x8c))(*puVar2,0,iVar3); } else if (iVar4 == 9) { //unit (**(code **)(*(int *)(iVar3 + 4) + 0x8c))(*puVar2,0,iVar3); } else { FUN_088984d4(iVar5); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "disableequipbigshield.html": {
    "href": "disableequipbigshield.html",
    "title": "disableEquipBigShield",
    "keywords": "disableEquipBigShield Disarms the greatshield, if the target unit has it. Used in ending cutscene (ascending with drum). Code Information Name: disableEquipBigShield Scope: Global PAC Instruction (Binary): 25 16 42 01 Assembly Address in Memory : 0x892b34c Parameters (int *)unit_handle (8 bytes) : Handle of the unit to disarm the greatshield. Example Here is one example in hex: 25 16 42 01 / 08 00 00 00 / ca 00 00 00 Which is interpreted as: disableEquipBigShield(((global)int *)giVar202) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892b34c(int param_1,undefined4 param_2) { short sVar1; undefined4 *puVar2; int iVar3; int iVar4; undefined4 uVar5; int iVar6; int iVar7; int iVar8; int iVar9; int *piVar10; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) && (iVar3 != 0)) { iVar8 = 0; iVar4 = iVar3; do { iVar7 = 0; iVar9 = iVar4; do { if (iVar8 < 8) { if (iVar7 < 3) { piVar10 = *(int **)(iVar9 + 0x8d4); } else { piVar10 = (int *)0x0; } } else { piVar10 = (int *)0x0; } if (piVar10 != (int *)0x0) { sVar1 = (**(code **)(*piVar10 + 0x24))(piVar10); uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); uVar5 = Param::Get_Data_Addr(*(undefined4 *)(iVar6 + 0xa4),9); iVar6 = Param::Get_Line_Addr(uVar5,0,(int)sVar1,1); if ((iVar6 != 0) && (sVar1 = *(short *)(iVar6 + 6), -1 < sVar1)) { uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); uVar5 = Param::Get_Data_Addr(*(undefined4 *)(iVar6 + 0xa4),0x1c); iVar6 = Param::Get_Line_Addr(uVar5,0,(int)sVar1,1); if ((iVar6 != 0) && ((*(char *)(iVar6 + 8) == '\\x03' && (*(char *)(iVar6 + 9) == '\\x1a')))) { FUN_088bb784(iVar3,piVar10); } } } iVar7 = iVar7 + 1; iVar9 = iVar9 + 4; } while (iVar7 < 3); iVar8 = iVar8 + 1; iVar4 = iVar4 + 0xc; } while (iVar8 < 8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "disablekilltimer.html": {
    "href": "disablekilltimer.html",
    "title": "disableKillTimer",
    "keywords": "disableKillTimer Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: disableKillTimer Scope: Global PAC Instruction (Binary): 25 17 25 00 Assembly Address in Memory : 0x89132a8 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 17 25 00 / 04 00 00 00 / 32 00 00 00 Which is interpreted as: disableKillTimer((int *)iVar50) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089132a8(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); if (*piVar1 != -1) { iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar2 == 0) { iVar2 = 0; } if (iVar2 != 0) { (**(code **)(*(int *)(iVar2 + 4) + 0x84))(iVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "disableretirebox.html": {
    "href": "disableretirebox.html",
    "title": "disableRetireBox",
    "keywords": "disableRetireBox Disables retiring during the mission. Used in tutorial. Please consider not using this. Code Information Name: disableRetireBox Scope: Global PAC Instruction (Binary): 25 16 60 00 Assembly Address in Memory : 0x89200ec Parameters (bool)disable_retire (8 bytes) : 1 blocks from opening the retire box. 0 allows to retire during the mission. Example Here is one example in hex: 25 16 60 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: disableRetireBox((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089200ec(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); func_0x08b550b0(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x4c),*piVar1 == 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "dispsetversusstring.html": {
    "href": "dispsetversusstring.html",
    "title": "dispSetVersusString",
    "keywords": "dispSetVersusString Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: dispSetVersusString Scope: Global PAC Instruction (Binary): 25 16 f7 00 Assembly Address in Memory : 0x8927510 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927510(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; int *piVar4; undefined4 *puVar5; int iVar6; undefined4 uVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); uVar7 = *(undefined4 *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x68); if (*piVar1 == 2) { iVar6 = func_0x08b36458(uVar7); } else if (*piVar1 == 1) { iVar6 = func_0x08b36460(uVar7,*puVar2); } else { iVar6 = func_0x08b36450(); } if (iVar6 != 0) { if (*piVar3 == 1) { if (*piVar1 != 2) { func_0x08b360f0(*puVar5,iVar6,*piVar4); } } else { func_0x08b360e8(iVar6,*piVar4 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "doselect.html": {
    "href": "doselect.html",
    "title": "doSelect",
    "keywords": "doSelect This comes end of the debug menu, following the setChoices. Code Information Name: doSelect Scope: Global PAC Instruction (Binary): 25 03 02 00 Assembly Address in Memory : 0x892cb68 Parameters (Address)close_callback (4 bytes) : Address to call when the debug is being closed. Usually expected to redirect to cmd_end only. (int)iVar0 (4 bytes) : Expected to be 1. Example Here is one example in hex: 25 03 02 00 / dc d7 02 00 / 01 00 00 00 Which is interpreted as: doSelect(0x2d7dc, 0x1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892cb68(int param_1,undefined4 param_2) { bool bVar1; short sVar2; int iVar3; int *piVar4; int *piVar5; undefined4 *puVar6; int iVar7; undefined4 *puVar8; int iVar9; undefined4 uVar10; int iVar11; int iVar12; undefined4 local_20; int *local_1c; int local_18; short *local_14; undefined4 local_10; int *local_c; int local_8; short *local_4; iVar3 = Get_Execution_Pause_Phase(param_2); if (iVar3 == 0) { piVar4 = (int *)Pac_Get_Param(param_2,0,0,4); piVar5 = (int *)Pac_Get_Param(param_2,1,0,4); iVar7 = *piVar4; *(int *)(param_1 + 0x30) = iVar7; iVar3 = *piVar5; iVar11 = *(int *)(param_1 + 0x10); if (*(int *)(iVar11 + 0x798) == 0) { bVar1 = false; } else { piVar4 = (int *)(iVar11 + 0x7a4); FUN_0885da7c(*(undefined4 *)(iVar11 + 0x7a4),iVar11 + 0x7ac); FUN_0885d70c(*piVar4); iVar9 = *(int *)(iVar11 + 0x794); iVar12 = iVar9 + *(int *)(iVar11 + 0x798) * 0x30; if (iVar9 == iVar12) { iVar11 = *piVar4; } else { uVar10 = *(undefined4 *)(iVar11 + 0x7a4); while( true ) { FUN_0885d8ec(uVar10,*(undefined4 *)(iVar9 + 4),*(undefined4 *)(iVar9 + 8),iVar9, iVar9 + 0xc); iVar9 = iVar9 + 0x30; if (iVar9 == iVar12) break; uVar10 = *(undefined4 *)(iVar11 + 0x7a4); } iVar11 = *piVar4; } *(undefined *)(iVar11 + 0x931) = 0; *(undefined *)(iVar11 + 0x932) = 0; *(undefined *)(iVar11 + 0x930) = 0; *(bool *)(iVar11 + 0x933) = iVar7 != 0; FUN_0885c4f4(iVar11,-(uint)(iVar3 == 0)); bVar1 = true; } if (!bVar1) { FUN_0885c34c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x7a4)); PAC::PAC_setCmdId(param_2,0); return; } FUN_0892d014(&local_10,*(undefined4 *)(param_1 + 0x10)); *(undefined *)(local_8 + 0x8e8) = 0; if (local_8 == 0) { uVar10 = *(undefined4 *)(param_1 + 0x10); } else { *local_4 = *local_4 + -1; if (local_4 == (short *)0x0) { sVar2 = 0; } else { sVar2 = *local_4; } if (sVar2 == 0) { (**(code **)(*local_c + 0xc))(local_c,local_8,local_4,local_10); FUN_0892e358(local_8,local_10); } uVar10 = *(undefined4 *)(param_1 + 0x10); } FUN_0892d014(&local_20,uVar10); *(undefined *)(local_18 + 0x9c2) = 1; *(undefined *)(local_18 + 0x9c9) = 0; if (local_18 == 0) { iVar3 = *(int *)(param_1 + 0x10); } else { *local_14 = *local_14 + -1; if (local_14 == (short *)0x0) { sVar2 = 0; } else { sVar2 = *local_14; } if (sVar2 == 0) { (**(code **)(*local_1c + 0xc))(local_1c,local_18,local_14,local_20); FUN_0892e358(local_18,local_20); } iVar3 = *(int *)(param_1 + 0x10); } iVar3 = *(int *)(iVar3 + 0x7a4); if (_DAT_08aabdd4 == iVar3) { *(undefined *)(iVar3 + 0x931) = 0; } else { *(int *)(iVar3 + 0x9b4) = _DAT_08aabdd4; _DAT_08aabdd4 = iVar3; *(undefined *)(iVar3 + 0x931) = 0; } *(undefined *)(iVar3 + 0x932) = 0; *(undefined *)(iVar3 + 0x930) = 0; Pause_Execution(param_2,1); puVar8 = *(undefined4 **)(param_1 + 0x10); } else { puVar8 = *(undefined4 **)(param_1 + 0x10); } iVar3 = puVar8[0x1e9]; if (*(char *)(iVar3 + 0x931) == '\\0') { return; } if (*(char *)(iVar3 + 0x932) == '\\0' || *(char *)(iVar3 + 0x931) == '\\0') { if (*(char *)(iVar3 + 0x931) == '\\0') { puVar6 = (undefined4 *)0x0; } else if (*(int *)(iVar3 + 0x8f0) < 0) { puVar6 = (undefined4 *)0x0; } else { puVar6 = (undefined4 *)(puVar8[0x1e5] + *(int *)(iVar3 + 0x8f0) * 0x30); } uVar10 = *puVar6; } else { uVar10 = *(undefined4 *)(param_1 + 0x30); } iVar3 = puVar8[0x1e9]; if (*(int *)(iVar3 + 0x9b4) == 0) { bVar1 = _DAT_08aabdd4 == iVar3; if (bVar1) { bVar1 = *(char *)(iVar3 + 0x931) == '\\0'; } if (!bVar1) { iVar3 = puVar8[0x1e6]; goto LAB_0892cea0; } _DAT_08aabdd4 = 0; } else { _DAT_08aabdd4 = *(int *)(iVar3 + 0x9b4); *(undefined4 *)(iVar3 + 0x9b4) = 0; } iVar3 = puVar8[0x1e6]; LAB_0892cea0: iVar7 = puVar8[0x1e5]; if (iVar7 != iVar7 + iVar3 * 0x30) { do { iVar7 = iVar7 + 0x30; } while (iVar7 != puVar8[0x1e5] + iVar3 * 0x30); } puVar8[0x1e6] = 0; if (puVar8[0x1e9] != 0) { FUN_0885d70c(puVar8[0x1e9]); } Syscall::Kernel::Kernel_Memset(puVar8 + 1,0,0x300); *puVar8 = 0; FUN_0885c34c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x7a4)); PAC::Cmd_Jump_Or_Call(param_2,uVar10,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "doselectcursor.html": {
    "href": "doselectcursor.html",
    "title": "doSelectCursor",
    "keywords": "doSelectCursor Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: doSelectCursor Scope: Global PAC Instruction (Binary): 25 03 08 00 Assembly Address in Memory : 0x892d058 Parameters (undefined4)Var0 (4 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 03 08 00 / 0c 22 05 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: doSelectCursor(0x5220c, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892d058(int param_1,undefined4 param_2) { bool bVar1; short sVar2; int iVar3; int *piVar4; undefined4 *puVar5; int iVar6; int iVar7; undefined4 uVar8; int iVar9; int iVar10; undefined4 local_20; int *local_1c; int local_18; short *local_14; undefined4 local_10; int *local_c; int local_8; short *local_4; iVar3 = Get_Execution_Pause_Phase(param_2); if (iVar3 == 0) { puVar5 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); piVar4 = (int *)Pac_Get_Param(param_2,1,1,4); *(undefined4 *)(param_1 + 0x30) = *puVar5; *(int **)(param_1 + 0x240) = piVar4; iVar6 = *piVar4; iVar3 = 0; if ((iVar6 < 0) || (iVar3 = iVar6, iVar6 < *(int *)(*(int *)(param_1 + 0x10) + 0x798))) { iVar6 = *(int *)(param_1 + 0x30); } else { iVar6 = *(int *)(param_1 + 0x30); iVar3 = 0; } iVar9 = *(int *)(param_1 + 0x10); if (*(int *)(iVar9 + 0x798) == 0) { bVar1 = false; } else { piVar4 = (int *)(iVar9 + 0x7a4); FUN_0885da7c(*(undefined4 *)(iVar9 + 0x7a4),iVar9 + 0x7ac); FUN_0885d70c(*piVar4); iVar7 = *(int *)(iVar9 + 0x794); iVar10 = iVar7 + *(int *)(iVar9 + 0x798) * 0x30; if (iVar7 == iVar10) { iVar9 = *piVar4; } else { uVar8 = *(undefined4 *)(iVar9 + 0x7a4); while( true ) { FUN_0885d8ec(uVar8,*(undefined4 *)(iVar7 + 4),*(undefined4 *)(iVar7 + 8),iVar7,iVar7 + 0xc ); iVar7 = iVar7 + 0x30; if (iVar7 == iVar10) break; uVar8 = *(undefined4 *)(iVar9 + 0x7a4); } iVar9 = *piVar4; } *(undefined *)(iVar9 + 0x931) = 0; *(undefined *)(iVar9 + 0x932) = 0; *(undefined *)(iVar9 + 0x930) = 0; *(bool *)(iVar9 + 0x933) = iVar6 != 0; FUN_0885c4f4(iVar9,iVar3); bVar1 = true; } if (!bVar1) { FUN_0885c34c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x7a4)); PAC::PAC_setCmdId(param_2,0); return; } FUN_0892d014(&local_10,*(undefined4 *)(param_1 + 0x10)); *(undefined *)(local_8 + 0x8e8) = 0; if (local_8 == 0) { uVar8 = *(undefined4 *)(param_1 + 0x10); } else { *local_4 = *local_4 + -1; if (local_4 == (short *)0x0) { sVar2 = 0; } else { sVar2 = *local_4; } if (sVar2 == 0) { (**(code **)(*local_c + 0xc))(local_c,local_8,local_4,local_10); FUN_0892e358(local_8,local_10); } uVar8 = *(undefined4 *)(param_1 + 0x10); } FUN_0892d014(&local_20,uVar8); *(undefined *)(local_18 + 0x9c2) = 1; *(undefined *)(local_18 + 0x9c9) = 0; if (local_18 == 0) { iVar3 = *(int *)(param_1 + 0x10); } else { *local_14 = *local_14 + -1; if (local_14 == (short *)0x0) { sVar2 = 0; } else { sVar2 = *local_14; } if (sVar2 == 0) { (**(code **)(*local_1c + 0xc))(local_1c,local_18,local_14,local_20); FUN_0892e358(local_18,local_20); } iVar3 = *(int *)(param_1 + 0x10); } iVar3 = *(int *)(iVar3 + 0x7a4); if (_DAT_08aabdd4 == iVar3) { *(undefined *)(iVar3 + 0x931) = 0; } else { *(int *)(iVar3 + 0x9b4) = _DAT_08aabdd4; _DAT_08aabdd4 = iVar3; *(undefined *)(iVar3 + 0x931) = 0; } *(undefined *)(iVar3 + 0x932) = 0; *(undefined *)(iVar3 + 0x930) = 0; Pause_Execution(param_2,1); iVar3 = *(int *)(param_1 + 0x10); } else { iVar3 = *(int *)(param_1 + 0x10); } iVar6 = *(int *)(iVar3 + 0x7a4); if (*(char *)(iVar6 + 0x931) == '\\0') { return; } if (*(char *)(iVar6 + 0x932) == '\\0' || *(char *)(iVar6 + 0x931) == '\\0') { if (*(char *)(iVar6 + 0x931) == '\\0') { puVar5 = (undefined4 *)0x0; } else if (*(int *)(iVar6 + 0x8f0) < 0) { puVar5 = (undefined4 *)0x0; } else { puVar5 = (undefined4 *)(*(int *)(iVar3 + 0x794) + *(int *)(iVar6 + 0x8f0) * 0x30); } uVar8 = *puVar5; } else { uVar8 = *(undefined4 *)(param_1 + 0x30); } **(undefined4 **)(param_1 + 0x240) = *(undefined4 *)(iVar6 + 0x8f0); puVar5 = *(undefined4 **)(param_1 + 0x10); iVar3 = puVar5[0x1e9]; if (*(int *)(iVar3 + 0x9b4) == 0) { bVar1 = _DAT_08aabdd4 == iVar3; if (bVar1) { bVar1 = *(char *)(iVar3 + 0x931) == '\\0'; } if (!bVar1) { iVar3 = puVar5[0x1e6]; goto LAB_0892d3bc; } _DAT_08aabdd4 = 0; } else { _DAT_08aabdd4 = *(int *)(iVar3 + 0x9b4); *(undefined4 *)(iVar3 + 0x9b4) = 0; } iVar3 = puVar5[0x1e6]; LAB_0892d3bc: iVar6 = puVar5[0x1e5]; if (iVar6 != iVar6 + iVar3 * 0x30) { do { iVar6 = iVar6 + 0x30; } while (iVar6 != puVar5[0x1e5] + iVar3 * 0x30); } puVar5[0x1e6] = 0; if (puVar5[0x1e9] != 0) { FUN_0885d70c(puVar5[0x1e9]); } Syscall::Kernel::Kernel_Memset(puVar5 + 1,0,0x300); *puVar5 = 0; FUN_0885c34c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x7a4)); PAC::Cmd_Jump_Or_Call(param_2,uVar8,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "drawtimer.html": {
    "href": "drawtimer.html",
    "title": "drawTimer",
    "keywords": "drawTimer Draw the timer as seconds only. This timer is paused by default, resuming will result incrementing the number as minute:second format. Code Information Name: drawTimer Scope: Global PAC Instruction (Binary): 25 16 1b 01 Assembly Address in Memory : 0x8929fc0 Parameters (float)time (8 bytes) : Time to display. Example Here is one example in hex: 25 16 1b 01 / 20 00 00 00 / 0a 00 00 00 Which is interpreted as: drawTimer((float *)fVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08929fc0(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (*(int *)(iVar2 + 100) != 0)) { func_0x08b32f40(*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "dsp_print.html": {
    "href": "dsp_print.html",
    "title": "dsp_print",
    "keywords": "dsp_print This does nothing. For debugging purpose. Code Information Name: dsp_print Scope: Global PAC Instruction (Binary): 25 09 08 00 Assembly Address in Memory : 0x8948cfc Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) (Undefined)Var3 (8 bytes) (String)Var4 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948cfc(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); Pac_Get_Param(param_2,3,1,4); Pac_Get_StringParam(param_2,auStack256); Pac_Get_Param(param_2,0,1,4); PAC::Pac_Return_ParamAddr(param_2,0); Pac_Get_ParamType(param_2,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "dsp_string.html": {
    "href": "dsp_string.html",
    "title": "dsp_string",
    "keywords": "dsp_string Unimplemented. This function does nothing. Code Information Name: dsp_string Scope: Global PAC Instruction (Binary): 25 09 07 00 Assembly Address in Memory : 0x8948c88 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) (String)Var3 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948c88(undefined4 param_1,undefined4 param_2) { undefined auStack256 [256]; Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); Pac_Get_StringParam(param_2,auStack256); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectgeteffectid.html": {
    "href": "effectgeteffectid.html",
    "title": "effectgetEffectId",
    "keywords": "effectgetEffectId Gets effect ID in effectparam by given handle. Code Information Name: effectgetEffectId Scope: Global PAC Instruction (Binary): 25 19 13 00 Assembly Address in Memory : 0x89420fc Parameters (int *)handle_id (8 bytes) : Handle of the effect, from addEffect. (int *)effect_id (8 bytes) : Variable to store the effect ID in effectparam. Example Here is one example in hex: 25 19 13 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: effectgetEffectId((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089420fc(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } *piVar2 = 0; if (iVar3 != 0) { *piVar2 = (int)*(short *)(*(int *)(*(int *)(iVar3 + 0x344) + 0x14) + 0x10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectgetuserid.html": {
    "href": "effectgetuserid.html",
    "title": "effectGetUserId",
    "keywords": "effectGetUserId Gets a custom ID of the given effect. Code Information Name: effectGetUserId Scope: Global PAC Instruction (Binary): 25 19 03 00 Assembly Address in Memory : 0x894112c Parameters (int *)handle_id (8 bytes) : Handle of the effect, from addEffect. (uint)Var1 (8 bytes) : Expected 0~3. (int)custom_id (8 bytes) : Unique custom ID, set from effectSetUserId. Example Here is one example in hex: 25 19 03 00 / 04 00 00 00 / 40 00 00 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: effectGetUserId((int *)iVar64, (int)3, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894112c(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if ((iVar4 != 0) && (*puVar2 < 4)) { *puVar3 = *(undefined4 *)(*puVar2 * 4 + iVar4 + 0x2c0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effecthiteffectcallback.html": {
    "href": "effecthiteffectcallback.html",
    "title": "effectHitEffectCallback",
    "keywords": "effectHitEffectCallback Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: effectHitEffectCallback Scope: Global PAC Instruction (Binary): 25 19 0c 00 Assembly Address in Memory : 0x8941acc Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 19 0c 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 40 00 00 00 Which is interpreted as: effectHitEffectCallback((int *)iVar0, (int *)iVar65, (int *)iVar64) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941acc(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int iVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (-1 < *piVar1)) && (-1 < *piVar2)) && (-1 < *piVar3)) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar1,1); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar2,1); iVar6 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar3,1); if (iVar6 == 0) { iVar6 = 0; } else if (iVar6 == 0) { iVar6 = 0; } else { (**(code **)(*(int *)(iVar6 + 4) + 0x34))(iVar6); } if (((iVar4 != 0) && (iVar5 != 0)) && (iVar6 != 0)) { (**(code **)(*(int *)(iVar4 + 4) + 100))(iVar4,iVar5,iVar6); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectkill.html": {
    "href": "effectkill.html",
    "title": "effectkill",
    "keywords": "effectkill Deletes an effect with given kill ID. Code Information Name: effectkill Scope: Global PAC Instruction (Binary): 25 19 12 00 Assembly Address in Memory : 0x894207c Parameters (int)kill_id (8 bytes) : Unique ID given for effect deleting, set by effectSetDeleteId. (int)Var1 (8 bytes) : -1 instakills the effect. Can keep 0. Example Here is one example in hex: 25 19 12 00 / 02 00 00 00 / 69 b6 01 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: effectkill((int)112233, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894207c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); FUN_088ad0b0(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x128),*puVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectsetcommonstatusparam.html": {
    "href": "effectsetcommonstatusparam.html",
    "title": "effectsetCommonStatusParam",
    "keywords": "effectsetCommonStatusParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: effectsetCommonStatusParam Scope: Global PAC Instruction (Binary): 25 19 0a 00 Assembly Address in Memory : 0x89418d8 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 19 0a 00 / 04 00 00 00 / 0a 00 00 00 / 02 00 00 00 / 35 00 00 00 Which is interpreted as: effectsetCommonStatusParam((int *)iVar10, (int)53) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089418d8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; undefined4 uVar4; int iVar5; int iVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar6 = *piVar2; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if ((iVar3 != 0) && (iVar6 != -1)) { Save::Get_Save_BaseAddr(1); uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); uVar4 = Param::Get_Data_Addr(*(undefined4 *)(iVar5 + 0xa4),2); iVar6 = Param::Get_Line_Addr(uVar4,1,iVar6,1); if (iVar6 != 0) { FUN_088d2b38(iVar3,iVar6); (**(code **)(*(int *)(iVar3 + 4) + 0x114))(iVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectsetdeleteid.html": {
    "href": "effectsetdeleteid.html",
    "title": "effectsetDeleteId",
    "keywords": "effectsetDeleteId Gives an unique ID to delete a specific effect. Code Information Name: effectsetDeleteId Scope: Global PAC Instruction (Binary): 25 19 11 00 Assembly Address in Memory : 0x8941fbc Parameters (int *)handle_id (8 bytes) : Handle of the effect, possibly from addEffect (int)kill_id (8 bytes) : Unique ID to set for deleting. Example Here is one example in hex: 25 19 11 00 / 08 00 00 00 / ca 00 00 00 / 08 00 00 00 / ca 00 00 00 Which is interpreted as: effectsetDeleteId(((global)int *)giVar202, ((global)int *)giVar202) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941fbc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x2d0) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectsetdisablegimmickthrough.html": {
    "href": "effectsetdisablegimmickthrough.html",
    "title": "effectSetDisableGimmickThrough",
    "keywords": "effectSetDisableGimmickThrough Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: effectSetDisableGimmickThrough Scope: Global PAC Instruction (Binary): 25 19 20 00 Assembly Address in Memory : 0x8942cd0 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 19 20 00 / 08 00 00 00 / a8 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: effectSetDisableGimmickThrough(((global)int *)giVar168, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942cd0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *(byte *)(iVar3 + 0x325) = *(byte *)(iVar3 + 0x325) & 0x7f | (*piVar2 != 0) << 7; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectsettimmingscript.html": {
    "href": "effectsettimmingscript.html",
    "title": "effectSetTimmingScript",
    "keywords": "effectSetTimmingScript When the effect is activated, calls the specific address. Does same thing as setEffectTimmingScript, except the parameter order is a bit different. Code Information Name: effectSetTimmingScript Scope: Global PAC Instruction (Binary): 25 19 0b 00 Assembly Address in Memory : 0x89419fc Parameters (undefined4)Var0 (8 bytes) : Expected 0~4. (int)effectID (8 bytes) : Effect ID from effectparam. (MemoryAddress)pac_address (8 bytes) : Memory address that contains start of the PAC, obtained from getPack. (Address)address (8 bytes) : Address to move when effect is performed. Example Here is one example in hex: 25 19 0b 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 76 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 0c 20 00 00 Which is interpreted as: effectSetTimmingScript((int)2, (int)118, (int *)iVar0, (index)8204) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089419fc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_088ad8a8(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x128),*puVar2,*puVar1,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectsetuserid.html": {
    "href": "effectsetuserid.html",
    "title": "effectSetUserId",
    "keywords": "effectSetUserId Gives a custom ID to the given effect. Code Information Name: effectSetUserId Scope: Global PAC Instruction (Binary): 25 19 04 00 Assembly Address in Memory : 0x8941224 Parameters (int *)handle_id (8 bytes) : Handle of the effect, from addEffect. (uint)Var1 (8 bytes) : Expected 0~3. (int)custom_id (8 bytes) : Unique custom ID. Example Here is one example in hex: 25 19 04 00 / 04 00 00 00 / 40 00 00 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00 / 41 00 00 00 Which is interpreted as: effectSetUserId((int *)iVar64, (int)3, (int *)iVar65) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941224(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if ((iVar4 != 0) && (*puVar2 < 4)) { *(undefined4 *)(*puVar2 * 4 + iVar4 + 0x2c0) = *puVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "effectsetwaittime.html": {
    "href": "effectsetwaittime.html",
    "title": "effectSetWaitTime",
    "keywords": "effectSetWaitTime Sets time to wait before the effect appears. Code Information Name: effectSetWaitTime Scope: Global PAC Instruction (Binary): 25 19 05 00 Assembly Address in Memory : 0x894131c Parameters (int *)handle_id (8 bytes) : The target handle. (float)waiting_time (8 bytes) : Time to wait before effect appears, as seconds. Example Here is one example in hex: 25 19 05 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: effectSetWaitTime((int *)iVar0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894131c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { FUN_089c91ec(*puVar2,iVar3 + 0x288); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enablebossmanualctrl.html": {
    "href": "enablebossmanualctrl.html",
    "title": "enableBossManualCtrl",
    "keywords": "enableBossManualCtrl Enables or disables boss attacking in sequence with setBossActionId. Code Information Name: enableBossManualCtrl Scope: Global PAC Instruction (Binary): 25 21 03 00 Assembly Address in Memory : 0x89b13f0 Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (bool)enable_manual (8 bytes) : If this is 1, the boss performs only one move per setBossActionId. Example Here is one example in hex: 25 21 03 00 / 02 00 00 00 / 64 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: enableBossManualCtrl((int)100, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b13f0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { FUN_08976e90(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enablecollision.html": {
    "href": "enablecollision.html",
    "title": "enableCollision",
    "keywords": "enableCollision Enables or disables a collision hitbox. Code Information Name: enableCollision Scope: Global PAC Instruction (Binary): 25 17 3e 00 Assembly Address in Memory : 0x89151c8 Parameters (int *)handle_id (8 bytes) : The target handle. (bool)bVar1 (8 bytes) : Usually this is zero, please describe what this does. (bool)enabled (8 bytes) : 1 enables the collision, otherwise 0. Example Here is one example in hex: 25 17 3e 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: enableCollision((int *)iVar1, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089151c8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 0xb) { if (*piVar2 == 0) { (**(code **)(*(int *)(iVar4 + 4) + 0x110))(iVar4,*piVar3 != 0); goto LAB_089152e0; } iVar4 = *(int *)(iVar4 + 0xd0); } else { iVar4 = *(int *)(iVar4 + 0xd0); } if ((iVar4 != 0) && (iVar4 = Set_Collision(iVar4 + 0xa0,*piVar2), iVar4 != 0)) { FUN_0886f280(iVar4,*piVar3 != 0); } } } LAB_089152e0: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enablecollisionconstgimmick.html": {
    "href": "enablecollisionconstgimmick.html",
    "title": "enableCollisionConstGimmick",
    "keywords": "enableCollisionConstGimmick Sets a const gimmick collidable. Code Information Name: enableCollisionConstGimmick Scope: Global PAC Instruction (Binary): 25 16 c1 00 Assembly Address in Memory : 0x8923fe4 Parameters (int)gate_id (8 bytes) : Obtained from getGateInfo with param_index 0. -1 to enable every constgimmick collision. Example Here is one example in hex: 25 16 c1 00 / 08 00 00 00 / 48 00 00 00 Which is interpreted as: enableCollisionConstGimmick(((global)int *)giVar72) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923fe4(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_089f0810(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x7e44,*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enablecollisionflag.html": {
    "href": "enablecollisionflag.html",
    "title": "enableCollisionFlag",
    "keywords": "enableCollisionFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: enableCollisionFlag Scope: Global PAC Instruction (Binary): 25 17 41 00 Assembly Address in Memory : 0x89155fc Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (int)Var4 (8 bytes) (int)Var5 (8 bytes) Example Here is one example in hex: 25 17 41 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: enableCollisionFlag((int *)iVar1, (int)0, (int)1, (int)1, (int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089155fc(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int *piVar4; int *piVar5; int *piVar6; int iVar7; int iVar8; uint uVar9; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); if (*piVar1 != -1) { iVar7 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar7 == 0) { iVar7 = 0; } if (iVar7 != 0) { iVar8 = (**(code **)(*(int *)(iVar7 + 4) + 0x34))(iVar7); if (iVar8 == 10) { if (*piVar2 == 0) { FUN_088cbea0(iVar7,*piVar5 != 0,*piVar4 != 0,*piVar6 != 0,*piVar4 != 0); (**(code **)(*(int *)(iVar7 + 4) + 0x110))(iVar7,*piVar3 != 0); goto LAB_089157c0; } iVar7 = *(int *)(iVar7 + 0xd0); } else { iVar7 = *(int *)(iVar7 + 0xd0); } if ((iVar7 != 0) && (iVar7 = Set_Collision(iVar7 + 0xa0,*piVar2), iVar7 != 0)) { uVar9 = 0; if (*piVar4 == 0) { uVar9 = 10; } if (*piVar5 == 0) { uVar9 = uVar9 | 1; iVar8 = *piVar6; } else { iVar8 = *piVar6; } if (iVar8 == 0) { *(uint *)(iVar7 + 0x58) = uVar9 | 4; } else { *(uint *)(iVar7 + 0x58) = uVar9; } FUN_0886f280(iVar7,*piVar3 != 0); } } } LAB_089157c0: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enabledamageflag.html": {
    "href": "enabledamageflag.html",
    "title": "enableDamageFlag",
    "keywords": "enableDamageFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: enableDamageFlag Scope: Global PAC Instruction (Binary): 25 17 6d 00 Assembly Address in Memory : 0x8918910 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 17 6d 00 / 04 00 00 00 / 14 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: enableDamageFlag((int *)iVar20, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08918910(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 - 9U < 2)) { *(bool *)(*(int *)(iVar3 + 0xcc) + 0xf) = *piVar2 == 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enableforeverrun.html": {
    "href": "enableforeverrun.html",
    "title": "enableForeverRun",
    "keywords": "enableForeverRun Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: enableForeverRun Scope: Global PAC Instruction (Binary): 25 17 64 00 Assembly Address in Memory : 0x891811c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 17 64 00 / 04 00 00 00 / 17 00 00 00 Which is interpreted as: enableForeverRun((int *)iVar23) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891811c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar2 == 0) { iVar2 = 0; } if (iVar2 != 0) { iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2); if (iVar3 == 0xb) { *(undefined *)(iVar2 + 0x2b5) = 1; } else { iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2); if (iVar3 == 10) { *(undefined *)(iVar2 + 0x18d) = 1; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enablerenderattach.html": {
    "href": "enablerenderattach.html",
    "title": "enableRenderAttach",
    "keywords": "enableRenderAttach Determines if it preserves own tree while being attached or not. Code Information Name: enableRenderAttach Scope: Global PAC Instruction (Binary): 25 17 71 00 Assembly Address in Memory : 0x8918c64 Parameters (int *)handle_id (8 bytes) : The target handle of the attached object. (bool)follow_parent (8 bytes) : Leave as 0 if there is any child to the handle, 1 might break the own node tree. Example Here is one example in hex: 25 17 71 00 / 08 00 00 00 / cb 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: enableRenderAttach(((global)int *)giVar203, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08918c64(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; uint uVar4; uint *puVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*(byte *)(iVar3 + 0x8c) = *(byte *)(iVar3 + 0x8c) & 0xfb | (*piVar2 != 0) << 2, *piVar2 == 0)) { if (*(int *)(iVar3 + 0x100) == 0) { puVar5 = *(uint **)(iVar3 + 0x108); } else { (**(code **)(*(int *)(iVar3 + 4) + 0x3c))(iVar3,0); puVar5 = *(uint **)(iVar3 + 0x108); } if ((puVar5[2] ^ *(uint *)(iVar3 + 0x10c) | *puVar5 ^ *(uint *)(iVar3 + 0x104) | puVar5[1] ^ *(uint *)(iVar3 + 0x108)) != 0) { uVar4 = puVar5[2]; while( true ) { (**(code **)(*(int *)(uVar4 + 4) + 0x3c))(uVar4,0); uVar4 = _DAT_00000004; if (puVar5 != (uint *)0x0) { puVar5 = (uint *)puVar5[1]; uVar4 = puVar5[1]; } if ((puVar5[2] ^ *(uint *)(iVar3 + 0x10c) | *puVar5 ^ *(uint *)(iVar3 + 0x104) | uVar4 ^ *(uint *)(iVar3 + 0x108)) == 0) break; uVar4 = puVar5[2]; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "endappearitem.html": {
    "href": "endappearitem.html",
    "title": "endAppearItem",
    "keywords": "endAppearItem Declares end of the item definition table. Paired with beginAppearItem. Code Information Name: endAppearItem Scope: Global PAC Instruction (Binary): 25 08 04 00 Assembly Address in Memory : 0x896eb90 Parameters This function is parameterless. Example Here is one example in hex: 25 08 04 00 Which is interpreted as: endAppearItem() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896eb90(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(param_1 + 0x10); if (iVar1 == 0) { iVar1 = 0; } else { if (iVar1 == 0) { iVar1 = 0; } iVar1 = *(int *)(iVar1 + 0x188); if (iVar1 == 0) { iVar1 = 0; } } if (iVar1 != 0) { Loot::Finish_Writing_Loot_Chances(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "endgame.html": {
    "href": "endgame.html",
    "title": "endGame",
    "keywords": "endGame Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: endGame Scope: Global PAC Instruction (Binary): 25 16 6c 00 Assembly Address in Memory : 0x8920750 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920750(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { FUN_0889ddec(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "endsetupstage.html": {
    "href": "endsetupstage.html",
    "title": "endSetupStage",
    "keywords": "endSetupStage Ends/Finalises stage setup. This can be paired with startSetupStage, or be called without pairing to completely end the stage setup. More information in How To: Setup Stages. Code Information Name: endSetupStage Scope: Global PAC Instruction (Binary): 25 16 5c 00 Assembly Address in Memory : 0x891fdc4 Parameters This function is parameterless. Example Here is one example in hex: 25 16 5c 00 Which is interpreted as: endSetupStage() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891fdc4(int param_1,undefined4 param_2) { FUN_088b03fc(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "enumequipitem.html": {
    "href": "enumequipitem.html",
    "title": "enumEquipItem",
    "keywords": "enumEquipItem Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: enumEquipItem Scope: Global PAC Instruction (Binary): 25 0a 48 00 Assembly Address in Memory : 0x894d708 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 0a 48 00 / 04 00 00 00 / 05 00 00 00 Which is interpreted as: enumEquipItem((int *)iVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d708(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); if (-1 < *piVar1) { iVar2 = FUN_08946440(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34)); *piVar1 = iVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "erasesquad.html": {
    "href": "erasesquad.html",
    "title": "eraseSquad",
    "keywords": "eraseSquad Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: eraseSquad Scope: Global PAC Instruction (Binary): 25 16 46 00 Assembly Address in Memory : 0x891e23c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 46 00 / 04 00 00 00 / 14 00 00 00 Which is interpreted as: eraseSquad((int *)iVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e23c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar2 != 0) && (iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2), iVar3 == 3)) { FUN_088c40f0(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "exitorder.html": {
    "href": "exitorder.html",
    "title": "exitOrder",
    "keywords": "exitOrder Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: exitOrder Scope: Global PAC Instruction (Binary): 25 0a 03 00 Assembly Address in Memory : 0x8949774 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949774(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { *(undefined *)(*(int *)(param_1 + 0x10) + 0x354) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "extinctionfire.html": {
    "href": "extinctionfire.html",
    "title": "extinctionFire",
    "keywords": "extinctionFire Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: extinctionFire Scope: Global PAC Instruction (Binary): 25 17 6a 00 Assembly Address in Memory : 0x89186c0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 6a 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: extinctionFire((int *)iVar65, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089186c0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 4) + 0x124))(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "filltipsselectmask.html": {
    "href": "filltipsselectmask.html",
    "title": "fillTipsSelectMask",
    "keywords": "fillTipsSelectMask Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: fillTipsSelectMask Scope: Global PAC Instruction (Binary): 25 0a 2d 00 Assembly Address in Memory : 0x894bd60 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bd60(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Save::Get_Save_BaseAddr(1); Syscall::Kernel::Kernel_Memset(*(int *)(iVar1 + 0x58) + 0x14,0xffffffff,0x10); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "flipenable.html": {
    "href": "flipenable.html",
    "title": "flipEnable",
    "keywords": "flipEnable Changes direction of the unit. For player, works only cutscene with player model index 1. For bosses, it works. Code Information Name: flipEnable Scope: Global PAC Instruction (Binary): 25 17 0e 00 Assembly Address in Memory : 0x8911a60 Parameters (int *)handle (8 bytes) : Handle of the target. (bool)is_flip (8 bytes) : 0 is normal direction (unit sees right), 1 the unit sees left. Example Here is one example in hex: 25 17 0e 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: flipEnable((int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911a60(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { if (*piVar2 == 0) { uVar4 = 0x3f800000; } else { uVar4 = 0xbf800000; } *(undefined4 *)(iVar3 + 0x94) = uVar4; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } (**(code **)(*(int *)(iVar3 + 4) + 0x3c))(iVar3,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getItem.html": {
    "href": "getItem.html",
    "title": "getItem",
    "keywords": "getItem There are few functions with the same name: getItem (25166300) (Global) getItem (250a0b00) (Global)"
  },
  "getPack.html": {
    "href": "getPack.html",
    "title": "getPack",
    "keywords": "getPack There are few functions with the same name: getPack (25100600) (Global) getPack (25160200) (Global) getPack (251c0200) (Azito)"
  },
  "getTroopSign.html": {
    "href": "getTroopSign.html",
    "title": "getTroopSign",
    "keywords": "getTroopSign There are few functions with the same name: getTroopSign (25175f00) (Global) getTroopSign (25164101) (Global)"
  },
  "getUnitParam.html": {
    "href": "getUnitParam.html",
    "title": "getUnitParam",
    "keywords": "getUnitParam There are few functions with the same name: getUnitParam (25161b00) (Global) getUnitParam (250a4700) (Global)"
  },
  "getabnormalstatus.html": {
    "href": "getabnormalstatus.html",
    "title": "getAbnormalStatus",
    "keywords": "getAbnormalStatus Gets status effect as flags. Works only with unit. Check status ID table for the status effect flag. Code Information Name: getAbnormalStatus Scope: Global PAC Instruction (Binary): 25 17 4e 00 Assembly Address in Memory : 0x89165cc Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (uint *)destination (8 bytes) : Target to store the result. Example Here is one example in hex: 25 17 4e 00 / 04 00 00 00 / 2d 00 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: getAbnormalStatus((int *)iVar45, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089165cc(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { iVar3 = iVar3 + 0x180; *puVar2 = 0; iVar4 = Damage::Status::Is_On_Status_Effect(iVar3,0); if (iVar4 != 0) { *puVar2 = *puVar2 | 1; } iVar4 = Damage::Status::Is_On_Status_Effect(iVar3,1); if (iVar4 != 0) { *puVar2 = *puVar2 | 2; } iVar4 = Damage::Status::Is_On_Status_Effect(iVar3,2); if (iVar4 != 0) { *puVar2 = *puVar2 | 4; } iVar4 = Damage::Status::Is_On_Status_Effect(iVar3,3); if (iVar4 != 0) { *puVar2 = *puVar2 | 8; } iVar4 = Damage::Status::Is_On_Status_Effect(iVar3,4); if (iVar4 != 0) { *puVar2 = *puVar2 | 0x10; } iVar4 = Damage::Status::Is_On_Status_Effect(iVar3,5); if (iVar4 != 0) { *puVar2 = *puVar2 | 0x20; } iVar3 = Damage::Status::Is_On_Status_Effect(iVar3,6); if (iVar3 != 0) { *puVar2 = *puVar2 | 0x40; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactive.html": {
    "href": "getactive.html",
    "title": "getActive",
    "keywords": "getActive Checks if a target with given handle is active. setActive decides if the target is active. Code Information Name: getActive Scope: Global PAC Instruction (Binary): 25 17 07 00 Assembly Address in Memory : 0x891111c Parameters (int *)handle_id (8 bytes) : The target Handle. (bool *)is_active (8 bytes) : Variable to store the result. 1 if the target is active, otherwise 0. Example Here is one example in hex: 25 17 07 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getActive((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891111c(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } *puVar2 = 0; if (iVar3 != 0) { *puVar2 = (uint)*(byte *)(iVar3 + 0x9c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactorbaseinfo.html": {
    "href": "getactorbaseinfo.html",
    "title": "getActorBaseInfo",
    "keywords": "getActorBaseInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getActorBaseInfo Scope: Global PAC Instruction (Binary): 25 17 03 00 Assembly Address in Memory : 0x8910d9c Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (uint)Var4 (8 bytes) Example Here is one example in hex: 25 17 03 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getActorBaseInfo((int *)iVar65, (int *)iVar0, (int *)iVar0, (int *)iVar1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08910d9c(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 *puVar3; undefined4 *puVar4; uint *puVar5; int iVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (uint *)Pac_Get_Param(param_2,4,1,4); iVar6 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar6 == 0) { iVar6 = 0; } if (iVar6 != 0) { *puVar2 = (uint)*(byte *)(iVar6 + 0x8a); *puVar3 = *(undefined4 *)(iVar6 + 0x74); uVar7 = (**(code **)(*(int *)(iVar6 + 4) + 0x34))(iVar6); *puVar4 = uVar7; *puVar5 = (uint)*(byte *)(iVar6 + 0x9c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactorhandle.html": {
    "href": "getactorhandle.html",
    "title": "getActorHandle",
    "keywords": "getActorHandle Gets an handle of any kind of reqActor. Must be called after the target is being spawned. Code Information Name: getActorHandle Scope: Mission PAC Instruction (Binary): 25 1f 14 00 Assembly Address in Memory : 0x8b5d8d0 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int *)destination (8 bytes) : Variable to store the handle. Example Here is one example in hex: 25 1f 14 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 03 00 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: getActorHandle((int *)iVar0, (int)3, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d8d0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8)); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { uVar4 = FUN_Mission__08b56d28(iVar5,*puVar2); *puVar3 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactorinfo.html": {
    "href": "getactorinfo.html",
    "title": "getActorInfo",
    "keywords": "getActorInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getActorInfo Scope: Global PAC Instruction (Binary): 25 17 04 00 Assembly Address in Memory : 0x8910ebc Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08910ebc(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*puVar2 == 0)) { *puVar2 = ((uint)*(byte *)(iVar3 + 0x8c) << 0x1e) >> 0x1f; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactorlevel.html": {
    "href": "getactorlevel.html",
    "title": "getActorLevel",
    "keywords": "getActorLevel Gets level of an any object (unit, gimmick etc) by the given handle. Code Information Name: getActorLevel Scope: Global PAC Instruction (Binary): 25 17 48 00 Assembly Address in Memory : 0x8915da4 Parameters (int *)handle (8 bytes) : Any kind of actor handle. (int *)level (8 bytes) : Variable to store the level of an actor. Example Here is one example in hex: 25 17 48 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 05 00 00 00 Which is interpreted as: getActorLevel((int *)iVar1, (int *)iVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915da4(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 1; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14)); if (iVar3 == 0) { iVar3 = 0; } if (*(int *)(iVar3 + 0xcc) != 0) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 0xcc) + 8); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactorphase.html": {
    "href": "getactorphase.html",
    "title": "getActorPhase",
    "keywords": "getActorPhase Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getActorPhase Scope: Global PAC Instruction (Binary): 25 19 14 00 Assembly Address in Memory : 0x89421c4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 19 14 00 / 04 00 00 00 / 40 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getActorPhase((int *)iVar64, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089421c4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 != 0) { iVar3 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); if (iVar3 == 0xb) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } *puVar2 = *(undefined4 *)(iVar3 + 0x290); } else if (iVar3 == 10) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } *puVar2 = *(undefined4 *)(iVar3 + 0x168); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getactreqactcount.html": {
    "href": "getactreqactcount.html",
    "title": "getActReqActCount",
    "keywords": "getActReqActCount Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getActReqActCount Scope: Mission PAC Instruction (Binary): 25 1f 16 00 Assembly Address in Memory : 0x8b5da88 Parameters (int)Var0 (8 bytes) (char)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 1f 16 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 05 00 00 00 Which is interpreted as: getActReqActCount((int *)iVar1, (int)0, (int *)iVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5da88(int param_1,undefined4 param_2) { int *piVar1; char *pcVar2; int *piVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); pcVar2 = (char *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { iVar4 = Get_ReqActor_Addr(iVar4,(int)*pcVar2); *piVar3 = (int)*(char *)(iVar4 + 9); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getaliveunitcount.html": {
    "href": "getaliveunitcount.html",
    "title": "getAliveUnitCount",
    "keywords": "getAliveUnitCount Checks currently how many units are alive in the player squad. This also determines mission failrue status (every member of the team is wiped out). Code Information Name: getAliveUnitCount Scope: Global PAC Instruction (Binary): 25 16 36 00 Assembly Address in Memory : 0x891cf94 Parameters (int *)destination (8 bytes) : Variable to store how many units are alive in the player troop. Example Here is one example in hex: 25 16 36 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getAliveUnitCount((int *)iVar0) This sets mission failure flag when the alive unit in the player team is 0 or less. 00004E40 25163600:getAliveUnitCount(4:0) 00004E4C 25001900:cmd_ifLSE(4:0, 0.0, 1:4F08) 00004E64 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891cf94(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0xf8); if (iVar2 == 0) { iVar2 = 0; } } if ((iVar2 != 0) && (iVar2 = FUN_088a8650(iVar2,0), iVar2 != 0)) { uVar3 = FUN_088e11c4(iVar2); *puVar1 = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getappearitem.html": {
    "href": "getappearitem.html",
    "title": "getAppearItem",
    "keywords": "getAppearItem Rolls and gets the random item from a given table. Called when rolling final item from chests. For rolling item during mission, check getAppearItemEx. Code Information Name: getAppearItem Scope: Global PAC Instruction (Binary): 25 08 05 00 Assembly Address in Memory : 0x896ebf4 Parameters (int)item_table_id (8 bytes) : ID of the Item table, defined from beginAppearItem (int *)item_id (8 bytes) : Variable to store the item ID. (int *)item_level (8 bytes) : Variable to store the item level. Example Here is one example in hex: 25 08 05 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 0d 00 00 00 / 04 00 00 00 / 0e 00 00 00 Which is interpreted as: getAppearItem((int)1, (int *)iVar13, (int *)iVar14) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896ebf4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0x188); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { // this somehow decides loot type (maybe) uVar5 = Util::Random::Timer_Get_Random(); puVar1 = (undefined4 *)Loot::Get_Chosen_Loot_Id(iVar4,*puVar1,uVar5,1); if (puVar1 == (undefined4 *)0x0) { *puVar2 = 0x220; // +1 *puVar3 = 1; } else { *puVar2 = *puVar1; *puVar3 = puVar1[2]; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getappearitemex.html": {
    "href": "getappearitemex.html",
    "title": "getAppearItemEx",
    "keywords": "getAppearItemEx Rolls with specific random seed and gets the random item from a given table. Used for rolling items during mission (e.g. Cyclops loot throwing), since the random function in getAppearItem doesn't work properly during mission. Code Information Name: getAppearItemEx Scope: Global PAC Instruction (Binary): 25 08 06 00 Assembly Address in Memory : 0x896ed04 Parameters (int)item_table_id (8 bytes) : ID of the Item table, defined from beginAppearItem (int *)item_id (8 bytes) : Variable to store the item ID. (int *)item_level (8 bytes) : Variable to store the item level. (int)random_seed (8 bytes) : Random seed to set. Example Here is one example in hex: 25 08 06 00 / 02 00 00 00 / 90 01 00 00 / 08 00 00 00 / 2a 00 00 00 / 08 00 00 00 / 36 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getAppearItemEx((int)400, ((global)int *)giVar42, ((global)int *)giVar54, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896ed04(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; int iVar5; uint uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = *(int *)(iVar5 + 0x188); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { param_1 = param_1 + *piVar4 * 0x10; uVar6 = *(uint *)(param_1 + 0x14) ^ *(uint *)(param_1 + 0x14) << 0xb; *(undefined4 *)(param_1 + 0x14) = *(undefined4 *)(param_1 + 0x18); *(undefined4 *)(param_1 + 0x18) = *(undefined4 *)(param_1 + 0x1c); *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(param_1 + 0x20); uVar6 = *(uint *)(param_1 + 0x20) ^ *(uint *)(param_1 + 0x20) >> 0x13 ^ uVar6 ^ uVar6 >> 8; *(uint *)(param_1 + 0x20) = uVar6; puVar1 = (undefined4 *)Loot::Get_Chosen_Loot_Id(iVar5,*puVar1,uVar6,1); if (puVar1 == (undefined4 *)0x0) { *puVar2 = 0x220; *puVar3 = 1; } else { *puVar2 = *puVar1; *puVar3 = puVar1[2]; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getappearmissiletype.html": {
    "href": "getappearmissiletype.html",
    "title": "getAppearMissileType",
    "keywords": "getAppearMissileType Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getAppearMissileType Scope: Global PAC Instruction (Binary): 25 16 38 01 Assembly Address in Memory : 0x892abcc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 38 01 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 0d 00 00 00 Which is interpreted as: getAppearMissileType((int *)iVar0, (int *)iVar13) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892abcc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; if (((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar3 + 0x2c) + 0x54),*puVar1), iVar3 != 0)) { uVar4 = FUN_08a4e6b4(iVar3); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getarray.html": {
    "href": "getarray.html",
    "title": "getArray",
    "keywords": "getArray Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getArray Scope: Global PAC Instruction (Binary): 25 09 10 00 Assembly Address in Memory : 0x8949244 Parameters (Int/Float)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) Example Here is one example in hex: 25 09 10 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 80 11 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getArray((int *)iVar3, (int *)iVar0, (index)4480, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949244(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int *piVar4; uint uVar5; int iVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar7 = *piVar4; iVar6 = *piVar2; uVar5 = Pac_Get_ParamType(param_2,0); if ((uVar5 & 0x70) == 0) { if ((uVar5 & 0xe) != 0) { *piVar1 = *(int *)(iVar6 + *piVar3 + iVar7 * 4); } } else { *piVar1 = (int)*(float *)(iVar6 + *piVar3 + iVar7 * 4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getazitoinfo.html": {
    "href": "getazitoinfo.html",
    "title": "getAzitoInfo",
    "keywords": "getAzitoInfo Gets certain hideout related information. The information depends on info_type parameter. Code Information Name: getAzitoInfo Scope: Azito PAC Instruction (Binary): 25 1c 06 00 Assembly Address in Memory : 0x8b4d560 Parameters (int)info_type (8 bytes) : Type to get the info, in range of 0x0 ~ 0x12 (uint *)destination (8 bytes) : Variable to store the result value. About info_type 0x0 : 2 if just loaded hideout, 3 if visited mission after loading hideout (used for autosave). Other values will break the game. 0x1 : Last selected (no need to play) mission Group ID, -1 if never selected mission after loading the save. 0x2 : Last selected (no need to play) mission ID in the world (DLC is separated world), -1 if never selected mission after loading the save. 0x3 : (Unused) If the player is in barracks or world map, this is 0. Otherwise it is 1. 0x4 : (Unused) Related to savedata internal value. 0x5 : (Unused) Related to savedata internal value. 0x6 : (Unused) Related to savedata internal value. 0x7 : The selected facility ID. 0x8, 0x9 : (Unused) Unimplemented. Does nothing. 0xA : 0 if loading the scene change. 1 if the scene is loaded. 0xB : 1 if a mission is selected. Otherwise it is 0. 0xC : 1 if the player is in VS world map or VS mission is selected. Otherwise it is 0. 0xD : 1 if host selected a VS mission, 2 if host selected a co-op mission, otherwise it is zero. 0xE : Same as 0x11, except non-functional facility choosing returns 1 too (viewing \"error\" dialog is 0). 0xF : 1 if host is in hideout, otherwise it is 0. Related to \"Cannot enter until host returns to Hideout\" message. 0x10 : (Unused) Please describe this. Expected to be 3. 0x11 : When the facility is chosen (clicked X) and has actual function, it is 1. 0x12 : 1 if the player is in Hoshi shop or Meden shop, otherwise 0. Example Here is one example in hex: 25 1c 06 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getAzitoInfo((int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d560(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; int iVar4; undefined4 uVar5; int iVar6; uint uVar7; undefined4 uVar8; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar8 = *puVar1; puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x1c(*(undefined4 *)(iVar3 + 0x50)); iVar4 = Save::Get_Save_BaseAddr(1); iVar4 = *(int *)(iVar4 + 0x58); uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); switch(uVar8) { case 0: *puVar2 = *(uint *)(iVar4 + 0x90); break; case 1: *puVar2 = *(uint *)(*(int *)(iVar6 + 0x44) + 0x534); break; case 2: *puVar2 = *(uint *)(*(int *)(iVar6 + 0x44) + 0x550); break; case 3: *puVar2 = (uint)*(byte *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x20); break; case 4: *puVar2 = *(uint *)(iVar3 + 0xeda4); break; case 5: *puVar2 = *(uint *)(iVar3 + 0xeda8); break; case 6: *puVar2 = *(uint *)(iVar3 + 0xeda0); break; case 7: iVar3 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x2b8); if (iVar3 != 0) { *puVar2 = (int)**(short **)(iVar3 + 0x144); } break; case 10: *puVar2 = (uint)*(byte *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x21); break; case 0xb: *puVar2 = (uint)*(byte *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x2d); break; case 0xc: *puVar2 = (uint)*(byte *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x2e); break; case 0xd: uVar8 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar8,1); *puVar2 = *(uint *)(*(int *)(iVar3 + 0x44) + 100); break; case 0xe: if (*(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x14) + 0x20) == 0) { *puVar2 = 1; } else { *puVar2 = (uint)*(byte *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x2f); } break; case 0xf: uVar8 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar8,1); uVar7 = FUN_089ff418(*(undefined4 *)(*(int *)(iVar3 + 100) + 0x1dc)); *puVar2 = uVar7 & 0xff; break; case 0x10: *puVar2 = *(uint *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x24); break; case 0x11: if (*(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x14) + 0x20) == 0) { *puVar2 = 1; } else { *puVar2 = 0; } break; case 0x12: *puVar2 = (uint)*(byte *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x28); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossactionid.html": {
    "href": "getbossactionid.html",
    "title": "getBossActionId",
    "keywords": "getBossActionId Gets ID of the action that the boss is currently performing. Code Information Name: getBossActionId Scope: Global PAC Instruction (Binary): 25 21 05 00 Assembly Address in Memory : 0x89b1598 Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (bool *)action_id (8 bytes) : Variable to store the current Action ID. Example Here is one example in hex: 25 21 05 00 / 02 00 00 00 / 64 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getBossActionId((int)100, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1598(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x29c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossattackmoverange.html": {
    "href": "getbossattackmoverange.html",
    "title": "getBossAttackMoveRange",
    "keywords": "getBossAttackMoveRange Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossAttackMoveRange Scope: Global PAC Instruction (Binary): 25 21 15 00 Assembly Address in Memory : 0x89b28ac Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 21 15 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getBossAttackMoveRange((int *)iVar0, (int)0, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b28ac(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar4 != 0) { uVar5 = (**(code **)(*(int *)(iVar4 + 0xc) + 0x98))(iVar4,*puVar2); *puVar3 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossdisableatkmove.html": {
    "href": "getbossdisableatkmove.html",
    "title": "getBossDisableAtkMove",
    "keywords": "getBossDisableAtkMove Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossDisableAtkMove Scope: Global PAC Instruction (Binary): 25 21 16 00 Assembly Address in Memory : 0x89b2968 Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 21 16 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getBossDisableAtkMove((int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2968(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { *puVar2 = (uint)*(byte *)(iVar3 + 0x330); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossinfo.html": {
    "href": "getbossinfo.html",
    "title": "getBossInfo",
    "keywords": "getBossInfo Gets boss information, don't use this. Called in monster.pac once. Patapon 3 original bosses don't use this. Code Information Name: getBossInfo Scope: Global PAC Instruction (Binary): 25 21 10 00 Assembly Address in Memory : 0x89b1b5c Parameters (undefined4)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) (Undefined)Var3 (8 bytes) (Undefined)Var4 (8 bytes) (Undefined)Var5 (8 bytes) (Undefined)Var6 (8 bytes) (Undefined)Var7 (8 bytes) (Undefined)Var8 (8 bytes) (Undefined)Var9 (8 bytes) (Undefined)Var10 (8 bytes) (Undefined)Var11 (8 bytes) (Undefined)Var12 (8 bytes) (Undefined)Var13 (8 bytes) (Undefined)Var14 (8 bytes) (Undefined)Var15 (8 bytes) (Undefined)Var16 (8 bytes) (Undefined)Var17 (8 bytes) (Undefined)Var18 (8 bytes) (Undefined)Var19 (8 bytes) (Undefined)Var20 (8 bytes) (Undefined)Var21 (8 bytes) (Undefined)Var22 (8 bytes) (Undefined)Var23 (8 bytes) (Undefined)Var24 (8 bytes) (Undefined)Var25 (8 bytes) (Undefined)Var26 (8 bytes) (Undefined)Var27 (8 bytes) (Undefined)Var28 (8 bytes) (undefined4)Var29 (8 bytes) (undefined4)Var30 (8 bytes) (undefined4)Var31 (8 bytes) (undefined4)Var32 (8 bytes) Example Here is one example in hex: 25 21 10 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 04 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 06 00 00 00 / 04 00 00 00 / 07 00 00 00 / 04 00 00 00 / 08 00 00 00 / 04 00 00 00 / 0d 00 00 00 / 04 00 00 00 / 0e 00 00 00 / 04 00 00 00 / 0f 00 00 00 / 20 00 00 00 / 03 00 00 00 / 20 00 00 00 / 04 00 00 00 / 20 00 00 00 / 05 00 00 00 / 20 00 00 00 / 06 00 00 00 / 04 00 00 00 / 0a 00 00 00 / 04 00 00 00 / 0b 00 00 00 / 20 00 00 00 / 07 00 00 00 / 20 00 00 00 / 08 00 00 00 / 20 00 00 00 / 09 00 00 00 / 20 00 00 00 / 0a 00 00 00 / 20 00 00 00 / 0b 00 00 00 / 20 00 00 00 / 0c 00 00 00 / 20 00 00 00 / 0d 00 00 00 / 04 00 00 00 / 0c 00 00 00 / 02 00 00 00 / 0a 0e 00 00 / 02 00 00 00 / 04 0e 00 00 / 02 00 00 00 / 18 0e 00 00 / 02 00 00 00 / 1b 0e 00 00 Which is interpreted as: getBossInfo((int *)iVar0, (int *)iVar1, (float *)fVar0, (float *)fVar1, (float *)fVar2, (int *)iVar2, (int *)iVar3, (int *)iVar4, (int *)iVar5, (int *)iVar6, (int *)iVar7, (int *)iVar8, (int *)iVar13, (int *)iVar14, (int *)iVar15, (float *)fVar3, (float *)fVar4, (float *)fVar5, (float *)fVar6, (int *)iVar10, (int *)iVar11, (float *)fVar7, (float *)fVar8, (float *)fVar9, (float *)fVar10, (float *)fVar11, (float *)fVar12, (float *)fVar13, (int *)iVar12, (int)3594, (int)3588, (int)3608, (int)3611) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1b5c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; undefined4 uVar6; undefined4 uVar7; undefined4 uVar8; undefined4 uVar9; undefined4 uVar10; undefined4 uVar11; undefined4 uVar12; undefined4 uVar13; undefined4 uVar14; undefined4 uVar15; undefined4 uVar16; undefined4 uVar17; undefined4 uVar18; undefined4 uVar19; undefined4 uVar20; undefined4 uVar21; undefined4 uVar22; undefined4 uVar23; undefined4 uVar24; undefined4 uVar25; undefined4 uVar26; undefined4 uVar27; undefined4 uVar28; undefined4 uVar29; undefined4 *puVar30; undefined4 *puVar31; undefined4 *puVar32; undefined4 *puVar33; int iVar34; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_Param(param_2,3,1,4); uVar5 = Pac_Get_Param(param_2,4,1,4); uVar6 = Pac_Get_Param(param_2,5,1,4); uVar7 = Pac_Get_Param(param_2,6,1,4); uVar8 = Pac_Get_Param(param_2,7,1,4); uVar9 = Pac_Get_Param(param_2,8,1,4); uVar10 = Pac_Get_Param(param_2,9,1,4); uVar11 = Pac_Get_Param(param_2,10,1,4); uVar12 = Pac_Get_Param(param_2,0xb,1,4); uVar13 = Pac_Get_Param(param_2,0xc,1,4); uVar14 = Pac_Get_Param(param_2,0xd,1,4); uVar15 = Pac_Get_Param(param_2,0xe,1,4); uVar16 = Pac_Get_Param(param_2,0xf,1,4); uVar17 = Pac_Get_Param(param_2,0x10,1,4); uVar18 = Pac_Get_Param(param_2,0x11,1,4); uVar19 = Pac_Get_Param(param_2,0x12,1,4); uVar20 = Pac_Get_Param(param_2,0x13,1,4); uVar21 = Pac_Get_Param(param_2,0x14,1,4); uVar22 = Pac_Get_Param(param_2,0x15,1,4); uVar23 = Pac_Get_Param(param_2,0x16,1,4); uVar24 = Pac_Get_Param(param_2,0x17,1,4); uVar25 = Pac_Get_Param(param_2,0x18,1,4); uVar26 = Pac_Get_Param(param_2,0x19,1,4); uVar27 = Pac_Get_Param(param_2,0x1a,1,4); uVar28 = Pac_Get_Param(param_2,0x1b,1,4); uVar29 = Pac_Get_Param(param_2,0x1c,1,4); puVar30 = (undefined4 *)Pac_Get_Param(param_2,0x1d,1,4); puVar31 = (undefined4 *)Pac_Get_Param(param_2,0x1e,1,4); puVar32 = (undefined4 *)Pac_Get_Param(param_2,0x1f,1,4); puVar33 = (undefined4 *)Pac_Get_Param(param_2,0x20,1,4); iVar34 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar34 != 0) { Boss::Save_BossAction (iVar34,uVar2,uVar3,uVar4,uVar5,uVar6,uVar7,uVar8,uVar9,uVar10,uVar11,uVar12,uVar13, uVar14,uVar15,uVar16,uVar17,uVar18,uVar19,uVar20,uVar21,uVar22,uVar23,uVar24,uVar25, uVar26,uVar27,uVar28,uVar29,*puVar30,*puVar31,*puVar32,*puVar33); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossinfo2.html": {
    "href": "getbossinfo2.html",
    "title": "getBossInfo2",
    "keywords": "getBossInfo2 Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossInfo2 Scope: Global PAC Instruction (Binary): 25 21 11 00 Assembly Address in Memory : 0x89b24e8 Parameters (undefined4)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) (Undefined)Var3 (8 bytes) (Undefined)Var4 (8 bytes) (Undefined)Var5 (8 bytes) (undefined4)Var6 (8 bytes) (Undefined)Var7 (8 bytes) (Undefined)Var8 (8 bytes) (Undefined)Var9 (8 bytes) (Undefined)Var10 (8 bytes) (Undefined)Var11 (8 bytes) (Undefined)Var12 (8 bytes) (Undefined)Var13 (8 bytes) (undefined4)Var14 (8 bytes) (Undefined)Var15 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b24e8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; undefined4 uVar6; undefined4 *puVar7; undefined4 uVar8; undefined4 uVar9; undefined4 uVar10; undefined4 uVar11; undefined4 uVar12; undefined4 uVar13; undefined4 uVar14; undefined4 *puVar15; undefined4 uVar16; int iVar17; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_Param(param_2,3,1,4); uVar5 = Pac_Get_Param(param_2,4,1,4); uVar6 = Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); uVar8 = Pac_Get_Param(param_2,7,1,4); uVar9 = Pac_Get_Param(param_2,8,1,4); uVar10 = Pac_Get_Param(param_2,9,1,4); uVar11 = Pac_Get_Param(param_2,10,1,4); uVar12 = Pac_Get_Param(param_2,0xb,1,4); uVar13 = Pac_Get_Param(param_2,0xc,1,4); uVar14 = Pac_Get_Param(param_2,0xd,1,4); puVar15 = (undefined4 *)Pac_Get_Param(param_2,0xe,1,4); uVar16 = Pac_Get_Param(param_2,0xf,1,4); iVar17 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar17 != 0) { FUN_08977210(iVar17,uVar2,uVar3,uVar4,uVar5,uVar6,*puVar7,uVar8,uVar9,uVar10,uVar11,uVar12, uVar13,uVar14,*puVar15,uVar16); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossiscreate.html": {
    "href": "getbossiscreate.html",
    "title": "getBossIsCreate",
    "keywords": "getBossIsCreate Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossIsCreate Scope: Global PAC Instruction (Binary): 25 21 13 00 Assembly Address in Memory : 0x89b2754 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 13 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getBossIsCreate((int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2754(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { if (*(int *)(iVar3 + 0x708) == 0) { *puVar2 = 0; } else { iVar4 = FUN_0896d6e0(); if ((iVar4 == 0) || (*(int *)(iVar3 + 0x180) == -1)) { *puVar2 = 0; } else { *puVar2 = 1; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossmoverange.html": {
    "href": "getbossmoverange.html",
    "title": "getBossMoveRange",
    "keywords": "getBossMoveRange Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossMoveRange Scope: Global PAC Instruction (Binary): 25 21 0b 00 Assembly Address in Memory : 0x89b2acc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 21 0b 00 / 04 00 00 00 / 14 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: getBossMoveRange((int *)iVar20, (float *)fVar0, (float *)fVar1, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2acc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar5 != 0) { *puVar2 = *(undefined4 *)(iVar5 + 0x2a4); *puVar3 = *(undefined4 *)(iVar5 + 0x2ac); *puVar4 = *(undefined4 *)(iVar5 + 0x2b0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossmoverangelimit.html": {
    "href": "getbossmoverangelimit.html",
    "title": "getBossMoveRangeLimit",
    "keywords": "getBossMoveRangeLimit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossMoveRangeLimit Scope: Global PAC Instruction (Binary): 25 21 0d 00 Assembly Address in Memory : 0x89b2c38 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 0d 00 / 04 00 00 00 / 14 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getBossMoveRangeLimit((int *)iVar20, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2c38(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { uVar4 = FUN_08977748(iVar3); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbossstate.html": {
    "href": "getbossstate.html",
    "title": "getBossState",
    "keywords": "getBossState Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getBossState Scope: Global PAC Instruction (Binary): 25 21 3b 00 Assembly Address in Memory : 0x89b46fc Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b46fc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x68); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getbrakescore.html": {
    "href": "getbrakescore.html",
    "title": "getBrakeScore",
    "keywords": "getBrakeScore Gets what is the VS scoring when the target squad or gimmick is killed. Code Information Name: getBrakeScore Scope: Global PAC Instruction (Binary): 25 17 09 00 Assembly Address in Memory : 0x8911378 Parameters (int *)handle (8 bytes) : The target handle. Can be squad or gimmick. (int *)point (8 bytes) : Variable to store the reward point. (int *)break_type (8 bytes) : Expected 0~6. More information in setBrakeScore. Does nothing with fort occupation. Example Here is one example in hex: 25 17 09 00 / 08 00 00 00 / 7f 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getBrakeScore(((global)int *)giVar127, (int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911378(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar2 = 0; *piVar3 = 0; iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { *piVar2 = (int)*(short *)(iVar4 + 0x86); *piVar3 = (int)*(short *)(iVar4 + 0x88); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcamerasightparam.html": {
    "href": "getcamerasightparam.html",
    "title": "getCameraSightParam",
    "keywords": "getCameraSightParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getCameraSightParam Scope: Global PAC Instruction (Binary): 25 16 84 00 Assembly Address in Memory : 0x8921500 Parameters (undefined4)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) (Undefined)Var3 (8 bytes) (Undefined)Var4 (8 bytes) Example Here is one example in hex: 25 16 84 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 03 00 00 00 Which is interpreted as: getCameraSightParam((int *)iVar0, (float *)fVar0, (float *)fVar1, (float *)fVar2, (float *)fVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921500(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); Pac_Get_Param(param_2,3,1,4); Pac_Get_Param(param_2,4,1,4); *puVar1 = 0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcenternodeid.html": {
    "href": "getcenternodeid.html",
    "title": "getCenterNodeId",
    "keywords": "getCenterNodeId Gets center (root) of node of an unit. Code Information Name: getCenterNodeId Scope: Global PAC Instruction (Binary): 25 17 58 00 Assembly Address in Memory : 0x8917648 Parameters (int *)unit_handle (8 bytes) : Unit handle, obtained from e.g. getUnitHandle. (int *)destination (8 bytes) : Vairable to store the root node. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917648(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; undefined4 uVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { uVar5 = FUN_088c25e4(iVar3); *puVar2 = uVar5; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcharabaseparamindexid.html": {
    "href": "getcharabaseparamindexid.html",
    "title": "getCharaBaseParamIndexId",
    "keywords": "getCharaBaseParamIndexId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getCharaBaseParamIndexId Scope: Global PAC Instruction (Binary): 25 16 2e 01 Assembly Address in Memory : 0x892a97c Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 2e 01 / 08 00 00 00 / 5b 00 00 00 / 08 00 00 00 / 5c 00 00 00 Which is interpreted as: getCharaBaseParamIndexId(((global)int *)giVar91, ((global)int *)giVar92) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a97c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) && (iVar3 != 0)) { *piVar2 = (int)*(short *)(*(int *)(iVar3 + 0x870) + 0x10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getchildgimmick.html": {
    "href": "getchildgimmick.html",
    "title": "getChildGimmick",
    "keywords": "getChildGimmick Gets a child gimmick handle by parent handle and child gimmick ID. Code Information Name: getChildGimmick Scope: Global PAC Instruction (Binary): 25 17 52 00 Assembly Address in Memory : 0x8916f0c Parameters (int *)handle_parent (8 bytes) : Handle of the parent gimmick. (int)gimmick_id (8 bytes) : Child Gimmick identifier from various place, e.g. addGimmick, getGateInfo or registConstGimmick. (int *)destination (8 bytes) : Variable to store the child gimmick handle. Example Here is one example in hex: 25 17 52 00 / 08 00 00 00 / 40 01 00 00 / 02 00 00 00 / 36 02 00 00 / 08 00 00 00 / 41 01 00 00 Which is interpreted as: getChildGimmick(((global)int *)giVar320, (int)566, ((global)int *)giVar321) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08916f0c(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int iVar4; int iVar5; uint uVar6; uint *puVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar3 = -1; if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } puVar7 = *(uint **)(iVar4 + 0x108); if ((puVar7[2] ^ *(uint *)(iVar4 + 0x10c) | *puVar7 ^ *(uint *)(iVar4 + 0x104) | puVar7[1] ^ *(uint *)(iVar4 + 0x108)) != 0) { uVar6 = puVar7[2]; while ((iVar5 = (**(code **)(*(int *)(uVar6 + 4) + 0x34))(uVar6), iVar5 != 10 || (*piVar2 != *(int *)(*(int *)(*(int *)(uVar6 + 0x20c) + 0x14) + 0x18)))) { uVar6 = _DAT_00000004; if (puVar7 != (uint *)0x0) { puVar7 = (uint *)puVar7[1]; uVar6 = puVar7[1]; } if ((puVar7[2] ^ *(uint *)(iVar4 + 0x10c) | *puVar7 ^ *(uint *)(iVar4 + 0x104) | uVar6 ^ *(uint *)(iVar4 + 0x108)) == 0) goto LAB_08917088; uVar6 = puVar7[2]; } *piVar3 = (int)*(short *)(uVar6 + 0x78); } } LAB_08917088: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getclasstype.html": {
    "href": "getclasstype.html",
    "title": "getClassType",
    "keywords": "getClassType Gets handle type of the given handle. This is not for obtaining unit class. Code Information Name: getClassType Scope: Global PAC Instruction (Binary): 25 17 53 00 Assembly Address in Memory : 0x89170b4 Parameters (int *)handle (8 bytes) : Handle from various places. (int *)handle_type (8 bytes) : Variable to store the handle. If it is invalid unit, the value is -1. handle_type handle 0x2 Troop 0x3 Squad 0x9 Unit/Character (or bubble speech handle is also 0x9, just why) 0xA Gimmick 0xB Effect Example Here is one example in hex: 25 17 53 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getClassType((int *)iVar65, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089170b4(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { uVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); *puVar2 = uVar4; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcloudylevel.html": {
    "href": "getcloudylevel.html",
    "title": "getCloudyLevel",
    "keywords": "getCloudyLevel Gets the cloud amount scale, in range of 0~1. Code Information Name: getCloudyLevel Scope: Global PAC Instruction (Binary): 25 16 7f 00 Assembly Address in Memory : 0x8921248 Parameters (float *)destination (8 bytes) : Variable to store how much clouds are, the level is between 0~1. 0 means no cloud. Example Here is one example in hex: 25 16 7f 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getCloudyLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921248(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x260); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcollisionsize.html": {
    "href": "getcollisionsize.html",
    "title": "getCollisionSize",
    "keywords": "getCollisionSize Gets size of the collision hitbox. Code Information Name: getCollisionSize Scope: Global PAC Instruction (Binary): 25 17 43 00 Assembly Address in Memory : 0x8915928 Parameters (int *)handle_id (8 bytes) : The target handle. (float *)width (8 bytes) : Variable to store the width of the collision box. (float *)height (8 bytes) : Variable to store the height of the collision box. Example Here is one example in hex: 25 17 43 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 / 40 00 00 00 / ff 01 00 00 Which is interpreted as: getCollisionSize((int *)iVar0, (float *)fVar1, ((global)float *)gfVar511) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915928(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar2 = 0; *puVar3 = 0; if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (((iVar4 != 0) && (*(int *)(iVar4 + 0xd0) != 0)) && (iVar4 = FUN_088dcfcc(), iVar4 != 0)) { *puVar2 = *(undefined4 *)(iVar4 + 0x88); *puVar3 = *(undefined4 *)(iVar4 + 0x8c); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcollisiontype.html": {
    "href": "getcollisiontype.html",
    "title": "getCollisionType",
    "keywords": "getCollisionType Gets troop type of the collider. Code Information Name: getCollisionType Scope: Global PAC Instruction (Binary): 25 17 55 00 Assembly Address in Memory : 0x891736c Parameters (int *)handle_id (8 bytes) : The target handle. (int)troop_type (8 bytes) : Troop type of the collider. Example Here is one example in hex: 25 17 55 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: getCollisionType((int *)iVar1, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891736c(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = 4; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } *piVar2 = (int)*(char *)(iVar3 + 0x98); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcombo.html": {
    "href": "getcombo.html",
    "title": "getCombo",
    "keywords": "getCombo Gets the current command combo chain. Code Information Name: getCombo Scope: Global PAC Instruction (Binary): 25 0c 12 00 Assembly Address in Memory : 0x8970bd4 Parameters (int)combo_type (8 bytes) : The combo type (0~2). 0 gives always total combo amount, regardless of fever. Otherwise it gives 0xb (11) in fever. (int *)destination (8 bytes) : Variable to store the combo chain. Example Here is one example in hex: 25 0c 12 00 / 02 00 00 00 / 02 00 00 00 / 08 00 00 00 / 27 00 00 00 Which is interpreted as: getCombo((int)2, ((global)int *)giVar39) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970bd4(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar2 = 0; if (iVar3 != 0) { if (*piVar1 == 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x6bc); } else if (*piVar1 == 1) { *puVar2 = *(undefined4 *)(iVar3 + 0x6b8); } else { *puVar2 = *(undefined4 *)(iVar3 + 0x3eb0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcommandid.html": {
    "href": "getcommandid.html",
    "title": "getCommandId",
    "keywords": "getCommandId Gets currenly performing command ID. Code Information Name: getCommandId Scope: Global PAC Instruction (Binary): 25 0c 01 00 Assembly Address in Memory : 0x8970160 Parameters (int)Var0 (8 bytes) : Keep -1 to get the command ID. (int *)destination (8 bytes) : Variable to store the result, which can be command ID. If first parameter is less than zero (or greater than 8) and no command combo/fever is ongoing, the result value is -1. Example Here is one example in hex: 25 0c 01 00 / 02 00 00 00 / ff ff ff ff / 04 00 00 00 / 0b 00 00 00 Which is interpreted as: getCommandId((int)-1, (int *)iVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970160(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int *piVar4; undefined4 uVar5; int iVar6; int iVar7; int local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; iVar7 = 0; iVar3 = Get_Some_Flag(1); if (*(int *)(iVar3 + 0x44) == 0) { iVar3 = *(int *)(param_1 + 0x10); } else { local_4 = *(int *)(*(int *)(iVar3 + 0x44) + 0x28); if (DAT_08a71d4c < local_4) { piVar4 = &local_4; } else { piVar4 = &DAT_08a71d4c; } iVar7 = *piVar4; iVar3 = *(int *)(param_1 + 0x10); } iVar3 = *(int *)(iVar3 + 0x158); if (iVar3 != 0) { iVar6 = *piVar1; if (((iVar6 < 0) || (7 < iVar6)) || (iVar7 == iVar6)) { iVar3 = func_0x08b72c38(iVar3 + 500); if (iVar3 != 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x28); } } else { uVar5 = func_0x08b63690(iVar3 + 0x3c54); *puVar2 = uVar5; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcommandrate.html": {
    "href": "getcommandrate.html",
    "title": "getCommandRate",
    "keywords": "getCommandRate Gets how perfect the recent command was, as percent. 1/400 of getCommandScore. Code Information Name: getCommandRate Scope: Global PAC Instruction (Binary): 25 0c 03 00 Assembly Address in Memory : 0x8970320 Parameters (float *)destination (8 bytes) : Variable to store the command perfection rate. 1 is all perfect, 0 if command is not ongoing. Example Here is one example in hex: 25 0c 03 00 / 20 00 00 00 / 0a 00 00 00 Which is interpreted as: getCommandRate((float *)fVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970320(int param_1,undefined4 param_2) { float *pfVar1; int iVar2; uint uVar3; float *pfVar4; int iVar5; float fVar6; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); *pfVar1 = 0.0; iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if ((iVar5 != 0) && (iVar2 = func_0x08b72c38(iVar5 + 500), iVar2 != 0)) { uVar3 = *(uint *)(iVar5 + 0x6cc); if ((int)uVar3 < 0) { fVar6 = (float)(uVar3 >> 1 | uVar3 & 1); fVar6 = fVar6 + fVar6; } else { fVar6 = (float)uVar3; } *pfVar1 = fVar6 / 400.0; pfVar4 = pfVar1; if (DAT_08a71d50 <= fVar6 / 400.0) { pfVar4 = &DAT_08a71d50; } *pfVar1 = *pfVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcommandscore.html": {
    "href": "getcommandscore.html",
    "title": "getCommandScore",
    "keywords": "getCommandScore Gets how perfect the recent command was, as original score. 400 times bigger than the result of getCommandRate. Code Information Name: getCommandScore Scope: Global PAC Instruction (Binary): 25 0c 13 00 Assembly Address in Memory : 0x8970c80 Parameters (int *)destination (8 bytes) : Variable to store the command perfection score. 400 is all perfect, 0 if command is not ongoing. Remarks This is from Example Here is one example in hex: 25 0c 13 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getCommandScore((int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970c80(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar1 = 0; if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x6cc); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getcountdowntimerstatus.html": {
    "href": "getcountdowntimerstatus.html",
    "title": "getCountDownTimerStatus",
    "keywords": "getCountDownTimerStatus Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getCountDownTimerStatus Scope: Global PAC Instruction (Binary): 25 16 1c 01 Assembly Address in Memory : 0x892a044 Parameters (uint)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 16 1c 01 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: getCountDownTimerStatus((int *)iVar2, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a044(int param_1,undefined4 param_2) { uint *puVar1; uint *puVar2; int iVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar1 = 1; *puVar2 = 0; if ((((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x2c), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 100), iVar3 != 0)) { *puVar1 = (uint)*(byte *)(iVar3 + 0x1f2); *puVar2 = (uint)*(byte *)(iVar3 + 499); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdamagecount_gimmickuid.html": {
    "href": "getdamagecount_gimmickuid.html",
    "title": "getDamageCount_GimmickUID",
    "keywords": "getDamageCount_GimmickUID Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getDamageCount_GimmickUID Scope: Global PAC Instruction (Binary): 25 16 d2 00 Assembly Address in Memory : 0x8925c5c Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925c5c(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if ((iVar3 != 0) && (iVar3 = Get_Gimmick(iVar3,*puVar1), iVar3 != 0)) { *puVar2 = (uint)*(ushort *)(iVar3 + 0x19a); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdamagedeadflag.html": {
    "href": "getdamagedeadflag.html",
    "title": "getDamageDeadFlag",
    "keywords": "getDamageDeadFlag Checks if the target is dead (by direct damage and passive death like childe node death). Code Information Name: getDamageDeadFlag Scope: Global PAC Instruction (Binary): 25 17 5c 00 Assembly Address in Memory : 0x89179d4 Parameters (int *)handle (8 bytes) : The handle ID to check if the target is dead. (int *)is_dead (8 bytes) : 0 if the unit is alive. Otherwise target is dead. For checking if the target is dead, please check if this is zero or not. Example Here is one example in hex: 25 17 5c 00 / 04 00 00 00 / 40 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getDamageDeadFlag((int *)iVar64, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089179d4(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 0xcc); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = (uint)(*(byte *)(iVar3 + 0x12) | *(byte *)(iVar3 + 0x11)); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdeadcount.html": {
    "href": "getdeadcount.html",
    "title": "getDeadCount",
    "keywords": "getDeadCount Counts total dead amount of a team in VS. Reborn count rule based VS uses this. This counts total dead amount, not currently alive units. Code Information Name: getDeadCount Scope: Global PAC Instruction (Binary): 25 16 03 01 Assembly Address in Memory : 0x89281c0 Parameters (int)team (8 bytes) : 0 is blue side team, 1 is red side team. (int *)dead_count (8 bytes) : Variable to store total how many times in the team are dead. Example Here is one example in hex: 25 16 03 01 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getDeadCount((int)0, (int *)iVar0) This shows how reborn based VS determines the winning side: 00075BF0 25160301:getDeadCount(2:0, 4:0) 00075C04 25001900:cmd_ifLSE(4:0, 8:9E, 1:2A0) 00075C1C 25002700:cmd_flgSet(C66) 00075C28 25000100:cmd_end() 00075C2C 25160301:getDeadCount(2:1, 4:0) 00075C40 25001900:cmd_ifLSE(4:0, 8:9E, 1:2A0) 00075C58 25002700:cmd_flgSet(C67) 00075C64 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089281c0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } iVar3 = FUN_088a8650(iVar3,*puVar1); if (iVar3 != 0) { uVar4 = FUN_088e0e5c(iVar3); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdirection.html": {
    "href": "getdirection.html",
    "title": "getDirection",
    "keywords": "getDirection Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getDirection Scope: Global PAC Instruction (Binary): 25 17 5d 00 Assembly Address in Memory : 0x8917aac Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 5d 00 / 04 00 00 00 / 0a 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: getDirection((int *)iVar10, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917aac(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0x3f800000; if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x94); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdisablebeatguide.html": {
    "href": "getdisablebeatguide.html",
    "title": "getDisableBeatGuide",
    "keywords": "getDisableBeatGuide Gets wheether the flashing rhythm border is hidden. This does not read from system setting. Code Information Name: getDisableBeatGuide Scope: Global PAC Instruction (Binary): 25 0c 0b 00 Assembly Address in Memory : 0x8970838 Parameters (bool *)disabled_beat_guide (8 bytes) : Variable to store the result, 1 is disabled, 0 is enabled. Example Here is one example in hex: 25 0c 0b 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getDisableBeatGuide((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970838(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (*(int *)(*(int *)(param_1 + 0x10) + 0x158) != 0) { uVar2 = func_0x08b5f6d0(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdisableguide.html": {
    "href": "getdisableguide.html",
    "title": "getDisableGuide",
    "keywords": "getDisableGuide Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getDisableGuide Scope: Global PAC Instruction (Binary): 25 0c 21 00 Assembly Address in Memory : 0x897139c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0897139c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdisablehpgaugeview.html": {
    "href": "getdisablehpgaugeview.html",
    "title": "getDisableHpgaugeView",
    "keywords": "getDisableHpgaugeView Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getDisableHpgaugeView Scope: Global PAC Instruction (Binary): 25 16 9a 00 Assembly Address in Memory : 0x892254c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892254c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if ((*(int *)(param_1 + 0x10) != 0) && (*(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x44) != 0)) { uVar2 = func_0x08b32640(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdisablekey.html": {
    "href": "getdisablekey.html",
    "title": "getDisableKey",
    "keywords": "getDisableKey Gets if the key input is disabled through setDisableKey. Code Information Name: getDisableKey Scope: Global PAC Instruction (Binary): 25 0c 09 00 Assembly Address in Memory : 0x8970730 Parameters (int *)destination (8 bytes) : Variable to store whether the key is disabled or not, please describe what 0 and 1 means. Example Here is one example in hex: 25 0c 09 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getDisableKey((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970730(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x3f6c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdisablepercussionflag.html": {
    "href": "getdisablepercussionflag.html",
    "title": "getDisablePercussionFlag",
    "keywords": "getDisablePercussionFlag Gets if the specific drum is disabled or or all drums are disabled. Code Information Name: getDisablePercussionFlag Scope: Global PAC Instruction (Binary): 25 0c 1a 00 Assembly Address in Memory : 0x8970fc0 Parameters (int)drum_id (8 bytes) : Drum ID to check if the drum is enabled or disabled. 0 checks if every drum is disabled. (int *)disabled (8 bytes) : Variable to store if the drum is enabled or not. Stores 1 if disabled, otherwise saves 0. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970fc0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = func_0x08b5f990(*puVar1); *puVar2 = uVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getdisablepercussionview.html": {
    "href": "getdisablepercussionview.html",
    "title": "getDisablePercussionView",
    "keywords": "getDisablePercussionView Gets if the drum hit icon visualising is enabled or disbaled. Works only when drum view is enabled in system setting. Code Information Name: getDisablePercussionView Scope: Global PAC Instruction (Binary): 25 0c 1d 00 Assembly Address in Memory : 0x8971140 Parameters (int)drum_id (8 bytes) : Drum ID to check if the visualising is enabled or disabled. 0 checks if every drum visualising is disabled. (int *)disabled (8 bytes) : Variable to store if the drum hit is visualised or not. Stores 1 if visualising is disabled, otherwise saves 0. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08971140(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar4 != 0) { uVar3 = func_0x08b5f738(iVar4,*puVar1); *puVar2 = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getenablepad.html": {
    "href": "getenablepad.html",
    "title": "getEnablePad",
    "keywords": "getEnablePad Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getEnablePad Scope: Azito PAC Instruction (Binary): 25 1c 25 00 Assembly Address in Memory : 0x8b4fd40 Parameters (uint)Var0 (8 bytes) Example Here is one example in hex: 25 1c 25 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getEnablePad((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fd40(int param_1,undefined4 param_2) { uint *puVar1; int iVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x14); if (iVar2 != 0) { *puVar1 = (uint)*(byte *)(iVar2 + 0x60); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getequipitemparam.html": {
    "href": "getequipitemparam.html",
    "title": "getEquipItemParam",
    "keywords": "getEquipItemParam Gets itemparam item information by the equipment slot index. Code Information Name: getEquipItemParam Scope: Global PAC Instruction (Binary): 25 0a 49 00 Assembly Address in Memory : 0x894d77c Parameters (int)inventory_index (8 bytes) : Equipment inventory slot index. (int *)itemparam_data02 (8 bytes) : Variable to store something, please describe. Usually zero. (int *)weaponparam_id (8 bytes) : Variable to store the weaponparam ID. (int *)equip_level (8 bytes) :Variable to store the level of the equipment. (int *)enchant_id (8 bytes) : Variable to store the enchant of the equipment. Example Here is one example in hex: 25 0a 49 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 04 00 00 00 Which is interpreted as: getEquipItemParam((int *)iVar5, (int *)iVar1, (int *)iVar2, (int *)iVar3, , (int *)iVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d77c(int param_1,undefined4 param_2) { short sVar1; int *piVar2; int *piVar3; int *piVar4; undefined4 *puVar5; int *piVar6; int iVar7; undefined4 uVar8; int iVar9; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); piVar3 = (int *)Pac_Get_Param(param_2,0,1,4); piVar4 = (int *)Pac_Get_Param(param_2,1,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar6 = (int *)Pac_Get_Param(param_2,3,1,4); *piVar3 = -1; *piVar4 = -1; *puVar5 = 0xffffffff; *piVar6 = -1; if (-1 < *piVar2) { iVar7 = Equipment::Get_Eqslot_Addr_Wrapper (*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34), *piVar2); sVar1 = *(short *)(iVar7 + 2); uVar8 = Save::Get_Save_BaseAddr(1); iVar9 = Save::Get_BaseAddr__0x78(uVar8,1); uVar8 = Param::Get_Data_Addr(*(undefined4 *)(iVar9 + 0xa4),9); iVar9 = Param::Get_Line_Addr(uVar8,0,(int)sVar1,1); *piVar3 = (int)*(short *)(iVar7 + 2); *piVar4 = (int)*(short *)(iVar9 + 6); uVar8 = Equip::Return_Eq_Level(iVar7); *puVar5 = uVar8; *piVar6 = (int)*(char *)(iVar9 + 0xe); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getequipsummontype.html": {
    "href": "getequipsummontype.html",
    "title": "getEquipSummonType",
    "keywords": "getEquipSummonType Gets equipped summon from a specific (blue or red) side. Code Information Name: getEquipSummonType Scope: Global PAC Instruction (Binary): 25 0c 2c 00 Assembly Address in Memory : 0x89718f4 Parameters (int)team (8 bytes) : 0 is blue team, 1 is red team. (int *)destination (8 bytes) : Address to store the summon ID. Example Here is one example in hex: 25 0c 2c 00 / 04 00 00 00 / 0a 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getEquipSummonType((int *)iVar10, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089718f4(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = *(undefined4 *)(&Summon_Type + *piVar1 * 4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getethnicid.html": {
    "href": "getethnicid.html",
    "title": "getEthnicId",
    "keywords": "getEthnicId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getEthnicId Scope: Global PAC Instruction (Binary): 25 16 3f 00 Assembly Address in Memory : 0x891d9e4 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 3f 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getEthnicId((int *)iVar65, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d9e4(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = -1; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 == 0) || (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 != 3)) { iVar4 = 0; if ((iVar3 != 0) && (iVar5 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar5 == 9)) { iVar4 = iVar3; } } else { iVar4 = *(int *)(iVar3 + 0x490); } if ((iVar4 != 0) && (*(int *)(iVar4 + 0x870) != 0)) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0x870) + 0x18); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "geteventunitcharabaseparamindexid.html": {
    "href": "geteventunitcharabaseparamindexid.html",
    "title": "getEventUnitCharaBaseParamIndexId",
    "keywords": "getEventUnitCharaBaseParamIndexId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getEventUnitCharaBaseParamIndexId Scope: Azito PAC Instruction (Binary): 25 1c 33 00 Assembly Address in Memory : 0x8b507b8 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 1c 33 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getEventUnitCharaBaseParamIndexId((int *)iVar0, (int)0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b507b8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar4 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar2 = 0; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 != 0) { if (*piVar1 == 0) { iVar3 = *(int *)(iVar3 + 0x1c4) + 0x2d0; } else { iVar3 = *(int *)(iVar3 + 0x1c4) + 0x2b20; } iVar3 = iVar4 * 0x500 + iVar3; if (((iVar3 != -0x20) && (piVar1 = (int *)(iVar3 + 0x30), piVar1 != (int *)0x0)) && (iVar3 = *piVar1, iVar3 != 0)) { *piVar2 = (int)*(short *)(*(int *)(iVar3 + 0x870) + 0x10); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "geteventunitdefaultpriority.html": {
    "href": "geteventunitdefaultpriority.html",
    "title": "getEventUnitDefaultPriority",
    "keywords": "getEventUnitDefaultPriority Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getEventUnitDefaultPriority Scope: Azito PAC Instruction (Binary): 25 1c 32 00 Assembly Address in Memory : 0x8b506c0 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 1c 32 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getEventUnitDefaultPriority((int *)iVar1, (int)0, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b506c0(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar2; puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0; iVar4 = *(int *)(param_1 + 0x10); if (iVar4 != 0) { if (*piVar1 == 0) { iVar4 = *(int *)(iVar4 + 0x1c4) + 0x2d0; } else { iVar4 = *(int *)(iVar4 + 0x1c4) + 0x2b20; } iVar4 = iVar5 * 0x500 + iVar4; if (((iVar4 != -0x20) && (piVar1 = (int *)(iVar4 + 0x30), piVar1 != (int *)0x0)) && (iVar4 = *piVar1, iVar4 != 0)) { *puVar3 = *(undefined4 *)(*(int *)(iVar4 + 0x870) + 0x1c); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "geteventunithandle.html": {
    "href": "geteventunithandle.html",
    "title": "getEventUnitHandle",
    "keywords": "getEventUnitHandle Gets handle of the non-multi units (Hero, Ton, Chin, Kan) in the hideout. Code Information Name: getEventUnitHandle Scope: Azito PAC Instruction (Binary): 25 1c 0e 00 Assembly Address in Memory : 0x8b4dec8 Parameters (int *)destination (8 bytes) : Destination to save the unit handle. (int)Var1 (8 bytes) : Event Unit ID. 0 is Hero, 1 is Ton, 2 is Chin, 3 is Kan. Hideout won't load with the other value. (uint *)destination2 (8 bytes) Example Here is one example in hex: 25 1c 0e 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 3f 00 00 00 Which is interpreted as: getEventUnitHandle((int *)iVar0, (int)1, (int *)iVar63) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4dec8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; uint *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar2; puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); *piVar1 = -1; *puVar3 = 0; if ((((*(int *)(param_1 + 0x10) != 0) && (iVar5 = iVar5 * 0x500 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4), iVar5 != -0x2f0)) && ((int *)(iVar5 + 0x300) != (int *)0x0)) && (iVar4 = *(int *)(iVar5 + 0x300), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); *puVar3 = (uint)*(byte *)(iVar5 + 0x688); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfacilitygimmickhandle.html": {
    "href": "getfacilitygimmickhandle.html",
    "title": "getFacilityGimmickHandle",
    "keywords": "getFacilityGimmickHandle Gets Gimmick handle from a specific hideout gimmick ID. Code Information Name: getFacilityGimmickHandle Scope: Azito PAC Instruction (Binary): 25 1c 09 00 Assembly Address in Memory : 0x8b4da48 Parameters (int *)destination (8 bytes) : Variable to store the facility gimmick handle. (int)facilitygimmick_id (8 bytes) : ID of the facility gimmick. Example Here is one example in hex: 25 1c 09 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getFacilityGimmickHandle((int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4da48(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*piVar2 * 0x10 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x1e0), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x148), iVar3 != 0)) { *piVar1 = (int)*(short *)(iVar3 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfacilityhandle.html": {
    "href": "getfacilityhandle.html",
    "title": "getFacilityHandle",
    "keywords": "getFacilityHandle Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getFacilityHandle Scope: Azito PAC Instruction (Binary): 25 1c 08 00 Assembly Address in Memory : 0x8b4d998 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d998(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*piVar2 * 0x10 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x1e0), iVar3 != 0)) { iVar3 = (int)*(short *)(iVar3 + 0x78); *piVar1 = iVar3; Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x194),iVar3,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfacilityinfo.html": {
    "href": "getfacilityinfo.html",
    "title": "getFacilityInfo",
    "keywords": "getFacilityInfo Gets certain information of a selectable hideout gimmick(facility). Code Information Name: getFacilityInfo Scope: Azito PAC Instruction (Binary): 25 1c 0c 00 Assembly Address in Memory : 0x8b4dc50 Parameters (int)facility_type (8 bytes) : Facility ID. (int)info_type (8 bytes) : Range of 0~4. (uint *)destination (8 bytes) : Variable to store the result. info_type meaning 0 Facility ID 1 facility gimmick handle 2 1 enables selection, let this 1 and editing 4 is preferred 3 1 enables interaction (action on X) 4 1 can be selected Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4dc50(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar4 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *piVar1; puVar2 = (uint *)Pac_Get_Param(param_2,2,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar4 = *(int *)(iVar4 * 0x10 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x1e0), iVar4 != 0)) { if (iVar3 == 4) { *puVar2 = (uint)*(byte *)(iVar4 + 0x142); } else if (iVar3 == 3) { *puVar2 = (uint)*(byte *)(iVar4 + 0x141); } else if (iVar3 == 2) { *puVar2 = (uint)*(byte *)(iVar4 + 0x9c); } else if (iVar3 == 1) { if (*(int *)(iVar4 + 0x148) != 0) { *puVar2 = (int)*(short *)(*(int *)(iVar4 + 0x148) + 0x78); } } else if (iVar3 == 0) { *puVar2 = (int)*(short *)(iVar4 + 0x78); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfadecolor.html": {
    "href": "getfadecolor.html",
    "title": "getFadeColor",
    "keywords": "getFadeColor Gets colour of the fading screen. Code Information Name: getFadeColor Scope: Global PAC Instruction (Binary): 25 16 88 00 Assembly Address in Memory : 0x892186c Parameters (float *)red (8 bytes) : Red value of the fading screen. (float *)green (8 bytes) : Green Value value of the fading screen. (float *)blue (8 bytes) : Blue value of the fading screen. (float *)alpha (8 bytes) : Alpha of the fading screen. Example Here is one example in hex: 25 16 88 00 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 03 00 00 00 / 20 00 00 00 / 04 00 00 00 Which is interpreted as: getFadeColor((float *)fVar1, (float *)fVar2, (float *)fVar3, (float *)fVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892186c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); *puVar1 = 0; *puVar2 = 0; *puVar3 = 0; *puVar4 = 0; if (*(int *)(param_1 + 0x10) != 0) { FUN_08992538(&local_10,*(undefined4 *)(*(int *)(param_1 + 0x10) + 200)); *puVar1 = local_10; *puVar2 = local_c; *puVar3 = local_8; *puVar4 = local_4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfaderate.html": {
    "href": "getfaderate.html",
    "title": "getFadeRate",
    "keywords": "getFadeRate Gets fading progress status. Used with startFade, useful with arranging change smoothly between scenes. Code Information Name: getFadeRate Scope: Global PAC Instruction (Binary): 25 16 87 00 Assembly Address in Memory : 0x89217f8 Parameters (float *)progress (8 bytes) : Variable to store the fading progress, 0 is just started used startFade and 1 is done with the fading animation. Note that the fading screen is not always 0 or 1, it is decided by the startFade. Example Here is one example in hex: 25 16 87 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getFadeRate((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089217f8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (*(int *)(param_1 + 0x10) != 0) { uVar2 = FUN_08992530(*(undefined4 *)(*(int *)(param_1 + 0x10) + 200)); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfevergaugepriority.html": {
    "href": "getfevergaugepriority.html",
    "title": "getFeverGaugePriority",
    "keywords": "getFeverGaugePriority Gets how top the fever gauge should be (render priority). Code Information Name: getFeverGaugePriority Scope: Global PAC Instruction (Binary): 25 0c 2b 00 Assembly Address in Memory : 0x8971874 Parameters (int *)priority (8 bytes) : Variable to store the fever gauge priority (how top it is). Example Here is one example in hex: 25 0c 2b 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getFeverGaugePriority((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08971874(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar1 = 0; if ((iVar3 != 0) && (iVar3 = *(int *)(iVar3 + 0x3f28), iVar3 != 0)) { uVar2 = (**(code **)(*(int *)(iVar3 + 0x1c) + 0x10))(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getflipenable.html": {
    "href": "getflipenable.html",
    "title": "getFlipEnable",
    "keywords": "getFlipEnable Gets the \"flip\" value, set from flipEnable. For player, works only cutscene with player model index 1. For bosses, it works. Code Information Name: getFlipEnable Scope: Global PAC Instruction (Binary): 25 17 0f 00 Assembly Address in Memory : 0x8911b74 Parameters (int *)handle (8 bytes) : Handle of the target. (int *)destination (8 bytes) : Variable to store the flip value. 0 is normal direction (unit sees right), 1 the unit sees left. This is not real flipping in e.g. dungeon, might not work properly. Example Here is one example in hex: 25 17 0f 00 / 04 00 00 00 / 16 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getFlipEnable((int *)iVar22, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911b74(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = 0.0 < *(float *)(iVar3 + 0x94) ^ 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfoglevel.html": {
    "href": "getfoglevel.html",
    "title": "getFogLevel",
    "keywords": "getFogLevel Gets how foggy the weather is in the world. Code Information Name: getFogLevel Scope: Global PAC Instruction (Binary): 25 16 81 00 Assembly Address in Memory : 0x8921360 Parameters (float *)fog_level (8 bytes) : Variable to store the fog level. 0 is no fog, 1 is maximum fog. Example Here is one example in hex: 25 16 81 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getFogLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921360(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x254); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getforwardmissile.html": {
    "href": "getforwardmissile.html",
    "title": "getForwardMissile",
    "keywords": "getForwardMissile Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getForwardMissile Scope: Global PAC Instruction (Binary): 25 16 17 01 Assembly Address in Memory : 0x89299bc Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (float)Var2 (8 bytes) Example Here is one example in hex: 25 16 17 01 / 08 00 00 00 / 65 00 00 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getForwardMissile(((global)int *)giVar101, (int *)iVar0, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089299bc(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; float *pfVar3; int *piVar4; int iVar5; int iVar6; uint uVar7; uint *puVar8; int iVar9; int iVar10; int iVar11; float fVar12; float fVar13; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); *piVar2 = -1; *pfVar3 = 0.0; if (*piVar1 == 0) { iVar11 = 0; } else { iVar11 = 1; if (*piVar1 != 1) { iVar11 = 4; } } if ((iVar11 != 4) && (iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x108), iVar6 != 0)) { puVar8 = *(uint **)(iVar6 + 0x1334); fVar13 = -1.0; iVar10 = -1; if ((*(uint *)(iVar6 + 0x1338) ^ puVar8[2] | *(uint *)(iVar6 + 0x1330) ^ *puVar8 | *(uint *)(iVar6 + 0x1334) ^ puVar8[1]) != 0) { piVar4 = (int *)puVar8[2]; while( true ) { iVar9 = *piVar4; if ((((((iVar9 != 0) && (*(char *)(iVar9 + 0x9c) != '\\0')) && (*piVar1 == (int)*(char *)(iVar9 + 0x98))) && ((*(char *)(iVar9 + 0x98) != 4 && (*(int *)(iVar9 + 0x20c) != 0)))) && ((iVar5 = *(int *)(*(int *)(iVar9 + 0x20c) + 0x14), iVar5 != 0 && (((iVar5 = *(int *)(iVar5 + 0x18), iVar5 == 0x220 || (iVar5 == 0x221)) || (iVar5 == 0x21e)))))) && (iVar5 = FUN_088ce294(iVar9,0), iVar5 != 0)) { fVar12 = *(float *)(*(int *)(iVar9 + 200) + 0xc0); if (iVar10 == -1) { iVar10 = (int)*(short *)(iVar9 + 0x78); fVar13 = fVar12; } else if (iVar11 == 0) { if (fVar13 < fVar12) { iVar10 = (int)*(short *)(iVar9 + 0x78); fVar13 = fVar12; } } else if (fVar12 < fVar13) { iVar10 = (int)*(short *)(iVar9 + 0x78); fVar13 = fVar12; } } if (puVar8 == (uint *)0x0) { uVar7 = *(uint *)(iVar6 + 0x1334); } else { puVar8 = (uint *)puVar8[1]; uVar7 = *(uint *)(iVar6 + 0x1334); } if ((*(uint *)(iVar6 + 0x1338) ^ puVar8[2] | *(uint *)(iVar6 + 0x1330) ^ *puVar8 | uVar7 ^ puVar8[1]) == 0) break; piVar4 = (int *)puVar8[2]; } } *piVar2 = iVar10; *pfVar3 = fVar13; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getfrontlineposition.html": {
    "href": "getfrontlineposition.html",
    "title": "getFrontLinePosition",
    "keywords": "getFrontLinePosition Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getFrontLinePosition Scope: Global PAC Instruction (Binary): 25 16 f4 00 Assembly Address in Memory : 0x8926f90 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 f4 00 / 04 00 00 00 / 01 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: getFrontLinePosition((int *)iVar1, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926f90(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = FUN_088a8650(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xf8),*puVar1); if (iVar3 != -0x170) { *puVar2 = *(undefined4 *)(iVar3 + 0x354); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgamemode.html": {
    "href": "getgamemode.html",
    "title": "getGameMode",
    "keywords": "getGameMode Reads mission type. Code Information Name: getGameMode Scope: Global PAC Instruction (Binary): 25 0a 1c 00 Assembly Address in Memory : 0x894b1a4 Parameters (int *)mission_type (8 bytes) : Variable to store the mission type. ID Mission Is Multi 0x1 Field/Dungeon No 0x2 VS No 0x3 Field/Dungeon Yes 0x4 VS Yes 0x5 ??? Yes Example Here is one example in hex: 25 0a 1c 00 / 08 00 00 00 / 18 00 00 00 Which is interpreted as: getGameMode(((global)int *)giVar24) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b1a4(undefined4 param_1,undefined4 param_2) { int iVar1; undefined4 *puVar2; iVar1 = Get_Some_Flag(1); iVar1 = *(int *)(iVar1 + 0x44); puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar2 = *(undefined4 *)(iVar1 + 0x530); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgateinfo.html": {
    "href": "getgateinfo.html",
    "title": "getGateInfo",
    "keywords": "getGateInfo Gets detail gate information given by setGateInfo. Code Information Name: getGateInfo Scope: Global PAC Instruction (Binary): 25 16 be 00 Assembly Address in Memory : 0x8923ce0 Parameters (bool)bind_type (8 bytes) : 0 has many types of binds, 1 will be connected to only param_index 2 (int)bind_identifier (8 bytes) : bind_identifier from setupAddDungeonWall. (int)param_index (8 bytes) : Index of the parameter, see below for the detail. (int *)destination (8 bytes) : Variable to store the result. The result depends on param_index, see below. For detail of each parameter, see setGateInfo. Example Here is one example in hex: 25 16 be 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 47 00 00 00 / 02 00 00 00 / 06 00 00 00 / 04 00 00 00 / 0a 00 00 00 Which is interpreted as: getGateInfo((int)0, ((global)int *)giVar71, (int)6, (int *)iVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923ce0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; undefined4 *puVar4; int iVar5; undefined4 uVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar6 = *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118); if (*piVar1 == 0) { iVar5 = FUN_088b25fc(uVar6,*puVar2); } else { iVar5 = FUN_088b2648(uVar6,*puVar2); } if (iVar5 != 0) { *puVar4 = *(undefined4 *)(iVar5 + *piVar3 * 4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgeneratorinfo.html": {
    "href": "getgeneratorinfo.html",
    "title": "getGeneratorInfo",
    "keywords": "getGeneratorInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getGeneratorInfo Scope: Global PAC Instruction (Binary): 25 16 db 00 Assembly Address in Memory : 0x892643c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 16 db 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getGeneratorInfo((int *)iVar20, (int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892643c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar2 = 0xffffffff; *puVar3 = 0xffffffff; iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) { *puVar2 = *(undefined4 *)(iVar4 + 0x1dc); *puVar3 = *(undefined4 *)(iVar4 + 0x1e0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgfpdata.html": {
    "href": "getgfpdata.html",
    "title": "getGfpData",
    "keywords": "getGfpData Gets data from the itemparam, either weaponparam ID or base Ka-ching requirement for blacksmith. Code Information Name: getGfpData Scope: Global PAC Instruction (Binary): 25 0a 07 00 Assembly Address in Memory : 0x8949ad4 Parameters (int *)destination (8 bytes) : Variable to store the result value (weaponparam ID or blacksmith ka-ching). (int)must_be_9 (8 bytes) : Param file ID, but only 9 (itemparam) works. Must be 9 to be functional. (int)must_be_0 (8 bytes) : Should be section index, Keep 0 to make functional. (int)item_id (8 bytes) : Item ID to get the data. (bool)type (8 bytes) : 1 gives weaponparam ID as result, 0 gives base Ka-ching requirement for Blacksmith as result. Example Here is one example in hex: 25 0a 07 00 / 04 00 00 00 / 05 00 00 00 / 02 00 00 00 / 09 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: getGfpData((int *)iVar5, (int)9, (int)0, (int *)iVar3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949ad4(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; int iVar6; undefined4 uVar7; int iVar8; int iVar9; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar9 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,2,1,4); iVar8 = *piVar2; puVar3 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar7 = *puVar3; piVar2 = (int *)Pac_Get_Param(param_2,4,1,4); iVar6 = *piVar2; uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); iVar5 = Param::Get_Data_Addr(*(undefined4 *)(iVar5 + 0xa4),iVar9); if ((((*(int *)(iVar5 + 8) != 0) && (iVar5 = Param::Get_Line_Addr(iVar5,iVar8,uVar7,1), iVar5 != 0)) && (iVar9 == 9)) && (iVar8 == 0)) { if (iVar6 == 1) { *piVar1 = (int)*(short *)(iVar5 + 6); } else if (iVar6 == 0) { *piVar1 = (int)*(short *)(iVar5 + 0xc); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgimmickid.html": {
    "href": "getgimmickid.html",
    "title": "getGimmickId",
    "keywords": "getGimmickId Gets Gimmick ID in gimmickparam by given handle. Code Information Name: getGimmickId Scope: Global PAC Instruction (Binary): 25 19 16 00 Assembly Address in Memory : 0x894242c Parameters (int *)handle_id (8 bytes) : Handle of the gimmick, from e.g. gimmick_getHandle. (int *)gimmick_id (8 bytes) : Variable to store the Gimmick ID. Example Here is one example in hex: 25 19 16 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getGimmickId((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894242c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } *puVar2 = 0; if (iVar3 != 0) { *puVar2 = *(undefined4 *)(*(int *)(*(int *)(iVar3 + 0x20c) + 0x14) + 0x18); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgimmickpowergaugepoint.html": {
    "href": "getgimmickpowergaugepoint.html",
    "title": "getGimmickPowerGaugePoint",
    "keywords": "getGimmickPowerGaugePoint Gets occupation status of a gimmick in head-on VS. Code Information Name: getGimmickPowerGaugePoint Scope: Global PAC Instruction (Binary): 25 16 13 00 Assembly Address in Memory : 0x891a418 Parameters (int *)handle_id (8 bytes) : Giimmick handle of the fort. (int)team_side (8 bytes) : Team to get, 0 is blue team and 1 is red team. (float *)occupation (8 bytes) : Variable to store the occupation percentage. (uint *)troopside_flag (8 bytes) : Variable to store the flag of the troop side, 0x1 blue, 0x10 red. Example Here is one example in hex: 25 16 13 00 / 08 00 00 00 / 7f 00 00 00 / 02 00 00 00 / 01 00 00 00 / 20 00 00 00 / 00 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getGimmickPowerGaugePoint(((global)int *)giVar127, (int)1, (float *)fVar0, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a418(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; uint *puVar4; int iVar5; int iVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (uint *)Pac_Get_Param(param_2,3,1,4); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); *puVar3 = 0; *puVar4 = 0; if ((((iVar5 != 0) && (iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5), iVar6 == 10)) && (*(int *)(param_1 + 0x10) != 0)) && (iVar5 = func_0x08b30450(*(undefined4 *) (*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x4c), iVar5), iVar5 != 0)) { iVar6 = *piVar2; uVar7 = func_0x08b29890(iVar5,iVar6); *puVar3 = uVar7; iVar5 = iVar6 * 0x10 + iVar5; *puVar4 = *(uint *)(iVar5 + 0x3c) | *(uint *)(iVar5 + 0x40); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getgroupid.html": {
    "href": "getgroupid.html",
    "title": "getGroupId",
    "keywords": "getGroupId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getGroupId Scope: Global PAC Instruction (Binary): 25 10 0a 00 Assembly Address in Memory : 0x890a2e0 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 10 0a 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getGroupId((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a2e0(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0xffffffff; if (*(int *)(param_1 + 0x10) != 0) { *puVar1 = *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x4fc); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gethandle.html": {
    "href": "gethandle.html",
    "title": "getHandle",
    "keywords": "getHandle Gets handle of the whole generator. Code Information Name: getHandle Scope: Mission PAC Instruction (Binary): 25 1f 15 00 Assembly Address in Memory : 0x8b5d9c8 Parameters (int)generator_identifier (8 bytes) : Identifier of the generator, 2nd parameter of create. (int *)destination (8 bytes) : Variable to store the generator handle. Example Here is one example in hex: 25 1f 15 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 1a 00 00 00 Which is interpreted as: getHandle((int)0, ((global)int *)giVar26) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d9c8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0x2c8); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 == 0) { *puVar2 = 0xffffffff; } else { uVar4 = Get_Generator_HandleID(iVar3,*puVar1); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gethataponhandle.html": {
    "href": "gethataponhandle.html",
    "title": "getHataPonHandle",
    "keywords": "getHataPonHandle Gets handle of the Hatapon. Code Information Name: getHataPonHandle Scope: Global PAC Instruction (Binary): 25 16 35 00 Assembly Address in Memory : 0x891ced8 Parameters (int *)destination (8 bytes) : Destination to save the Hatapon handle. Remarks This can be also done with getPlayerSquadHandle (Unit ID 5) and getUnitHandle. Example Here is one example in hex: 25 16 35 00 / 08 00 00 00 / 1f 00 00 00 Which is interpreted as: getHataPonHandle(((global)int *)giVar31) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ced8(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); *piVar1 = -1; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0xf8); if (iVar2 == 0) { iVar2 = 0; } } if (((iVar2 != 0) && (iVar2 = FUN_088a8650(iVar2,0), iVar2 != 0)) && (iVar2 = Get_HataponAddr(iVar2), iVar2 != 0)) { *piVar1 = (int)*(short *)(iVar2 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getherocount.html": {
    "href": "getherocount.html",
    "title": "getHeroCount",
    "keywords": "getHeroCount Gets how many heroes are in the player troop. Code Information Name: getHeroCount Scope: Global PAC Instruction (Binary): 25 0c 14 00 Assembly Address in Memory : 0x8970ce4 Parameters (int *)destination (8 bytes) : Variable to store how many heroes are in the player troop. Example Here is one example in hex: 25 0c 14 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: getHeroCount((int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970ce4(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar1 = 0; if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x6dc); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gethitpercussion.html": {
    "href": "gethitpercussion.html",
    "title": "getHitPercussion",
    "keywords": "getHitPercussion Checks if any drum is pressed. Code Information Name: getHitPercussion Scope: Global PAC Instruction (Binary): 25 0c 04 00 Assembly Address in Memory : 0x8970404 Parameters (int *)drum_id (8 bytes) : Variable to store the drum ID. 0 if no drum is pressed. Example Here is one example in hex: 25 0c 04 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getHitPercussion((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970404(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); *piVar1 = 0; if (*(int *)(*(int *)(param_1 + 0x10) + 0x158) != 0) { piVar2 = (int *)func_0x08b5f810(); if ((0 < *piVar2) && (piVar2[3] != 4)) { *piVar1 = *piVar2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gethitrate.html": {
    "href": "gethitrate.html",
    "title": "getHitRate",
    "keywords": "getHitRate Saves how perfect the drum hit was. Code Information Name: getHitRate Scope: Global PAC Instruction (Binary): 25 0c 02 00 Assembly Address in Memory : 0x8970288 Parameters (float *)destination (8 bytes) : Variable to store how the perfect the drum hit was. 0 is no hit at all, 1 is perfect hit. Example Here is one example in hex: 25 0c 02 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getHitRate((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970288(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); *piVar1 = 0; if (((*(int *)(*(int *)(param_1 + 0x10) + 0x158) != 0) && (piVar2 = (int *)func_0x08b5f810(), 0 < *piVar2)) && (piVar2[3] != 4)) { *piVar1 = piVar2[5]; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getid.html": {
    "href": "getid.html",
    "title": "getId",
    "keywords": "getId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getId Scope: Global PAC Instruction (Binary): 25 20 05 00 Assembly Address in Memory : 0x89b0f6c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 20 05 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getId((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b0f6c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x14) != 0) { uVar2 = FUN_0898e324(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getitem_250a0b00.html": {
    "href": "getitem_250a0b00.html",
    "title": "getItem (250a0b00)",
    "keywords": "getItem (250a0b00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getItem Scope: Global PAC Instruction (Binary): 25 0a 0b 00 Assembly Address in Memory : 0x8949ef4 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 0a 0b 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getItem((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949ef4(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; short *psVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = 0; iVar4 = *(int *)(param_1 + 0x10); if (iVar4 != 0) { if (*piVar1 == 0x32) { iVar4 = FUN_089457e4(*(undefined4 *)(*(int *)(iVar4 + 0x374) + 0x34)); *piVar2 = iVar4; } else { psVar3 = (short *)FUN_0894554c(*(undefined4 *)(*(int *)(iVar4 + 0x374) + 0x34)); *piVar2 = (int)*psVar3; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getitem_25166300.html": {
    "href": "getitem_25166300.html",
    "title": "getItem (25166300)",
    "keywords": "getItem (25166300) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getItem Scope: Global PAC Instruction (Binary): 25 16 63 00 Assembly Address in Memory : 0x8920374 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 63 00 / 02 00 00 00 / 31 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getItem((int)49, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920374(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = FUN_089656e4(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 100),*puVar1); *puVar2 = uVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getkillorderflag.html": {
    "href": "getkillorderflag.html",
    "title": "getKillOrderFlag",
    "keywords": "getKillOrderFlag Gets if the unit is killed without taking direct damage, such as kill or child node kill (not from direct damage calculation). Code Information Name: getKillOrderFlag Scope: Global PAC Instruction (Binary): 25 17 59 00 Assembly Address in Memory : 0x8917718 Parameters (int *)handle (8 bytes) : Handle of the target. (int *)kill_order (8 bytes) : Variable to store the result. For checking if the target is dead indirectly, please check if this is zero or not. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917718(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 0xcc); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = (uint)*(byte *)(iVar3 + 0x11); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getlaboinfo.html": {
    "href": "getlaboinfo.html",
    "title": "getLaboInfo",
    "keywords": "getLaboInfo Gets certain types of information. See also: setLaboInfo Code Information Name: getLaboInfo Scope: Global PAC Instruction (Binary): 25 0a 05 00 Assembly Address in Memory : 0x89497ec Parameters (int)labo_type (8 bytes) : The \"labo type\" to get the value, see below. (int *)destination (8 bytes) : Variable to store the value, expected boolean. Id Value 0 Value 1 0x1 hideout closed multi 0x2 multi guest multi host/hideout closed 0x3 Not Mission Complete Mission Complete 0x4 Mission not Completed and March disabled (in multi) Mission Completed or March enabled (in multi) 0x5 unused unused 0x6 unused unused 0x7 Not connected or connecting Fully connected in multi 0x8 unused unused 0x9 Uberhero Dark hero 0xA ??? ??? 0xB Unused Unused Example Here is one example in hex: 25 0a 05 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getLaboInfo((int)1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089497ec(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 uVar3; int iVar4; uint uVar5; undefined4 uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar6 = *puVar1; puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { Save::Get_Save_BaseAddr(1); uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); iVar4 = *(int *)(iVar4 + 0x44); switch(uVar6) { case 1: *puVar2 = (uint)*(byte *)(iVar4 + 0x24); break; case 2: *puVar2 = (uint)*(byte *)(iVar4 + 0x25); break; case 3: *puVar2 = (uint)*(byte *)(iVar4 + 0x81c); break; case 4: if (*(char *)(iVar4 + 0x81c) == '\\0') { *puVar2 = 1; } else if (*(int *)(iVar4 + 0x28) == 0) { *puVar2 = 1; } else { *puVar2 = 0; } break; case 5: *puVar2 = (uint)*(byte *)(iVar4 + 0x3c); break; case 6: *puVar2 = (uint)*(byte *)(iVar4 + 0x3d); break; case 7: *puVar2 = (uint)*(byte *)(iVar4 + 0x26); break; case 8: *puVar2 = (uint)*(byte *)(iVar4 + 0x3e); break; case 9: iVar4 = Save::Get_Save_BaseAddr(1); iVar4 = return__0x285a8(*(undefined4 *)(iVar4 + 0x50)); *puVar2 = *(uint *)(iVar4 + 0x11b4); break; case 10: uVar6 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar6,1); *puVar2 = (uint)(*(int *)(*(int *)(iVar4 + 100) + 0x98) != 0); break; case 0xb: uVar6 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar6,1); uVar5 = (uint)(*(char *)(*(int *)(iVar4 + 0x94) + 0x3d8) != '\\0'); if (uVar5 != 0) { uVar5 = (uint)(*(int *)(*(int *)(iVar4 + 0x94) + 0x3f0) != 0); } *puVar2 = uVar5; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getlevelupinfo.html": {
    "href": "getlevelupinfo.html",
    "title": "getLevelUpInfo",
    "keywords": "getLevelUpInfo Gets blacksmith level-up related data from currently selected equipment. Code Information Name: getLevelUpInfo Scope: Azito PAC Instruction (Binary): 25 1c 1c 00 Assembly Address in Memory : 0x8b4f4e8 Parameters (int)unknown (8 bytes) : Unused, can keep 0. (int *)item_id (8 bytes) : Variable to store the item ID. (int *)level (8 bytes) : Variable to store the equipment level, used for requirement calculation (int *)section_id (8 bytes) : Variable to store the Section ID of the levelupparam. 0 is equipment section and 1 is material section. (int *)equipment_type (8 bytes) : Variable to store the equipment group, from levelupparam+0x40, works only with individual equipment section. (int *)Var4 (8 bytes) : Variable to store the result, Please explain, from levelupparam+0x44. (int *)Var5 (8 bytes) : Variable to store the result, Proper data has zero, from levelupparam+0x48. (int *)Var6 (8 bytes) : Variable to store the result, Proper data has zero, from levelupparam+0x4c. (int *)data_type (8 bytes) : Variable to store the result, in range of 0~3. from levelupparam+0x70, Affects blacksmith Ka-ching calculation. 0 is material, 2 is equipment, unknown -1 also observed. (int *)material_id (8 bytes) : Variable to store the material id, from levelupparam+0x74. 2nd section (Material info) only. (int *)kaching (8 bytes) : Variable to store the ka-ching amount, the amount is in from levelupparam 2nd section+0x68 Do not use this. Use itemparam from getGfpData instead. (float *)Var11 (8 bytes) : Variable to store the result, from levelupparam+0x6C There are some data that aren't useful, so can put same variable to the parameter to discard it. Remarks Ka-ching calculation logic follows this (from PAC instructions), but only the type 1 is used: //returns Ka-ching amount function calculate_kaching(level, baseRequirement, type) { let nextLvl = level+1; let val = (((nextLvl+1)*nextLvl)/2)*baseRequirement; switch(type){ case 1: return val*0.75 + baseRequirement*0.25; case 2: return val*0.25 + baseRequirement*0.75 default: return 0; } } Example Here is one example in hex: 25 1c 1c 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 10 00 00 00 / 04 00 00 00 / 0b 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 0e 00 00 00 / 04 00 00 00 / 0d 00 00 00 / 04 00 00 00 / 0c 00 00 00 / 20 00 00 00 / 04 00 00 00 Which is interpreted as: getLevelUpInfo((int)0, (int *)iVar16, (int *)iVar11, (int *)iVar5, (int *)iVar5, (int *)iVar5, (int *)iVar5, (int *)iVar5, (int *)iVar14, (int *)iVar13, (int *)iVar12, (float *)fVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f4e8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; undefined4 *puVar8; undefined4 *puVar9; undefined4 *puVar10; undefined4 *puVar11; int iVar12; int iVar13; undefined4 uVar14; int *piVar15; Pac_Get_Param(param_2,0,1,4); piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,8,1,4); puVar9 = (undefined4 *)Pac_Get_Param(param_2,9,1,4); puVar10 = (undefined4 *)Pac_Get_Param(param_2,10,1,4); puVar11 = (undefined4 *)Pac_Get_Param(param_2,0xb,1,4); *piVar1 = 0; *puVar2 = 0; *puVar3 = 0; *puVar4 = 0; *puVar5 = 0; *puVar6 = 0; *puVar7 = 0; *puVar8 = 0; *puVar9 = 0; *puVar10 = 0; *puVar11 = 0; if (*(int *)(param_1 + 0x10) != 0) { iVar12 = Get_Some_Flag(1); iVar12 = *(int *)(iVar12 + 0x34); piVar15 = (int *)(iVar12 + 0x25c); if (piVar15 != (int *)0x0) { if (*piVar15 == 0) { iVar13 = *(int *)(iVar12 + 0x268); } else { iVar13 = *(int *)(*piVar15 + 0x20); if (iVar13 != 0) { *piVar1 = (int)*(short *)(iVar13 + 2); uVar14 = Equip::Return_Eq_Level(*(undefined4 *)(*piVar15 + 0x20)); *puVar2 = uVar14; } iVar13 = *(int *)(iVar12 + 0x268); } if (iVar13 == 0) { puVar2 = *(undefined4 **)(iVar12 + 0x264); } else { *puVar3 = *(undefined4 *)(iVar12 + 0x260); *puVar4 = *(undefined4 *)(*(int *)(iVar12 + 0x268) + 0x40); *puVar5 = *(undefined4 *)(*(int *)(iVar12 + 0x268) + 0x44); *puVar6 = *(undefined4 *)(*(int *)(iVar12 + 0x268) + 0x48); *puVar7 = *(undefined4 *)(*(int *)(iVar12 + 0x268) + 0x4c); puVar2 = *(undefined4 **)(iVar12 + 0x264); } if (puVar2 != (undefined4 *)0x0) { *puVar8 = *puVar2; *puVar9 = *(undefined4 *)(*(int *)(iVar12 + 0x264) + 4); *puVar10 = *(undefined4 *)(*(int *)(iVar12 + 0x264) + 8); *puVar11 = *(undefined4 *)(*(int *)(iVar12 + 0x264) + 0xc); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getlevelupscriptparam.html": {
    "href": "getlevelupscriptparam.html",
    "title": "getLevelUpScriptParam",
    "keywords": "getLevelUpScriptParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getLevelUpScriptParam Scope: Azito PAC Instruction (Binary): 25 1c 1b 00 Assembly Address in Memory : 0x8b4f3b0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f3b0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 uVar5; int iVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar7 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); if (*(int *)(param_1 + 0x10) != 0) { uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); uVar5 = Param::Get_Data_Addr(*(undefined4 *)(iVar6 + 0xa4),10); iVar6 = Param::Get_Line_Addr(uVar5,0,uVar7,1); *puVar1 = *(undefined4 *)(iVar6 + 0x40); *puVar2 = *(undefined4 *)(iVar6 + 0x44); *puVar3 = *(undefined4 *)(iVar6 + 0x48); *puVar4 = *(undefined4 *)(iVar6 + 0x4c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getlinefeedcount.html": {
    "href": "getlinefeedcount.html",
    "title": "getLinefeedCount",
    "keywords": "getLinefeedCount Gets lines of the message, possibly from sysytemMessage Code Information Name: getLinefeedCount Scope: Global PAC Instruction (Binary): 25 03 11 00 Assembly Address in Memory : 0x892e268 Parameters (uint *)lines (8 bytes) : Variable to store the line amount of the message. Example Here is one example in hex: 25 03 11 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getLinefeedCount((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892e268(int param_1,undefined4 param_2) { uint *puVar1; uint uVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (*(int *)(param_1 + 0x2c) != 0) { uVar2 = (**(code **)(**(int **)(*(int *)(param_1 + 0x2c) + 0x150) + 0x94))(); *puVar1 = (uVar2 & 0xff) - 1 & 0xff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getlocalvalue.html": {
    "href": "getlocalvalue.html",
    "title": "getLocalValue",
    "keywords": "getLocalValue Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getLocalValue Scope: Global PAC Instruction (Binary): 25 10 10 00 Assembly Address in Memory : 0x890a678 Parameters (int*)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Int/Float)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a678(undefined4 param_1,undefined4 param_2) { undefined uVar1; int **ppiVar2; float *pfVar3; uint uVar4; uint uVar5; undefined4 uVar6; float fVar7; int *piVar8; ppiVar2 = (int **)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_ParamType(param_2,1); uVar5 = Pac_Get_ParamType(param_2,2); uVar1 = FUN_0883c49c(param_2,1); piVar8 = *ppiVar2; if (piVar8 != (int *)0x0) { if ((uVar4 & 0x20) != 0) { uVar6 = (**(code **)(*piVar8 + 0xc))(piVar8); fVar7 = (float)FUN_0883752c(uVar6,uVar1); if ((uVar5 & 0x70) == 0) { *pfVar3 = (float)(int)fVar7; } else { *pfVar3 = fVar7; } } if ((uVar4 & 4) != 0) { uVar6 = (**(code **)(*piVar8 + 0xc))(piVar8); fVar7 = (float)Get_Certain_Stored_Value(uVar6,uVar1); if ((uVar5 & 0x70) == 0) { *pfVar3 = fVar7; } else { *pfVar3 = (float)(int)fVar7; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmaterialitemid.html": {
    "href": "getmaterialitemid.html",
    "title": "getMaterialItemId",
    "keywords": "getMaterialItemId Loads item ID of the material by the material group and tier. Code Information Name: getMaterialItemId Scope: Global PAC Instruction (Binary): 25 0a 0e 00 Assembly Address in Memory : 0x894a10c Parameters (int *)item_id (8 bytes) : Variable to store the material item ID. (int)material_group_id (8 bytes) : Material Group ID, see below. (uint)material_tier (8 bytes) : Material Tier, expected 0~4. (4 here is tier 5 material) material_group_id Material 0x0 Leaf 0x1 Mineral (Stone) 0x2 Wood 0x3 Meat 0x4 Vegetables 0x5 Alloy 0x6 Hide 0x7 Fang 0x8 Bone 0x9 Seed 0xA Liquid Other material group IDs are invalid. Example Here is one example in hex: 25 0a 0e 00 / 04 00 00 00 / 0f 00 00 00 / 04 00 00 00 / 0d 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getMaterialItemId((int *)iVar15, (int *)iVar13, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a10c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; uint *puVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar2; puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); if (*(int *)(param_1 + 0x10) != 0) { uVar4 = BS::Get_Material_ID(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34), uVar4,*puVar3); *puVar1 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmaxmissionareaid.html": {
    "href": "getmaxmissionareaid.html",
    "title": "getMaxMissionAreaId",
    "keywords": "getMaxMissionAreaId Gets floor amount of the dungeon, from setMaxMissionAreaId. It should be 1 outside dungeon mission. Code Information Name: getMaxMissionAreaId Scope: Global PAC Instruction (Binary): 25 12 04 00 Assembly Address in Memory : 0x8a1d184 Parameters (int *)destination (8 bytes) : Variable to store the floor amount. Example Here is one example in hex: 25 12 04 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getMaxMissionAreaId((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d184(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x544); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmissionareaid.html": {
    "href": "getmissionareaid.html",
    "title": "getMissionAreaId",
    "keywords": "getMissionAreaId Gets current floor of the dungeon. Dungeon index starts from 0, floor 1 results zero. Code Information Name: getMissionAreaId Scope: Global PAC Instruction (Binary): 25 12 06 00 Assembly Address in Memory : 0x8a1d25c Parameters (int *)dungeon_floor (8 bytes) : Variable to store dungeon floor id, starts from zero. \"Floor number\" is this number +1. Example Here is one example in hex: 25 12 06 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getMissionAreaId((int *)iVar0) This is used for setting separate logic for each dungeon floor. The example below is part of defining each floor logic in \"Baby Dragon Hyumitto\" mission. 00000000 25120300:setMaxMissionAreaId(2:5) 0000000C 25000300:cmd_call(1:1770) 00000014 25002C00:cmd_flgAND(1:24, E3E) 00000024 25001700:cmd_ifEQ(8:1C, 202.0, 1:5B774) 0005B774 25000300:cmd_call(1:5BA4) 0005B77C 25100600:getPack(4:0) /* timming script 1 */ 0005B788 25120200:setMissionTimmingScript(2:0, 4:0, 1:5B7E0) /* b8 */ 0005B7E0 25000300:cmd_call(1:B8) 000000B8 25000300:cmd_call(1:148) 000000C0 25120600:getMissionAreaId(4:0) 000000CC 25001700:cmd_ifEQ(4:0, 0.0, 1:178) //floor 1 000000E4 25001700:cmd_ifEQ(4:0, 1.0, 1:190) //floor 2 000000FC 25001700:cmd_ifEQ(4:0, 2.0, 1:1B0) //floor 3 00000114 25001700:cmd_ifEQ(4:0, 3.0, 1:1D0) //floor 4 0000012C 25001700:cmd_ifEQ(4:0, 4.0, 1:1F0) //floor 5 00000144 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d25c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x540); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmissioninfo.html": {
    "href": "getmissioninfo.html",
    "title": "getMissionInfo",
    "keywords": "getMissionInfo Obtains various mission data, mostly mission ID and mission group ID. Code Information Name: getMissionInfo Scope: Global PAC Instruction (Binary): 25 0a 20 00 Assembly Address in Memory : 0x894b568 Parameters All variables are used for storing data. (int *)group_id (8 bytes) : Mission group ID. (int *)mission_id (8 bytes) : Mission ID (DLC only), otherwise it is zero. (int *)dlc_misison_id (8 bytes) : Mission ID, both for DLC and non-DLC. (int *)Var3 (8 bytes) : Related to resetting stage with resetStageParam, 2nd param as 2. (or adding with addStage) (float *)Var4 (8 bytes) : Related to resetting stage with resetStageParam, 2nd param as 3. (or adding with addStage) Example Here is one example in hex: 25 0a 20 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getMissionInfo((int *)iVar0, (int *)iVar1, (int *)iVar2, (int *)iVar3, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b568(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); iVar6 = Get_Some_Flag(1); iVar6 = *(int *)(iVar6 + 0x44); *puVar1 = *(undefined4 *)(iVar6 + 0x534); *puVar2 = *(undefined4 *)(iVar6 + 0x538); *puVar3 = *(undefined4 *)(iVar6 + 0x550); *puVar4 = *(undefined4 *)(iVar6 + 0x77c); *puVar5 = *(undefined4 *)(iVar6 + 0x780); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmodelinfo.html": {
    "href": "getmodelinfo.html",
    "title": "getModelInfo",
    "keywords": "getModelInfo Gets position and movement information of the given handle. Before performing this, wait until the model is fully loaded. Code Information Name: getModelInfo Scope: Global PAC Instruction (Binary): 25 17 0a 00 Assembly Address in Memory : 0x8911444 Parameters (int *)handle_id (8 bytes) : Handle to get the model info. (float *)position_x (8 bytes) : Variable to store the X Position of the model, as PSP pixel in the world. (float *)position_y (8 bytes) : Variable to store the Y position of the model, as PSP pixel in the world. 0 is the center. (float *)dest_x (8 bytes) : Variable to store the destination X position. (float *)dest_y (8 bytes) : Variable to store the destination Y position. Note that PSP screen size is 480 x 272. Example Here is one example in hex: 25 17 0a 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 03 00 00 00 / 20 00 00 00 / 04 00 00 00 / 20 00 00 00 / 05 00 00 00 Which is interpreted as: getModelInfo((int *)iVar0, (float *)fVar2, (float *)fVar3, (float *)fVar4, (float *)fVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911444(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); if (param_1 == 0) { iVar6 = 0; } else { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar6 == 0) { iVar6 = 0; } if (iVar6 == 0) { iVar6 = 0; } else { iVar6 = *(int *)(iVar6 + 200); if (iVar6 == 0) { iVar6 = 0; } } } if (iVar6 != 0) { *puVar2 = *(undefined4 *)(iVar6 + 0xc0); *puVar3 = *(undefined4 *)(iVar6 + 0xc4); *puVar4 = *(undefined4 *)(iVar6 + 0xe0); *puVar5 = *(undefined4 *)(iVar6 + 0xe4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmotionendframe.html": {
    "href": "getmotionendframe.html",
    "title": "getMotionEndFrame",
    "keywords": "getMotionEndFrame Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getMotionEndFrame Scope: Global PAC Instruction (Binary): 25 17 5a 00 Assembly Address in Memory : 0x89177e8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 5a 00 / 08 00 00 00 / 5b 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: getMotionEndFrame(((global)int *)giVar91, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089177e8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*(int *)(iVar3 + 200) != 0)) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 200) + 0x70); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmotionframerate.html": {
    "href": "getmotionframerate.html",
    "title": "getMotionFrameRate",
    "keywords": "getMotionFrameRate Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getMotionFrameRate Scope: Global PAC Instruction (Binary): 25 17 1f 00 Assembly Address in Memory : 0x8912c70 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 1f 00 / 04 00 00 00 / 15 00 00 00 / 20 00 00 00 / 03 00 00 00 Which is interpreted as: getMotionFrameRate((int *)iVar21, (float *)fVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912c70(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { uVar4 = FUN_088796c4(); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmotioninfo.html": {
    "href": "getmotioninfo.html",
    "title": "getMotionInfo",
    "keywords": "getMotionInfo Gets current action ID and animation status of the motion. Code Information Name: getMotionInfo Scope: Global PAC Instruction (Binary): 25 17 0c 00 Assembly Address in Memory : 0x8911878 Parameters (int *)handle (8 bytes) : Handle to get the motion. (int *)motion_id (8 bytes) : Variable to store the current ID of the motion. (int *)is_anim_ended (8 bytes) : 1 if animation has been ended, 0 if it is still animating. (int *)anim_time_offset (8 bytes) Example Here is one example in hex: 25 17 0c 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: getMotionInfo((int *)iVar0, (int *)iVar1, (int *)iVar2, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911878(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; uint *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (param_1 == 0) { iVar5 = 0; } else { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 == 0) { iVar5 = 0; } else { iVar5 = *(int *)(iVar5 + 200); if (iVar5 == 0) { iVar5 = 0; } } } if (iVar5 != 0) { *puVar2 = (uint)*(ushort *)(iVar5 + 0x78); *puVar3 = (uint)(*(float *)(iVar5 + 0x70) <= *(float *)(iVar5 + 0x68)); *puVar4 = *(undefined4 *)(iVar5 + 0x68); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmovespeedratio.html": {
    "href": "getmovespeedratio.html",
    "title": "getMoveSpeedRatio",
    "keywords": "getMoveSpeedRatio Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getMoveSpeedRatio Scope: Global PAC Instruction (Binary): 25 16 4a 00 Assembly Address in Memory : 0x891e504 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e504(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) && (iVar3 != -0x1f0)) { uVar5 = FUN_088f725c(); *puVar2 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmsgwndusenum.html": {
    "href": "getmsgwndusenum.html",
    "title": "getMsgWndUseNum",
    "keywords": "getMsgWndUseNum Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getMsgWndUseNum Scope: Global PAC Instruction (Binary): 25 16 19 01 Assembly Address in Memory : 0x8929e00 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 19 01 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getMsgWndUseNum((int)1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08929e00(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0x178); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 == 0) { *puVar2 = 0; } else { uVar4 = FUN_0893d534(iVar3,*puVar1); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmultieventunithandle.html": {
    "href": "getmultieventunithandle.html",
    "title": "getMultiEventUnitHandle",
    "keywords": "getMultiEventUnitHandle Gets handle of the other players in the hideout for event. In normal hideout unit placing, getMultiHeroHandle is preferred. Code Information Name: getMultiEventUnitHandle Scope: Azito PAC Instruction (Binary): 25 1c 0f 00 Assembly Address in Memory : 0x8b4dfb8 Parameters (int *)destination (8 bytes) : Destination to save the unit handle. (int)Var1 (8 bytes) : Player index in multi. (uint *)destination2 *(8 bytes) Example Here is one example in hex: 25 1c 0f 00 / 08 00 00 00 / 5b 00 00 00 / 08 00 00 00 / 5c 00 00 00 / 08 00 00 00 / 5d 00 00 00 Which is interpreted as: getMultiEventUnitHandle(((global)int *)giVar91, ((global)int *)giVar92, ((global)int *)giVar93) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4dfb8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; uint *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar2; puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); *piVar1 = -1; *puVar3 = 0; if ((((*(int *)(param_1 + 0x10) != 0) && (iVar5 = iVar5 * 0x500 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4), iVar5 != -0x2b40)) && ((int *)(iVar5 + 0x2b50) != (int *)0x0)) && (iVar4 = *(int *)(iVar5 + 0x2b50), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); *puVar3 = (uint)*(byte *)(iVar5 + 0x2ed8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmultiherohandle.html": {
    "href": "getmultiherohandle.html",
    "title": "getMultiHeroHandle",
    "keywords": "getMultiHeroHandle Gets player hero handle in the hideout in multi. Code Information Name: getMultiHeroHandle Scope: Azito PAC Instruction (Binary): 25 1c 10 00 Assembly Address in Memory : 0x8b4e0a8 Parameters (int *)unit_handle (8 bytes) : Variable to store the unit handle of the certain hero. (int)unit_index (8 bytes) : Hero unit index in the multi, expected 0~3. (bool *)Var2 (8 bytes) : Variable to store a value. Please describe. Might be related if the resource is loaded and valid. Example Here is one example in hex: 25 1c 10 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / ff 01 00 00 Which is interpreted as: getMultiHeroHandle((int *)iVar0, (int)0, ((global)int *)giVar511) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4e0a8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; uint *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar2; puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); *piVar1 = -1; *puVar3 = 0; if ((((*(int *)(param_1 + 0x10) != 0) && (iVar5 = iVar5 * 0x500 + *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0xcdc4), iVar5 != -0x180)) && ((int *)(iVar5 + 400) != (int *)0x0)) && (iVar4 = *(int *)(iVar5 + 400), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); *puVar3 = (uint)*(byte *)(iVar5 + 0x518); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmultiplayerlevelmax.html": {
    "href": "getmultiplayerlevelmax.html",
    "title": "getMultiPlayerLevelMax",
    "keywords": "getMultiPlayerLevelMax Gets highest hero level amongst currently playing multiplayer squad. Rare bosses (a.k.a. sukopon bosses) use this to scale the enemy level. Code Information Name: getMultiPlayerLevelMax Scope: Global PAC Instruction (Binary): 25 16 2a 01 Assembly Address in Memory : 0x892a824 Parameters (int *)destination (8 bytes) : Variable to store the maximum hero level. Remarks Unlike getPlayerClassLevel giving max level amongst all heroes, this counts from only current squad. For example, if the players have max level 40 unit, and they bring level 16 and 18 units, the result is 18, not 40. Example Here is one example in hex: 25 16 2a 01 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getMultiPlayerLevelMax((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a824(undefined4 param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; int *piVar4; int iVar5; uint uVar6; uint uVar7; uint uVar8; int local_c; int local_8; int local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); *piVar1 = 1; iVar2 = Get_Some_Flag(); iVar2 = *(int *)(iVar2 + 0x44); if (*(char *)(iVar2 + 0x81c) == '\\0') { uVar6 = 1; } else { uVar6 = 2; } local_4 = -1; uVar8 = 0; if (uVar6 != 0) { do { iVar5 = -1; local_c = -1; uVar7 = 0; do { iVar3 = FUN_089880e8(iVar2 + 0x850,uVar8,uVar7); if ((iVar3 != 0) && (*(char *)(iVar3 + 8) != '\\0')) { piVar4 = (int *)(iVar3 + 0x20); if (*(int *)(iVar3 + 0x20) < iVar5) { piVar4 = &local_c; } iVar5 = *piVar4; local_c = iVar5; } uVar7 = uVar7 + 1; } while (uVar7 < 4); local_8 = iVar5; if (local_4 < iVar5) { piVar4 = &local_8; } else { piVar4 = &local_4; } uVar8 = uVar8 + 1; local_4 = *piVar4; } while (uVar8 < uVar6); } piVar4 = piVar1; if (*piVar1 < local_4) { piVar4 = &local_4; } *piVar1 = *piVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmultiplayersquadhandle.html": {
    "href": "getmultiplayersquadhandle.html",
    "title": "getMultiPlayerSquadHandle",
    "keywords": "getMultiPlayerSquadHandle Gets a squad ID from a player in multi. Please describe the difference from getMultiplayerSquadHandle_PID. Code Information Name: getMultiPlayerSquadHandle Scope: Global PAC Instruction (Binary): 25 16 3a 00 Assembly Address in Memory : 0x891d458 Parameters (int *)squad_handle (8 bytes) : Variable to store the squad handle. Stores -1 if the unit doesn't exist. (undefined4)Var1 (8 bytes) : The observed value was zero, please describe more. (int)player_index (8 bytes) : Index of the player in multi, usually 0~3. Example Here is one example in hex: 25 16 3a 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getMultiPlayerSquadHandle((int *)iVar3, (int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d458(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *piVar1 = -1; iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0xf8); if (iVar4 == 0) { iVar4 = 0; } } if (((iVar4 != 0) && (iVar4 = FUN_088a8650(iVar4,*puVar2), iVar4 != 0)) && (iVar4 = FUN_088df588(iVar4,*puVar3), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmultiplayersquadhandle_pid.html": {
    "href": "getmultiplayersquadhandle_pid.html",
    "title": "getMultiPlayerSquadHandle_PID",
    "keywords": "getMultiPlayerSquadHandle_PID Gets a squad ID from a player in multi. Please describe the difference from getMultiplayerSquadHandle. Code Information Name: getMultiPlayerSquadHandle_PID Scope: Global PAC Instruction (Binary): 25 16 3b 00 Assembly Address in Memory : 0x891d558 Parameters (int *)squad_handle (8 bytes) : Variable to store the squad handle. Stores -1 if the unit doesn't exist. (int)player_index (8 bytes) : Index of the player in multi, 0~3 expected. Example Here is one example in hex: 25 16 3b 00 / 04 00 00 00 / 00 00 00 00 / 08 00 00 00 / 64 00 00 00 Which is interpreted as: getMultiPlayerSquadHandle_PID((int *)iVar0, ((global)int *)giVar100) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d558(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; uint uVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *piVar1 = -1; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { uVar4 = *puVar2; if ((int)uVar4 < 0) { uVar4 = uVar4 + 3; } iVar3 = FUN_088a8650(iVar3,(int)uVar4 >> 2); if (iVar3 != 0) { uVar4 = *puVar2 & 3; if (((int)*puVar2 < 0) && (uVar4 != 0)) { uVar4 = uVar4 - 4; } iVar3 = FUN_088df588(iVar3,uVar4); if (iVar3 != 0) { *piVar1 = (int)*(short *)(iVar3 + 0x78); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getmyselfplayerid.html": {
    "href": "getmyselfplayerid.html",
    "title": "getMyselfPlayerId",
    "keywords": "getMyselfPlayerId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getMyselfPlayerId Scope: Global PAC Instruction (Binary): 25 16 0c 01 Assembly Address in Memory : 0x8928b00 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 0c 01 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getMyselfPlayerId((int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928b00(undefined4 param_1,undefined4 param_2) { int *piVar1; int iVar2; int *piVar3; int local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); *piVar1 = 0; iVar2 = Get_Some_Flag(1); if (*(int *)(iVar2 + 0x44) != 0) { local_4 = *(int *)(*(int *)(iVar2 + 0x44) + 0x28); if (DAT_08a70bc0 < local_4) { piVar3 = &local_4; } else { piVar3 = &DAT_08a70bc0; } *piVar1 = *piVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getnodedisp.html": {
    "href": "getnodedisp.html",
    "title": "getNodeDisp",
    "keywords": "getNodeDisp Gets the node display status, if it is shown or hidden. Code Information Name: getNodeDisp Scope: Global PAC Instruction (Binary): 25 17 22 00 Assembly Address in Memory : 0x8912f78 Parameters (int *)handle_id (8 bytes) : The target handle. (int *)node_index (8 bytes) : Node index, obtained from getNodeIndex. (int *)display_node (8 bytes) : Variable to store the node display status, 1 displayed and 0 hidden. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912f78(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; uint *puVar3; int iVar4; uint uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); if (param_1 == 0) { iVar4 = 0; } else { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 == 0) { iVar4 = 0; } else { iVar4 = *(int *)(iVar4 + 200); if (iVar4 == 0) { iVar4 = 0; } } } if (iVar4 != 0) { uVar5 = (**(code **)(**(int **)(iVar4 + 0x60) + 0x6c))(*(int **)(iVar4 + 0x60),*puVar2); *puVar3 = uVar5 & 0xff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getnodeindex.html": {
    "href": "getnodeindex.html",
    "title": "getNodeIndex",
    "keywords": "getNodeIndex Gets specific node ID from the model by given node name. Useful for e.g. getNodePos, getNodeDisp, or setNodeDisp, but can be used for e.g. callMessageWindow. Code Information Name: getNodeIndex Scope: Global PAC Instruction (Binary): 25 17 20 00 Assembly Address in Memory : 0x8912d40 Parameters (int *)handle_id (8 bytes) : The target handle. (int *)destination (8 bytes) : Variable to store the node index. (String)node_name : The node name from the GXX file. Example Here is one example in hex: 25 17 20 00 / 08 00 00 00 / 43 01 00 00 / 08 00 00 00 / ff 01 00 00 / 67 69 72 6f / 74 69 6e 5f / 72 6f 74 00 Which is interpreted as: getNodeIndex(((global)int *)giVar323, ((global)int *)giVar511, \"girotin_rot\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912d40(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined *puVar4; undefined4 uVar5; undefined *puVar6; int iVar7; int *piVar8; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = &DAT_00000100; puVar6 = local_100; puVar1 = puVar6; while (puVar1 != (undefined *)0x0) { *puVar6 = 0; puVar6 = puVar6 + 1; puVar4 = puVar4 + -1; puVar1 = puVar4; } Pac_Get_StringParam(param_2,local_100); if (param_1 == 0) { iVar7 = 0; } else { iVar7 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar2,1); if (iVar7 == 0) { iVar7 = 0; } if (iVar7 == 0) { iVar7 = 0; } else { iVar7 = *(int *)(iVar7 + 200); if (iVar7 == 0) { iVar7 = 0; } } } if (iVar7 != 0) { *puVar3 = 0xffffffff; piVar8 = *(int **)(iVar7 + 0x60); if (piVar8 == (int *)0x0) { *puVar3 = 0xffffffff; } else { uVar5 = (**(code **)(*piVar8 + 0x48))(piVar8,local_100); *puVar3 = uVar5; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getnodepos.html": {
    "href": "getnodepos.html",
    "title": "getNodePos",
    "keywords": "getNodePos Retrives position of the given node. Code Information Name: getNodePos Scope: Global PAC Instruction (Binary): 25 17 21 00 Assembly Address in Memory : 0x8912e58 Parameters (int *)handle_id (8 bytes) : The target handle. (int *)node (8 bytes) : ID of the node, obtained from getNodeIndex (float *)x (8 bytes) : Variable to store the X poisiton of the node. (float *)y (8 bytes) : Variable to store the Y position of the node. Example Here is one example in hex: 25 17 21 00 / 08 00 00 00 / 43 01 00 00 / 08 00 00 00 / ff 01 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: getNodePos(((global)int *)giVar323, ((global)int *)giVar511, (float *)fVar0, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912e58(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined auStack64 [48]; undefined4 local_10; undefined4 local_c; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (param_1 == 0) { iVar5 = 0; } else { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 == 0) { iVar5 = 0; } else { iVar5 = *(int *)(iVar5 + 200); if (iVar5 == 0) { iVar5 = 0; } } } if (iVar5 != 0) { Gimmick::Load_Set_Gimmick_Position(iVar5,*puVar2,auStack64); *puVar3 = local_10; *puVar4 = local_c; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpack_25100600.html": {
    "href": "getpack_25100600.html",
    "title": "getPack (25100600)",
    "keywords": "getPack (25100600) Other functions have the same name. Check the Disambiguation page to find them. Gets address of (start of) the PAC instructions in memory. e.g. 09 xx xx xx. Code Information Name: getPack Scope: Global PAC Instruction (Binary): 25 10 06 00 Assembly Address in Memory : 0x8909f58 Parameters (MemoryAddress)pac_address_in_memory (8 bytes) : The memory address where the whole PAC instructions start. Example Here is one example in hex: 25 10 06 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getPack((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08909f58(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { uVar2 = FUN_0883bc1c(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpack_25160200.html": {
    "href": "getpack_25160200.html",
    "title": "getPack (25160200)",
    "keywords": "getPack (25160200) Other functions have the same name. Check the Disambiguation page to find them. Gets address of (start of) the PAC instructions in memory, but from external pac file. e.g. 09 xx xx xx. Code Information Name: getPack Scope: Global PAC Instruction (Binary): 25 16 02 00 Assembly Address in Memory : 0x8919084 Parameters (MemoryAddress)pac_address_in_memory (8 bytes) : The memory address where the whole PAC instructions start. (String)pac_file_name : The PAC file name to get the address. Example Here is one example in hex: 25 16 02 00 / 04 00 00 00 / 00 00 00 00 / 45 66 66 65 / 63 74 2e 70 / 61 63 00 00 Which is interpreted as: getPack((int *)iVar0, \"Effect.pac\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919084(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined *puVar3; undefined4 uVar4; undefined *puVar5; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = &DAT_00000100; puVar5 = local_100; puVar1 = puVar5; while (puVar1 != (undefined *)0x0) { *puVar5 = 0; puVar5 = puVar5 + 1; puVar3 = puVar3 + -1; puVar1 = puVar3; } Pac_Get_StringParam(param_2,local_100); if (*(int *)(param_1 + 0x10) != 0) { uVar4 = FUN_0889505c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x168),local_100); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpack_251c0200.html": {
    "href": "getpack_251c0200.html",
    "title": "getPack (251c0200)",
    "keywords": "getPack (251c0200) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPack Scope: Azito PAC Instruction (Binary): 25 1c 02 00 Assembly Address in Memory : 0x8b4d200 Parameters (undefined4)Var0 (8 bytes) (String)Var1 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d200(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined *puVar3; undefined4 uVar4; undefined *puVar5; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = &DAT_00000100; puVar5 = local_100; puVar1 = puVar5; while (puVar1 != (undefined *)0x0) { *puVar5 = 0; puVar5 = puVar5 + 1; puVar3 = puVar3 + -1; puVar1 = puVar3; } Pac_Get_StringParam(param_2,local_100); if (*(int *)(param_1 + 0x10) != 0) { uVar4 = FUN_0889505c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x1a4),local_100); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpaddirect.html": {
    "href": "getpaddirect.html",
    "title": "getPadDirect",
    "keywords": "getPadDirect Gets keys that are just started to be pressed as flag. Code Information Name: getPadDirect Scope: Global PAC Instruction (Binary): 25 09 02 00 Assembly Address in Memory : 0x89489e4 Parameters (int *)destination (8 bytes) : Variable to store the just pressed keys as flag. Example Here is one example in hex: 25 09 02 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getPadDirect((int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089489e4(undefined4 param_1,undefined4 param_2) { bool bVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); bVar1 = *(char *)(*(int *)(iVar4 + 0x94) + 0x3d8) != '\\0'; if (bVar1) { bVar1 = *(int *)(*(int *)(iVar4 + 0x94) + 0x3f0) != 0; } *puVar2 = 0; if (!bVar1) { iVar4 = FUN_08851bec(1); *puVar2 = **(undefined4 **)(iVar4 + 0x10c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpadrelease.html": {
    "href": "getpadrelease.html",
    "title": "getPadRelease",
    "keywords": "getPadRelease Gets keys that are just started to be released as flag. Code Information Name: getPadRelease Scope: Global PAC Instruction (Binary): 25 09 04 00 Assembly Address in Memory : 0x8948b24 Parameters (int *)destination (8 bytes) : Variable to store the just released keys as flag. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948b24(undefined4 param_1,undefined4 param_2) { bool bVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); bVar1 = *(char *)(*(int *)(iVar4 + 0x94) + 0x3d8) != '\\0'; if (bVar1) { bVar1 = *(int *)(*(int *)(iVar4 + 0x94) + 0x3f0) != 0; } *puVar2 = 0; if (!bVar1) { iVar4 = FUN_08851bec(1); *puVar2 = *(undefined4 *)(*(int *)(iVar4 + 0x10c) + 8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpadstand.html": {
    "href": "getpadstand.html",
    "title": "getPadStand",
    "keywords": "getPadStand Gets curently pressed keys as flag. Code Information Name: getPadStand Scope: Global PAC Instruction (Binary): 25 09 03 00 Assembly Address in Memory : 0x8948a84 Parameters (int *)destination (8 bytes) : Variable to store the currently pressed keys as flag. Example Here is one example in hex: 25 09 03 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getPadStand((int *)iVar0) With cmd_ifAND, certain PAC instructions can be executed on key press. 0000F6B0 25090300:getPadStand(8:2B) 0000F6BC 25001D00:cmd_ifAND(8:2B, 2:2000, 1:F6DC) 0000F6D4 25000200:cmd_jmp(1:F6A4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948a84(undefined4 param_1,undefined4 param_2) { bool bVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); bVar1 = *(char *)(*(int *)(iVar4 + 0x94) + 0x3d8) != '\\0'; if (bVar1) { bVar1 = *(int *)(*(int *)(iVar4 + 0x94) + 0x3f0) != 0; } *puVar2 = 0; if (!bVar1) { iVar4 = FUN_08851bec(1); *puVar2 = *(undefined4 *)(*(int *)(iVar4 + 0x10c) + 4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getparent.html": {
    "href": "getparent.html",
    "title": "getParent",
    "keywords": "getParent Gets parent handle of a handle. Code Information Name: getParent Scope: Global PAC Instruction (Binary): 25 17 54 00 Assembly Address in Memory : 0x8917170 Parameters (int *)handle_id (8 bytes) : The target handle. (int)Var1 (8 bytes) : Set 1 if it is not sure. (int *)parent_handle (8 bytes) : Variable to store the parent handle. Example Here is one example in hex: 25 17 54 00 / 04 00 00 00 / 40 00 00 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getParent((int *)iVar64, (int)1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917170(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar3 = -1; if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { if (*piVar2 == 0) { if (*(int *)(iVar4 + 0x100) == 0) { iVar4 = 0; } else { iVar4 = *(int *)(*(int *)(iVar4 + 0x100) + 8); } } else { iVar4 = *(int *)(iVar4 + 0x7c); } if (iVar4 != 0) { *piVar3 = (int)*(short *)(iVar4 + 0x78); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getparentgroupid.html": {
    "href": "getparentgroupid.html",
    "title": "getParentGroupId",
    "keywords": "getParentGroupId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getParentGroupId Scope: Global PAC Instruction (Binary): 25 10 0b 00 Assembly Address in Memory : 0x890a348 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a348(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0xffffffff; if ((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x4e0), iVar2 != 0)) { *puVar1 = *(undefined4 *)(iVar2 + 0x4fc); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayerclassid.html": {
    "href": "getplayerclassid.html",
    "title": "getPlayerClassId",
    "keywords": "getPlayerClassId Gets class ID of the given player. Code Information Name: getPlayerClassId Scope: Global PAC Instruction (Binary): 25 16 51 00 Assembly Address in Memory : 0x891eda0 Parameters (int)class_tree (8 bytes) : The index of the player. 0 is hero, 1 is Ton, 2 is Chin, 3 is Kan. (int *)destination (8 bytes) : Variable to store the class ID. -1 if the class is invalid. Example Here is one example in hex: 25 16 51 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 10 00 00 00 Which is interpreted as: getPlayerClassId((int)0, (int *)iVar16) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891eda0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); iVar6 = 0; if (*(int *)(iVar5 + 0x44) != 0) { iVar5 = *(int *)(*(int *)(iVar5 + 0x44) + 0x28); iVar6 = iVar5 >> 2; if (iVar5 < 0) { iVar6 = iVar5 + 3 >> 2; } } uVar4 = FUN_088a8650(iVar3,iVar6); iVar5 = *piVar1; iVar3 = 0; if (iVar5 == 3) { iVar3 = Is_Class_Tree(uVar4,3,0); } else if (iVar5 == 2) { iVar3 = Is_Class_Tree(uVar4,2,0); } else if (iVar5 == 1) { iVar3 = Is_Class_Tree(uVar4,1,0); } else if (iVar5 == 0) { iVar3 = FUN_088df7ac(uVar4); } if (iVar3 != 0) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 0xa14) + 0x18c); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayerclasslevel.html": {
    "href": "getplayerclasslevel.html",
    "title": "getPlayerClassLevel",
    "keywords": "getPlayerClassLevel Gets Maximum class level of the given player index. This affects e.g. item level from chest and infection. Code Information Name: getPlayerClassLevel Scope: Global PAC Instruction (Binary): 25 16 53 00 Assembly Address in Memory : 0x891f004 Parameters (int)player_id (8 bytes) : 0 is hero, 1 is Ton, 2 is Chin, 3 is Kan. (int)level_limit (8 bytes) : If this is -1, the result is max level. Otherwise, the result is level_limit <= max_level. (int *destination (8 bytes) : Variable to store the result. (Stores either 0 or 1 if the level_limit is not -1). Example Here is one example in hex: 25 16 53 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getPlayerClassLevel((int)0, (int)-1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891f004(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; undefined4 uVar4; int iVar5; uint uVar6; int iVar7; uint uVar8; uint uVar9; int iVar10; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar3 = 0; uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); iVar10 = *(int *)(iVar5 + 100); uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); iVar5 = *(int *)(iVar5 + 0x44); if (iVar5 == 0) goto LAB_0891f280; iVar7 = *piVar1; piVar1 = (int *)0x0; if (iVar7 == 3) { iVar10 = *(int *)(iVar5 + 0x28); if (iVar10 < 0) { iVar10 = iVar10 + 3; } piVar1 = (int *)(iVar5 + (iVar10 >> 2) * 0x58a4 + 0x67b4); } else if (iVar7 == 2) { iVar10 = *(int *)(iVar5 + 0x28); if (iVar10 < 0) { iVar10 = iVar10 + 3; } piVar1 = (int *)(iVar5 + (iVar10 >> 2) * 0x58a4 + 0x5194); } else if (iVar7 == 1) { iVar10 = *(int *)(iVar5 + 0x28); if (iVar10 < 0) { iVar10 = iVar10 + 3; } piVar1 = (int *)(iVar5 + (iVar10 >> 2) * 0x58a4 + 0x3b74); } else if (iVar7 == 6) { iVar10 = *(int *)(iVar5 + 0x28); if (iVar10 < 0) { iVar10 = iVar10 + 3; } piVar1 = (int *)(iVar5 + (iVar10 >> 2) * 0x58a4 + 0x2554); } else if (iVar7 == 0) { if (iVar10 == 0) { iVar10 = *(int *)(iVar5 + 0x28); } else { iVar10 = Is_Multi(iVar10); if (iVar10 != 0) { uVar9 = *(uint *)(iVar5 + 0x28); uVar6 = uVar9; if ((int)uVar9 < 0) { uVar6 = uVar9 + 3; } uVar8 = uVar9 & 3; if (((int)uVar9 < 0) && (uVar8 != 0)) { uVar8 = uVar8 - 4; } piVar1 = (int *)(uVar8 * 0x1620 + iVar5 + ((int)uVar6 >> 2) * 0x58a4 + 0x2554); goto LAB_0891f224; } iVar10 = *(int *)(iVar5 + 0x28); } if (iVar10 < 0) { iVar10 = iVar10 + 3; } piVar1 = (int *)(iVar5 + (iVar10 >> 2) * 0x58a4 + 0x2554); } LAB_0891f224: if ((piVar1 != (int *)0x0) && (*piVar1 != 0)) { iVar5 = *piVar2; if (iVar5 == -1) { iVar5 = piVar1[1]; } *piVar3 = piVar1[iVar5 * 0x21 + 8]; } LAB_0891f280: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayerdata.html": {
    "href": "getplayerdata.html",
    "title": "getPlayerData",
    "keywords": "getPlayerData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPlayerData Scope: Global PAC Instruction (Binary): 25 0a 12 00 Assembly Address in Memory : 0x894a5bc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (Undefined)Var5 (8 bytes) Example Here is one example in hex: 25 0a 12 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 5c 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 01 00 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: getPlayerData((int)0, ((global)int *)giVar92, (int)0, (int)2, (int)1, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a5bc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; undefined4 uVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar6 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar5 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar3 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); uVar7 = *puVar1; uVar2 = Pac_Get_Param(param_2,5,1,4); FUN_0894ad3c(param_1,0,uVar6,uVar5,uVar4,uVar3,uVar7,uVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayerid.html": {
    "href": "getplayerid.html",
    "title": "getPlayerId",
    "keywords": "getPlayerId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPlayerId Scope: Global PAC Instruction (Binary): 25 16 cd 00 Assembly Address in Memory : 0x892570c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 cd 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getPlayerId((int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892570c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 != 0) { iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); if (iVar4 == 3) { *puVar2 = *(undefined4 *)(iVar3 + 0x184); } else { *puVar2 = 0xffffffff; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayersight.html": {
    "href": "getplayersight.html",
    "title": "getPlayerSight",
    "keywords": "getPlayerSight Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPlayerSight Scope: Global PAC Instruction (Binary): 25 16 a8 00 Assembly Address in Memory : 0x8922bd0 Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (uint)Var2 (8 bytes) Example Here is one example in hex: 25 16 a8 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 55 0e 00 00 / 02 00 00 00 / 59 0e 00 00 Which is interpreted as: getPlayerSight((int)0, (int)3669, (int)3673) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922bd0(int param_1,undefined4 param_2) { int iVar1; undefined4 *puVar2; uint *puVar3; uint *puVar4; int iVar5; byte *pbVar6; int iVar7; iVar1 = FUN_0883c070(param_2); puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar4 = (uint *)Pac_Get_Param(param_2,2,1,4); pbVar6 = (byte *)(*(int *)(iVar1 + 4) + (*puVar3 >> 3)); *pbVar6 = *pbVar6 & ((byte)(1 << (*puVar3 & 7)) ^ 0xff); pbVar6 = (byte *)(*(int *)(iVar1 + 4) + (*puVar4 >> 3)); *pbVar6 = *pbVar6 & ((byte)(1 << (*puVar4 & 7)) ^ 0xff); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = *(int *)(iVar5 + 0xf8); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { iVar7 = 0; iVar5 = FUN_088a8650(iVar5,0); switch(*puVar2) { case 0: iVar7 = FUN_088df7ac(iVar5); break; case 1: iVar7 = Is_Class_Tree(iVar5,1,0); break; case 2: iVar7 = Is_Class_Tree(iVar5,2,0); break; case 3: iVar7 = Is_Class_Tree(iVar5,3,0); } if ((iVar7 != 0) && (*(char *)(*(int *)(iVar7 + 0xa14) + 0x44c) != '\\0')) { if (*(int *)(iVar5 + 0x374) == 10) { pbVar6 = (byte *)(*(int *)(iVar1 + 4) + (*puVar4 >> 3)); *pbVar6 = *pbVar6 | (byte)(1 << (*puVar4 & 7)); } else { pbVar6 = (byte *)(*(int *)(iVar1 + 4) + (*puVar3 >> 3)); *pbVar6 = *pbVar6 | (byte)(1 << (*puVar3 & 7)); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayersquadhandle.html": {
    "href": "getplayersquadhandle.html",
    "title": "getPlayerSquadHandle",
    "keywords": "getPlayerSquadHandle Gets a squad handle of the player squad member. Code Information Name: getPlayerSquadHandle Scope: Global PAC Instruction (Binary): 25 16 39 00 Assembly Address in Memory : 0x891d1bc Parameters (int *)destination (8 bytes) : Destination ID to store the squad handle. Stores -1 if the unit doesn't exist. (int)player_type (8 bytes) : PlayerSquad ID of the player. Here is the \"PlayerSquad ID\" table: player_type Unit 0 UberHero 1 Ton 2 Chin 3 Kan 4 Dark Hero 5 Hatapon 6 ??? Example Here is one example in hex: 25 16 39 00 / 04 00 00 00 / 03 00 00 00 / 02 00 00 00 / 05 00 00 00 Which is interpreted as: getPlayerSquadHandle((int *)iVar3, (int)5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d1bc(int param_1,undefined4 param_2) { char cVar1; int *piVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; int iVar6; undefined4 uVar7; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *piVar2 = -1; iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0xf8); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); iVar6 = *(int *)(*(int *)(iVar6 + 0x44) + 0x28); if (iVar6 < 0) { iVar6 = iVar6 + 3; } uVar5 = FUN_088a8650(iVar4,iVar6 >> 2); switch(*puVar3) { case 0: iVar4 = FUN_088df7ac(uVar5); if (iVar4 != 0) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0xa14) + 0x78); } break; case 1: iVar4 = Is_Class_Tree(uVar5,1,0); if (iVar4 != 0) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0xa14) + 0x78); } break; case 2: iVar4 = Is_Class_Tree(uVar5,2,0); if (iVar4 != 0) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0xa14) + 0x78); } break; case 3: iVar4 = Is_Class_Tree(uVar5,3,0); if (iVar4 != 0) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0xa14) + 0x78); } break; case 4: iVar4 = FUN_088e0afc(uVar5); if (iVar4 != 0) { *piVar2 = (int)*(short *)(iVar4 + 0x78); } break; case 5: iVar4 = Get_HataponAddr(uVar5); if (iVar4 != 0) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0xa14) + 0x78); } break; case 6: uVar7 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar7,1); if (*(int *)(*(int *)(iVar4 + 100) + 0x98) == 0) { iVar4 = *piVar2; } else { iVar4 = 0; do { iVar6 = FUN_088df588(uVar5,iVar4); if (((iVar6 != 0) && (*(int *)(iVar6 + 0x188) == 0)) && (cVar1 = pointer_offset18(iVar6 + 0x474), cVar1 == '\\0')) { *piVar2 = (int)*(short *)(iVar6 + 0x78); break; } iVar4 = iVar4 + 1; } while (iVar4 < 4); iVar4 = *piVar2; } if ((iVar4 == -1) && (iVar4 = FUN_088df7ac(uVar5), iVar4 != 0)) { *piVar2 = (int)*(short *)(*(int *)(iVar4 + 0xa14) + 0x78); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayersuperheroclassmaskid.html": {
    "href": "getplayersuperheroclassmaskid.html",
    "title": "getPlayerSuperHeroClassMaskId",
    "keywords": "getPlayerSuperHeroClassMaskId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPlayerSuperHeroClassMaskId Scope: Global PAC Instruction (Binary): 25 16 52 00 Assembly Address in Memory : 0x891ef1c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ef1c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0xffffffff; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0xf8); if (iVar2 == 0) { iVar2 = 0; } } uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); iVar5 = 0; if (*(int *)(iVar4 + 0x44) != 0) { iVar4 = *(int *)(*(int *)(iVar4 + 0x44) + 0x28); iVar5 = iVar4 >> 2; if (iVar4 < 0) { iVar5 = iVar4 + 3 >> 2; } } if (iVar2 != 0) { uVar3 = FUN_088a8650(iVar2,iVar5); iVar2 = FUN_088df7ac(uVar3); if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0xa00); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayertroopbaseposition.html": {
    "href": "getplayertroopbaseposition.html",
    "title": "getPlayerTroopBasePosition",
    "keywords": "getPlayerTroopBasePosition Gets player troop position without additional attack movement. With additional attack movement, check getTroopTopPosX. Code Information Name: getPlayerTroopBasePosition Scope: Global PAC Instruction (Binary): 25 16 40 00 Assembly Address in Memory : 0x891daec Parameters (bool)no_hatapon_pos (8 bytes) : Single player only. 0 uses Hatapon base position. Does nothing in multi. (float *)destination (8 bytes) : Variable to store the base position. Example Here is one example in hex: 25 16 40 00 / 02 00 00 00 / 01 00 00 00 / 40 00 00 00 / c8 00 00 00 Which is interpreted as: getPlayerTroopBasePosition((int)1, ((global)float *)gfVar200) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891daec(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; int iVar5; int iVar6; undefined4 *puVar7; int iVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,0), iVar3 != 0)) { uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); uVar4 = *(undefined4 *)(iVar5 + 100); iVar5 = FUN_088e217c(iVar3); iVar8 = 0; iVar6 = Is_Multi(uVar4); if (iVar6 == 0) { if (*piVar1 == 0) { iVar3 = Get_HataponAddr(iVar3); if (iVar3 == 0) { if (iVar5 != 0) { iVar8 = iVar5 + 0x260; } } else { iVar8 = *(int *)(iVar3 + 0xa14) + 0x260; } } else if ((*piVar1 == 1) && (iVar5 != 0)) { iVar8 = iVar5 + 0x260; } } else if (iVar5 != 0) { iVar8 = iVar5 + 0x260; } if (iVar8 != 0) { puVar7 = (undefined4 *)offset__10(iVar8); *puVar2 = *puVar7; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getplayerversusgoal.html": {
    "href": "getplayerversusgoal.html",
    "title": "getPlayerVersusGoal",
    "keywords": "getPlayerVersusGoal Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPlayerVersusGoal Scope: Global PAC Instruction (Binary): 25 16 c4 00 Assembly Address in Memory : 0x8924130 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 c4 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getPlayerVersusGoal((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924130(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar4 = *piVar1; if ((iVar4 < 0) || (7 < iVar4)) { uVar3 = 0xffffffff; } else { uVar3 = *(undefined4 *) (iVar4 * 4 + *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2d8) + 0x58) + 0x14); } *puVar2 = uVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getpos.html": {
    "href": "getpos.html",
    "title": "getPos",
    "keywords": "getPos Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getPos Scope: Global PAC Instruction (Binary): 25 0c 06 00 Assembly Address in Memory : 0x897054c Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 0c 06 00 / 02 00 00 00 / ff ff ff ff / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getPos((int)-1, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0897054c(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; undefined4 uVar5; int local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar4 != 0) { iVar3 = *piVar1; if (iVar3 < 0) { iVar3 = Get_Some_Flag(1); local_4 = *(int *)(*(int *)(iVar3 + 0x44) + 0x28); if (DAT_08a71d58 < local_4) { piVar1 = &local_4; } else { piVar1 = &DAT_08a71d58; } iVar3 = *piVar1; } uVar5 = func_0x08b5f800(iVar4,iVar3); *puVar2 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getquestcompletecounter.html": {
    "href": "getquestcompletecounter.html",
    "title": "getQuestCompleteCounter",
    "keywords": "getQuestCompleteCounter Gets the quest completing count. DLC Quests call this with Mission ID -1. Max quest complement amount stored is 100 (0x64). Code Information Name: getQuestCompleteCounter Scope: Global PAC Instruction (Binary): 25 0a 3b 00 Assembly Address in Memory : 0x894cea0 Parameters (int *)destination (8 bytes) : Variable to store the quest complement amount. (int)mission_id (8 bytes) : The Mission ID to retrieve the complement counter. Example Here is one example in hex: 25 0a 3b 00 / 08 00 00 00 / 1c 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getQuestCompleteCounter(((global)int *)giVar28, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cea0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; uint uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x1c(*(undefined4 *)(iVar3 + 0x50)); uVar4 = Save::Get_Flag_From_Data(iVar3 + 0xedae,*puVar1); *puVar2 = uVar4 & 0xff; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getquestid.html": {
    "href": "getquestid.html",
    "title": "getQuestId",
    "keywords": "getQuestId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getQuestId Scope: Global PAC Instruction (Binary): 25 12 08 00 Assembly Address in Memory : 0x8a1d31c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d31c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x550); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getquestlevel.html": {
    "href": "getquestlevel.html",
    "title": "getQuestLevel",
    "keywords": "getQuestLevel Gets the quest level, potentially set by setQuestLevel. Use getQuestLevelRevise instead for actual usage. Code Information Name: getQuestLevel Scope: Global PAC Instruction (Binary): 25 16 a5 00 Assembly Address in Memory : 0x8922ab0 Parameters (int *)destination (8 bytes) : Variable to store the quest level. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922ab0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x554); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getquestlevelrevise.html": {
    "href": "getquestlevelrevise.html",
    "title": "getQuestLevelRevise",
    "keywords": "getQuestLevelRevise Gets the actual quest level, set by setQuestLevelRevise. Code Information Name: getQuestLevelRevise Scope: Global PAC Instruction (Binary): 25 16 a7 00 Assembly Address in Memory : 0x8922b70 Parameters (int *)destination (8 bytes) : Variable to store the quest level. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922b70(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x558); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getquesttype.html": {
    "href": "getquesttype.html",
    "title": "getQuestType",
    "keywords": "getQuestType Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getQuestType Scope: Global PAC Instruction (Binary): 25 16 00 01 Assembly Address in Memory : 0x89280f8 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 00 01 / 04 00 00 00 / 33 00 00 00 Which is interpreted as: getQuestType((int *)iVar51) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089280f8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x54c); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getrainlevel.html": {
    "href": "getrainlevel.html",
    "title": "getRainLevel",
    "keywords": "getRainLevel Gets the raining amount. This works both in hideout and during mission. Code Information Name: getRainLevel Scope: Global PAC Instruction (Binary): 25 16 7d 00 Assembly Address in Memory : 0x8921130 Parameters (float *)destination (8 bytes) : Variable store how much the rain falls, the level is between 0~1. 0 means no rain. Example Here is one example in hex: 25 16 7d 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getRainLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921130(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x264); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getrenderpriority.html": {
    "href": "getrenderpriority.html",
    "title": "getRenderPriority",
    "keywords": "getRenderPriority Gets how top the object is. Higher value means the target is more top of the screen. Code Information Name: getRenderPriority Scope: Global PAC Instruction (Binary): 25 17 70 00 Assembly Address in Memory : 0x8918bb8 Parameters (int *)handle_id (8 bytes) : Handle to set render priority. (int *)destination (8 bytes) : Destination to save the render priority. For reference, fever gauge render priority is 10000 (0x2710). Example Here is one example in hex: 25 17 70 00 / 04 00 00 00 / 00 00 00 00 / 08 00 00 00 / a9 01 00 00 Which is interpreted as: getRenderPriority((int *)iVar0, ((global)int *)giVar425) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08918bb8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { uVar4 = (**(code **)(*(int *)(iVar3 + 0x3c) + 0x10))(iVar3 + 0x20); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getresultsavems.html": {
    "href": "getresultsavems.html",
    "title": "getResultSaveMS",
    "keywords": "getResultSaveMS Checks if the saving is done. Called after saveMs. Code Information Name: getResultSaveMS Scope: Azito PAC Instruction (Binary): 25 1c 1e 00 Assembly Address in Memory : 0x8b4f830 Parameters (bool)is_saving (8 bytes) : 1 if the saving is not done, 0 if saving is done. Example Here is one example in hex: 25 1c 1e 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getResultSaveMS((int *)iVar0) This is an example how to save the data properly. 0000A504 251C1D00:saveMS(2:0, 2:0) 0000A518 25000200:cmd_jmp(1:A554) 0000A554 25000F00:cmd_waitFrame(2:1) 0000A560 251C1E00:getResultSaveMS(4:0) 0000A56C 25001D00:cmd_ifAND(4:0, 2:1, 1:A554) //if saving is not done, go before, so block the instruction flow until saving is done 0000A584 25000100:cmd_end()``` ## Code Ths PAC instruction calls this function (Decompiled by Ghidra): ```c void FUN_Azito__08b4f830(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (*(int *)(param_1 + 0x10) != 0) { uVar2 = FUN_Azito__08b51148(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x204)); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getretireflag.html": {
    "href": "getretireflag.html",
    "title": "getRetireFlag",
    "keywords": "getRetireFlag Checks if the player decided to retire. Code Information Name: getRetireFlag Scope: Global PAC Instruction (Binary): 25 16 08 01 Assembly Address in Memory : 0x8928770 Parameters (uint *)destination (8 bytes) : Variable to store if the player is retired. 0 if player did not retire, 1 if they did. Example Here is one example in hex: 25 16 08 01 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getRetireFlag((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928770(int param_1,undefined4 param_2) { uint *puVar1; int iVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x4c), iVar2 != 0)) { *puVar1 = (uint)*(byte *)(iVar2 + 0x27); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsandlevel.html": {
    "href": "getsandlevel.html",
    "title": "getSandLevel",
    "keywords": "getSandLevel Gets the strength of the sandstorm weather. Code Information Name: getSandLevel Scope: Global PAC Instruction (Binary): 25 16 82 00 Assembly Address in Memory : 0x89213ec Parameters (float *)sandstorm_level (8 bytes) : Variable to store the sandstorm level. 0 is no sandstorm, 1 is strongest sandstorm. Example Here is one example in hex: 25 16 82 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getSandLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089213ec(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 600); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getscale.html": {
    "href": "getscale.html",
    "title": "getScale",
    "keywords": "getScale Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getScale Scope: Global PAC Instruction (Binary): 25 17 4c 00 Assembly Address in Memory : 0x89160d0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 4c 00 / 04 00 00 00 / 14 00 00 00 / 20 00 00 00 / 14 00 00 00 Which is interpreted as: getScale((int *)iVar20, (float *)fVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089160d0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0x3f800000; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*(int *)(iVar3 + 200) != 0)) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 200) + 0x88); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getshopiteminfo.html": {
    "href": "getshopiteminfo.html",
    "title": "getShopItemInfo",
    "keywords": "getShopItemInfo Unimplemented. Code Information Name: getShopItemInfo Scope: Azito PAC Instruction (Binary): 25 1c 2a 00 Assembly Address in Memory : 0x8b4ff70 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4ff70(undefined4 param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsnowlevel.html": {
    "href": "getsnowlevel.html",
    "title": "getSnowLevel",
    "keywords": "getSnowLevel Gets the snowing amount. This works both in hideout and during mission. Code Information Name: getSnowLevel Scope: Global PAC Instruction (Binary): 25 16 7e 00 Assembly Address in Memory : 0x89211bc Parameters (float *)destination (8 bytes) : Variable to store how much the snow falls, the level is between 0~1. 0 means no snow. Example Here is one example in hex: 25 16 7e 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getSnowLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089211bc(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x250); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsoundcommandid.html": {
    "href": "getsoundcommandid.html",
    "title": "getSoundCommandID",
    "keywords": "getSoundCommandID Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSoundCommandID Scope: Global PAC Instruction (Binary): 25 21 27 00 Assembly Address in Memory : 0x89b3a74 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 27 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 3e 00 00 00 Which is interpreted as: getSoundCommandID((int *)iVar20, (int *)iVar62) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3a74(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 0x80) + 0x178); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsoundlevel.html": {
    "href": "getsoundlevel.html",
    "title": "getSoundLevel",
    "keywords": "getSoundLevel Gets if current combo status is fever or pre-fever. Code Information Name: getSoundLevel Scope: Global PAC Instruction (Binary): 25 0c 15 00 Assembly Address in Memory : 0x8970d48 Parameters (int *)destination (8 bytes) : Variable to store the current combostatus (0 is no fever, 1 is pre-fever, 2 is fever). Example Here is one example in hex: 25 0c 15 00 / 08 00 00 00 / 25 00 00 00 Which is interpreted as: getSoundLevel(((global)int *)giVar37) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970d48(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar1 = 0; if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x69c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsquad_playerid.html": {
    "href": "getsquad_playerid.html",
    "title": "getSquad_playerId",
    "keywords": "getSquad_playerId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSquad_playerId Scope: Global PAC Instruction (Binary): 25 16 cf 00 Assembly Address in Memory : 0x8925880 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925880(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int iVar4; int iVar5; int iVar6; int iVar7; int iVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0xf8); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { iVar8 = 0; do { iVar5 = FUN_088a8650(iVar4,iVar8); if (iVar5 != 0) { iVar7 = 0; do { iVar6 = FUN_088df588(iVar5,iVar7); if ((iVar6 != 0) && (*piVar1 == *(int *)(iVar6 + 0x188))) { *piVar2 = iVar8; *piVar3 = iVar7; PAC::PAC_setCmdId(param_2,0); return; } iVar7 = iVar7 + 1; } while (iVar7 < 4); } iVar8 = iVar8 + 1; } while (iVar8 < 2); } *piVar2 = -1; *piVar3 = -1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsquadbaseposition.html": {
    "href": "getsquadbaseposition.html",
    "title": "getSquadBasePosition",
    "keywords": "getSquadBasePosition Gets squad position without additional attack movement. Code Information Name: getSquadBasePosition Scope: Global PAC Instruction (Binary): 25 16 42 00 Assembly Address in Memory : 0x891de1c Parameters (int *)squad_handle (8 bytes) : The squad handle of the squad to get the position. (float *)position (8 bytes) : Variable to store the current X position of the squad. Example Here is one example in hex: 25 16 42 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getSquadBasePosition((int *)iVar0, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891de1c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { puVar1 = (undefined4 *)offset__10(iVar3 + 0x260); *puVar2 = *puVar1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsquadclassid.html": {
    "href": "getsquadclassid.html",
    "title": "getSquadClassId",
    "keywords": "getSquadClassId Gets class ID of the given squad. Code Information Name: getSquadClassId Scope: Global PAC Instruction (Binary): 25 16 b8 00 Assembly Address in Memory : 0x89234fc Parameters (int *)squad_handle (8 bytes) : The squad handle to get the class ID. (int *)destination (8 bytes) : Variable to store the class ID. -1 if the class is invalid. Example Here is one example in hex: 25 16 b8 00 / 04 00 00 00 / 03 00 00 00 / 04 00 00 00 / 04 00 00 00 Which is interpreted as: getSquadClassId((int *)iVar3, (int *)iVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089234fc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) && (iVar3 != 0)) { *puVar2 = *(undefined4 *)(iVar3 + 0x18c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsquadhandle.html": {
    "href": "getsquadhandle.html",
    "title": "getSquadHandle",
    "keywords": "getSquadHandle Gets squad handle by given generator and ID in the generator. getUnitSquadHandle is more frequently used. Code Information Name: getSquadHandle Scope: Mission PAC Instruction (Binary): 25 1f 30 00 Assembly Address in Memory : 0x8b5ec20 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int *)destination (8 bytes) : Variable to store the squad handle. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5ec20(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0xffffffff; iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { uVar5 = FUN_Mission__08b57b08(iVar4,*puVar2); *puVar3 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getstagegimmickparam.html": {
    "href": "getstagegimmickparam.html",
    "title": "getStageGimmickParam",
    "keywords": "getStageGimmickParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getStageGimmickParam Scope: Global PAC Instruction (Binary): 25 16 1e 00 Assembly Address in Memory : 0x891ac50 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 1e 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getStageGimmickParam((int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ac50(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Get_Some_Flag(1); uVar4 = Equip::Item::Divide_By_10000d (*(int *)(*piVar1 * 0xc + *(int *)(iVar3 + 0x44) + 0x82c) >> 1); *puVar2 = uVar4; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getstageruleparam.html": {
    "href": "getstageruleparam.html",
    "title": "getStageRuleParam",
    "keywords": "getStageRuleParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getStageRuleParam Scope: Global PAC Instruction (Binary): 25 16 1d 00 Assembly Address in Memory : 0x891ab78 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) Example Here is one example in hex: 25 16 1d 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: getStageRuleParam((int *)iVar0, (int *)iVar1, (int *)iVar2, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ab78(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int *piVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = Get_Some_Flag(1); iVar5 = *(int *)(iVar5 + 0x44); *piVar1 = (int)*(char *)(iVar5 + 0x822); *piVar2 = (int)*(char *)(iVar5 + 0x823); *piVar3 = (int)*(short *)(iVar5 + 0x826); *piVar4 = (int)*(char *)(iVar5 + 0x821); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getstatusinfo.html": {
    "href": "getstatusinfo.html",
    "title": "getStatusInfo",
    "keywords": "getStatusInfo Gets stamina information of a target. Code Information Name: getStatusInfo Scope: Global PAC Instruction (Binary): 25 17 24 00 Assembly Address in Memory : 0x8913178 Parameters (int *)handle (8 bytes) : Handle of the target to get the stamina information. (int *)data_type (8 bytes) : Expected 0~2. 0 gives max stamina (int), 1 gives current stamina (int), 2 gives stamina rate (float). (int/float *)destination (8 bytes) : Variable to store the stamina information. If data_type is 2, float is expected. Example Here is one example in hex: 25 17 24 00 / 08 00 00 00 / 1f 00 00 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getStatusInfo(((global)int *)giVar31, (int)1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913178(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; float *pfVar3; int iVar4; float *pfVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); if (param_1 == 0) { pfVar5 = (float *)0x0; } else { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 == 0) { pfVar5 = (float *)0x0; } else { pfVar5 = *(float **)(iVar4 + 0xcc); if (pfVar5 == (float *)0x0) { pfVar5 = (float *)0x0; } } } if (pfVar5 != (float *)0x0) { iVar4 = *piVar2; if (iVar4 == 0) { *pfVar3 = *pfVar5; //max stamina } else if (iVar4 == 1) { *pfVar3 = pfVar5[1]; //current stamina } else if (iVar4 == 2) { *pfVar3 = (float)(int)pfVar5[1] / (float)(int)*pfVar5; //stamina percentage } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsubjecthandle.html": {
    "href": "getsubjecthandle.html",
    "title": "getSubjectHandle",
    "keywords": "getSubjectHandle Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSubjectHandle Scope: Global PAC Instruction (Binary): 25 17 6b 00 Assembly Address in Memory : 0x891877c Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 17 6b 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getSubjectHandle((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891877c(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = -1; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*(int *)(iVar3 + 0x80) != 0)) { *piVar2 = (int)*(short *)(*(int *)(iVar3 + 0x80) + 0x78); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsubjectplayerid.html": {
    "href": "getsubjectplayerid.html",
    "title": "getSubjectPlayerId",
    "keywords": "getSubjectPlayerId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSubjectPlayerId Scope: Global PAC Instruction (Binary): 25 17 6c 00 Assembly Address in Memory : 0x8918838 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 6c 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: getSubjectPlayerId((int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08918838(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); if (((iVar4 == 9) && (iVar3 != 0)) && (*(int *)(iVar3 + 0xa14) != 0)) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 0xa14) + 0x188); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsummonplayerid.html": {
    "href": "getsummonplayerid.html",
    "title": "getSummonPlayerId",
    "keywords": "getSummonPlayerId Gets the player ID who is currently summoning. Code Information Name: getSummonPlayerId Scope: Global PAC Instruction (Binary): 25 16 13 01 Assembly Address in Memory : 0x892952c Parameters (int)summon_side (8 bytes) : Summoning side. 0 is blue, 1 is red side. (int *)summon_player_id (8 bytes) : -1 if nobody is summoning. Example Here is one example in hex: 25 16 13 01 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getSummonPlayerId((int)0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892952c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,*puVar1), iVar3 != 0)) && (iVar3 != -0x170)) && (((int *)(iVar3 + 0x178) != (int *)0x0 && (*(int *)(iVar3 + 0x178) == 8)))) { *puVar2 = *(undefined4 *)(iVar3 + 0x184); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getswitchwaittime.html": {
    "href": "getswitchwaittime.html",
    "title": "getSwitchWaitTime",
    "keywords": "getSwitchWaitTime Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSwitchWaitTime Scope: Global PAC Instruction (Binary): 25 19 1a 00 Assembly Address in Memory : 0x8942850 Parameters (undefined4)Var0 (8 bytes) (float)Var1 (8 bytes) (uint)Var2 (8 bytes) Example Here is one example in hex: 25 19 1a 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 / 04 00 00 00 / 15 00 00 00 Which is interpreted as: getSwitchWaitTime((int *)iVar0, (float *)fVar0, (int *)iVar21) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942850(int param_1,undefined4 param_2) { undefined4 *puVar1; float *pfVar2; uint *puVar3; int iVar4; uint uVar5; int *piVar6; int iVar7; uint uVar8; float fVar9; float fVar10; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } *pfVar2 = 0.0; *puVar3 = 0; if (((iVar4 != 0) && (piVar6 = *(int **)(iVar4 + 0x1f0), piVar6 != (int *)0x0)) && (uVar8 = 0, piVar6[1] != 0)) { iVar7 = 0; do { if (*(int *)(*piVar6 + iVar7 + 0x28) == 4) { fVar9 = (float)FUN_088ce2d4(iVar4,0); fVar10 = (float)FUN_08875d78(*(undefined4 *)(*piVar6 + iVar7)); *pfVar2 = fVar10; *puVar3 = (uint)(fVar9 < *pfVar2 + 0.06666667); uVar5 = piVar6[1]; } else { uVar5 = piVar6[1]; } uVar8 = uVar8 + 1; iVar7 = iVar7 + 0x30; } while (uVar8 < uVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsymbolmarkid.html": {
    "href": "getsymbolmarkid.html",
    "title": "getSymbolMarkId",
    "keywords": "getSymbolMarkId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSymbolMarkId Scope: Global PAC Instruction (Binary): 25 16 df 00 Assembly Address in Memory : 0x892652c Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 df 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getSymbolMarkId((int *)iVar1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892652c(undefined4 param_1,undefined4 param_2) { bool bVar1; undefined4 *puVar2; int *piVar3; int iVar4; int iVar5; int iVar6; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar3 = (int *)Pac_Get_Param(param_2,1,1,4); iVar6 = *piVar3; *puVar2 = 0xffffffff; iVar4 = Get_Some_Flag(1); iVar4 = *(int *)(iVar4 + 0x44); if (*(char *)(iVar4 + 0x24b4) == '\\0') { if (iVar6 == 0) { iVar5 = Save::Get_Save_BaseAddr(1); iVar5 = return__0x1c(*(undefined4 *)(iVar5 + 0x50)); *puVar2 = *(undefined4 *)(iVar5 + 0x2187c); } } else { iVar5 = FUN_089880b8(iVar4 + 0x850,iVar6); *puVar2 = *(undefined4 *)(iVar5 + 4); } if (iVar6 == 1) { bVar1 = true; if ((*(char *)(iVar4 + 0x24b4) != '\\0') && (*(char *)(iVar4 + 0x81c) != '\\0')) { bVar1 = false; } if (bVar1) { *puVar2 = 0x34; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsyncgameflagresult.html": {
    "href": "getsyncgameflagresult.html",
    "title": "getSyncGameFlagResult",
    "keywords": "getSyncGameFlagResult Checks if succesfully joined to the other's hideout. Guest only. Code Information Name: getSyncGameFlagResult Scope: Azito PAC Instruction (Binary): 25 1c 27 00 Assembly Address in Memory : 0x8b4fe28 Parameters (int *)status (8 bytes) : Variable to store the joining status, 1 joining, -1 failed to join, 0 succesfully joined. Example Here is one example in hex: 25 1c 27 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getSyncGameFlagResult((int *)iVar0) 0000CB08 251C2600:startSyncGameFlag() 0000CB0C 25000F00:cmd_waitFrame(2:1) 0000CB18 251C2700:getSyncGameFlagResult(4:0) 0000CB24 25001700:cmd_ifEQ(4:0, 1.0, 1:CB0C) 0000CB3C 25001B00:cmd_ifLS(4:0, 0.0, 1:99EC) 0000CB54 25000200:cmd_jmp(1:99DC) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fe28(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x214) + 0x38) != 0) { uVar2 = FUN_Azito__08b546d8(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsynchropoint.html": {
    "href": "getsynchropoint.html",
    "title": "getSynchroPoint",
    "keywords": "getSynchroPoint Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSynchroPoint Scope: Global PAC Instruction (Binary): 25 0c 11 00 Assembly Address in Memory : 0x8970b6c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0c 11 00 / 04 00 00 00 / 0c 00 00 00 Which is interpreted as: getSynchroPoint((int *)iVar12) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970b6c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar1 = 0; *puVar1 = 0; if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x6b4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getsyncvalue.html": {
    "href": "getsyncvalue.html",
    "title": "getSyncValue",
    "keywords": "getSyncValue Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getSyncValue Scope: Global PAC Instruction (Binary): 25 21 1d 00 Assembly Address in Memory : 0x89b33a4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b33a4(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar5 != 0) { puVar1 = (undefined4 *)FUN_08977d70(iVar5,*puVar2); *puVar3 = *puVar1; *puVar4 = puVar1[1]; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettalkflag.html": {
    "href": "gettalkflag.html",
    "title": "getTalkFlag",
    "keywords": "getTalkFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getTalkFlag Scope: Global PAC Instruction (Binary): 25 0a 42 00 Assembly Address in Memory : 0x894d304 Parameters (uint)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 0a 42 00 / 02 00 00 00 / 03 00 00 00 / 08 00 00 00 / 5d 00 00 00 Which is interpreted as: getTalkFlag((int)3, ((global)int *)giVar93) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d304(undefined4 param_1,undefined4 param_2) { int iVar1; uint *puVar2; uint *puVar3; int iVar4; byte *pbVar5; uint uVar6; uint uVar7; iVar1 = FUN_0883c070(param_2); puVar2 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar4 = Save::Get_Save_BaseAddr(1); uVar7 = *puVar2 & 7; uVar6 = *puVar2 >> 3; if (((int)(uint)*(byte *)((*puVar3 >> 3) + *(int *)(iVar4 + 0x50) + 0x2b008) >> (*puVar3 & 7) & 1U ) == 0) { pbVar5 = (byte *)(*(int *)(iVar1 + 4) + uVar6); *pbVar5 = *pbVar5 & ((byte)(1 << uVar7) ^ 0xff); } else { pbVar5 = (byte *)(*(int *)(iVar1 + 4) + uVar6); *pbVar5 = *pbVar5 | (byte)(1 << uVar7); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getthunderlevel.html": {
    "href": "getthunderlevel.html",
    "title": "getThunderLevel",
    "keywords": "getThunderLevel Gets the thunder frequency. This works both in hideout and during mission. Code Information Name: getThunderLevel Scope: Global PAC Instruction (Binary): 25 16 80 00 Assembly Address in Memory : 0x89212d4 Parameters (float)frequency (8 bytes) : How frequent the thunder occurs, the value is between 0~1. 0 means no thunder. With maximum thunder frequency (1), thunder hits around once per 6 seconds (1.5 command measurement). Example Here is one example in hex: 25 16 80 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getThunderLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089212d4(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x25c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettimersec.html": {
    "href": "gettimersec.html",
    "title": "getTimerSec",
    "keywords": "getTimerSec Gets current seconds of the current timer. Code Information Name: getTimerSec Scope: Global PAC Instruction (Binary): 25 16 a1 00 Assembly Address in Memory : 0x8922878 Parameters (int *)time (8 bytes) : Variable to store the current time in the timer, as seconds. Example Here is one example in hex: 25 16 a1 00 / 20 00 00 00 / 0b 00 00 00 Which is interpreted as: getTimerSec((float *)fVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922878(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (*(int *)(iVar2 + 100) != 0)) { uVar3 = func_0x08b32f08(); *puVar1 = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettroopherotype.html": {
    "href": "gettroopherotype.html",
    "title": "getTroopHeroType",
    "keywords": "getTroopHeroType Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getTroopHeroType Scope: Global PAC Instruction (Binary): 25 16 40 01 Assembly Address in Memory : 0x892b1b8 Parameters (uint)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 40 01 / 04 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getTroopHeroType((int *)iVar2, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892b1b8(undefined4 param_1,undefined4 param_2) { uint *puVar1; int *piVar2; int iVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *puVar1 = 0; if ((-1 < *piVar2) && (*piVar2 < 2)) { iVar3 = Get_Some_Flag(1); *puVar1 = *(int *)(*(int *)(iVar3 + 0x44) + *piVar2 * 0x58a4 + 0x2558) < 0x1c ^ 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettroopsign_25164101.html": {
    "href": "gettroopsign_25164101.html",
    "title": "getTroopSign (25164101)",
    "keywords": "getTroopSign (25164101) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getTroopSign Scope: Global PAC Instruction (Binary): 25 16 41 01 Assembly Address in Memory : 0x892b274 Parameters (undefined4)Var0 (8 bytes) (float)Var1 (8 bytes) Example Here is one example in hex: 25 16 41 01 / 04 00 00 00 / 0a 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getTroopSign((int *)iVar10, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892b274(int param_1,undefined4 param_2) { undefined4 *puVar1; float *pfVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); *pfVar2 = 0.0; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if (((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,*puVar1), iVar3 != 0)) && (iVar3 != -0x170)) { *pfVar2 = (float)*(int *)(iVar3 + 0x288); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettroopsign_25175f00.html": {
    "href": "gettroopsign_25175f00.html",
    "title": "getTroopSign (25175f00)",
    "keywords": "getTroopSign (25175f00) Other functions have the same name. Check the Disambiguation page to find them. Gets direction as terms of troop. This works on head-on VS mission. Otherwise it always returns 1. Code Information Name: getTroopSign Scope: Global PAC Instruction (Binary): 25 17 5f 00 Assembly Address in Memory : 0x8917c4c Parameters (int *)handle (8 bytes) (int *)result (8 bytes) : Result to store. 1 means blue team or going forward. Example Here is one example in hex: 25 17 5f 00 / 04 00 00 00 / 0a 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: getTroopSign((int *)iVar10, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917c4c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0x3f800000; if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x90); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettrooptopposx.html": {
    "href": "gettrooptopposx.html",
    "title": "getTroopTopPosX",
    "keywords": "getTroopTopPosX Gets current position of the troop with attack movement. Without additional attack movement, check getPlayerTroopBasePosition. Code Information Name: getTroopTopPosX Scope: Global PAC Instruction (Binary): 25 16 34 00 Assembly Address in Memory : 0x891cde4 Parameters (float *)position (8 bytes) : Variable to store the position of the troop. (bool)side (8 bytes) : Should be 0 for Player/Blue team, 1 for Enemy/Red team, but somehow results same value. Example Here is one example in hex: 25 16 34 00 / 20 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getTroopTopPosX((float *)fVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891cde4(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; undefined4 *puVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *puVar1 = 0; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,0), iVar3 != 0)) { if (*piVar2 == 0) { puVar4 = (undefined4 *)FUN_088e21d0(iVar3); } else { puVar4 = (undefined4 *)FUN_088e2208(iVar3); } if (puVar4 != (undefined4 *)0x0) { *puVar1 = *puVar4; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettrooptopposx_enemy.html": {
    "href": "gettrooptopposx_enemy.html",
    "title": "getTroopTopPosX_Enemy",
    "keywords": "getTroopTopPosX_Enemy Gets troop position (including attack movement speed) from the enemies. Code Information Name: getTroopTopPosX_Enemy Scope: Global PAC Instruction (Binary): 25 16 ce 00 Assembly Address in Memory : 0x89257c8 Parameters (float *)position (8 bytes) : Variable to store the position of the troop. Example Here is one example in hex: 25 16 ce 00 / 20 00 00 00 / 0e 00 00 00 Which is interpreted as: getTroopTopPosX_Enemy((float *)fVar14) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089257c8(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 *puVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0xf8); if (iVar2 == 0) { iVar2 = 0; } } if (((iVar2 != 0) && (iVar2 = FUN_088a8650(iVar2,1), iVar2 != 0)) && (puVar3 = (undefined4 *)FUN_088e2208(iVar2), puVar3 != (undefined4 *)0x0)) { *puVar1 = *puVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettrooptopposy.html": {
    "href": "gettrooptopposy.html",
    "title": "getTroopTopPosY",
    "keywords": "getTroopTopPosY Gets current Y (up or down) position of the troop with attack movement. Code Information Name: getTroopTopPosY Scope: Global PAC Instruction (Binary): 25 16 04 01 Assembly Address in Memory : 0x8928300 Parameters (bool)side (8 bytes) : Should be 0 for Player/Blue team, 1 for Enemy/Red team. (float *)position (8 bytes) : Variable to store the position of the troop. Note the usage order is reversed from getTroopTopPosX. Example Here is one example in hex: 25 16 04 01 / 02 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getTroopTopPosY((int)0, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928300(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } iVar3 = FUN_088a8650(iVar3,*puVar1); if ((iVar3 != 0) && (iVar3 = FUN_088e21c8(iVar3), iVar3 != 0)) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 200) + 0xc4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gettrooptype_gimmickuid.html": {
    "href": "gettrooptype_gimmickuid.html",
    "title": "getTroopType_GimmickUID",
    "keywords": "getTroopType_GimmickUID Gets the troop type where the gimmick is belong to. Code Information Name: getTroopType_GimmickUID Scope: Global PAC Instruction (Binary): 25 16 d0 00 Assembly Address in Memory : 0x89259f0 Parameters (int)gimmick_identifier (8 bytes) : User defined any gimmick identifier, from addGimmick. (int *)troop_type (8 bytes) : Variable to store the troop type of the gimmick. Example Here is one example in hex: 25 16 d0 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 04 00 00 00 Which is interpreted as: getTroopType_GimmickUID((int *)iVar1, (int *)iVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089259f0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if ((iVar3 != 0) && (iVar3 = Get_Gimmick(iVar3,*puVar1), iVar3 != 0)) { *piVar2 = (int)*(char *)(iVar3 + 0x98); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunit_gameplayerid.html": {
    "href": "getunit_gameplayerid.html",
    "title": "getUnit_gamePlayerId",
    "keywords": "getUnit_gamePlayerId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getUnit_gamePlayerId Scope: Global PAC Instruction (Binary): 25 16 20 01 Assembly Address in Memory : 0x892a264 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 20 01 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 0f 00 00 00 Which is interpreted as: getUnit_gamePlayerId((int *)iVar2, (int *)iVar15) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a264(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; int iVar4; int iVar5; int iVar6; int iVar7; int iVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { iVar8 = 0; do { iVar4 = FUN_088a8650(iVar3,iVar8); if (iVar4 != 0) { iVar7 = 0; do { iVar5 = FUN_088df588(iVar4,iVar7); if (((iVar5 != 0) && (*piVar1 == *(int *)(iVar5 + 0x188))) && (iVar6 = FUN_088c5348(iVar5,0), iVar6 != 0)) { iVar3 = FUN_088c5348(iVar5,0); *piVar2 = (int)*(short *)(iVar3 + 0x78); PAC::PAC_setCmdId(param_2,0); return; } iVar7 = iVar7 + 1; } while (iVar7 < 4); } iVar8 = iVar8 + 1; } while (iVar8 < 2); } *piVar2 = -1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitctrlactivity.html": {
    "href": "getunitctrlactivity.html",
    "title": "getUnitCtrlActivity",
    "keywords": "getUnitCtrlActivity Gets current squad action of a unit. This gets the \"acting\" ID only. For actual unit attack status, use getUnitCtrlCurrentActType. Code Information Name: getUnitCtrlActivity Scope: Mission PAC Instruction (Binary): 25 1f 2b 00 Assembly Address in Memory : 0x8b5e6a8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)command_id (8 bytes) : Command ID of it, but range of 0~2 (march, defend, attack) or nothing (-1). (int *)sqaudactivity_id (8 bytes) : Variable to store the ID from squadActivityParam. Example Here is one example in hex: 25 1f 2b 00 / 04 00 00 00 / 2b 00 00 00 / 04 00 00 00 / 2a 00 00 00 / 04 00 00 00 / 31 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getUnitCtrlActivity((int *)iVar43, (int *)iVar42, (int *)iVar49, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e6a8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; undefined4 *puVar4; int iVar5; undefined4 uVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); *puVar4 = 0xffffffff; if (-1 < *piVar3) { iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8), *piVar1); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { uVar6 = FUN_Mission__08b57410(iVar5,*puVar2,*piVar3); *puVar4 = uVar6; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitctrlcurrentacttype.html": {
    "href": "getunitctrlcurrentacttype.html",
    "title": "getUnitCtrlCurrentActType",
    "keywords": "getUnitCtrlCurrentActType Gets what the unit is currently doing. Code Information Name: getUnitCtrlCurrentActType Scope: Mission PAC Instruction (Binary): 25 1f 2c 00 Assembly Address in Memory : 0x8b5e7d0 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int *)command_id (8 bytes) : Variable to store the Command ID performing now. For PvE enemy, the action is limited to march/defend/attack or nothing (-1). Example Here is one example in hex: 25 1f 2c 00 / 04 00 00 00 / 2b 00 00 00 / 04 00 00 00 / 2a 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getUnitCtrlCurrentActType((int *)iVar43, (int *)iVar42, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e7d0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0xffffffff; iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8), *piVar1); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { uVar5 = FUN_Mission__08b57630(iVar4,*puVar2); *puVar3 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunithandle.html": {
    "href": "getunithandle.html",
    "title": "getUnitHandle",
    "keywords": "getUnitHandle Obtains handle of the certain unit. The ID can be used for getting the unit status, or controlling the unit through PAC, e.g. Status effect. Code Information Name: getUnitHandle Scope: Global PAC Instruction (Binary): 25 16 3d 00 Assembly Address in Memory : 0x891d7f4 Parameters (int *)destination (8 bytes) : Destination to save the unit handle. (int *)squad_handle_id (8 bytes) : Value obtained from getUnitSquadHandle or getPlayerSquadHandle. (int)index (8 bytes) : Index in squad, Usually this is zero. Example Here is one example in hex: 25 16 3d 00 / 04 00 00 00 / 06 00 00 00 / 04 00 00 00 / 03 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getUnitHandle((int *)iVar6, (int *)iVar3, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d7f4(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; int iVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar1 = -1; iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) { iVar5 = *piVar3; if (iVar5 == -1) { if (*(int *)(iVar4 + 0x490) != 0) { *piVar1 = (int)*(short *)(*(int *)(iVar4 + 0x490) + 0x78); } } else { iVar6 = FUN_088c5340(iVar4); if ((iVar5 < iVar6) && (iVar4 = FUN_088c5348(iVar4,iVar5), iVar4 != 0)) { *piVar1 = (int)*(short *)(iVar4 + 0x78); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunithandle_trooptoppos.html": {
    "href": "getunithandle_trooptoppos.html",
    "title": "getUnitHandle_TroopTopPos",
    "keywords": "getUnitHandle_TroopTopPos Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getUnitHandle_TroopTopPos Scope: Global PAC Instruction (Binary): 25 16 f0 00 Assembly Address in Memory : 0x8926b20 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 f0 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: getUnitHandle_TroopTopPos((int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926b20(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar1 = -1; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,0), iVar3 != 0)) { if (*piVar2 == 0) { iVar3 = FUN_088e21c8(iVar3); if (iVar3 != 0) { *piVar1 = (int)*(short *)(iVar3 + 0x78); } } else { iVar3 = FUN_088e2234(iVar3); if (iVar3 != 0) { *piVar1 = (int)*(short *)(iVar3 + 0x78); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitinfo_unituid.html": {
    "href": "getunitinfo_unituid.html",
    "title": "getUnitInfo_UnitUID",
    "keywords": "getUnitInfo_UnitUID Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getUnitInfo_UnitUID Scope: Global PAC Instruction (Binary): 25 16 ed 00 Assembly Address in Memory : 0x8925da0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925da0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); *puVar2 = 0xffffffff; *piVar3 = -1; *puVar4 = 0xffffffff; *puVar5 = 0; iVar6 = *(int *)(param_1 + 0x10); if (iVar6 == 0) { iVar6 = 0; } else { if (iVar6 == 0) { iVar6 = 0; } iVar6 = *(int *)(iVar6 + 0xf8); if (iVar6 == 0) { iVar6 = 0; } } if ((iVar6 != 0) && (iVar6 = FUN_088a8798(iVar6,*puVar1), iVar6 != 0)) { uVar7 = (**(code **)(*(int *)(iVar6 + 4) + 0x13c))(iVar6); *puVar2 = uVar7; if (*(int *)(iVar6 + 0xa14) != 0) { *piVar3 = (int)*(short *)(*(int *)(iVar6 + 0xa14) + 0x78); } uVar7 = FUN_088b8f6c(iVar6); *puVar4 = uVar7; *puVar5 = *(undefined4 *)(*(int *)(iVar6 + 200) + 0xc0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitmotionindex.html": {
    "href": "getunitmotionindex.html",
    "title": "getUnitMotionIndex",
    "keywords": "getUnitMotionIndex Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getUnitMotionIndex Scope: Global PAC Instruction (Binary): 25 16 26 00 Assembly Address in Memory : 0x891be1c Parameters (uint)Var0 (8 bytes) Example Here is one example in hex: 25 16 26 00 / 04 00 00 00 / 04 00 00 00 Which is interpreted as: getUnitMotionIndex((int *)iVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891be1c(int param_1,undefined4 param_2) { uint *puVar1; undefined4 uVar2; int iVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); uVar2 = FUN_088a8650(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xf8),0); uVar2 = FUN_088df588(uVar2,0); iVar3 = FUN_088c5348(uVar2,0); if (iVar3 != 0) { *puVar1 = (uint)*(ushort *)(*(int *)(iVar3 + 200) + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitparam_250a4700.html": {
    "href": "getunitparam_250a4700.html",
    "title": "getUnitParam (250a4700)",
    "keywords": "getUnitParam (250a4700) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getUnitParam Scope: Global PAC Instruction (Binary): 25 0a 47 00 Assembly Address in Memory : 0x894d62c Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 0a 47 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: getUnitParam((int)0, (int)0, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d62c(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar6 = *piVar1; iVar5 = *piVar2; iVar4 = Get_Some_Flag(1); iVar4 = *(int *)(iVar4 + 0x44); *puVar3 = 0; iVar4 = iVar5 * 0x1620 + iVar4 + iVar6 * 0x58a4; if (*(int *)(iVar4 + 0x2554) != 0) { *puVar3 = *(undefined4 *)(iVar4 + 0x2558); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitparam_25161b00.html": {
    "href": "getunitparam_25161b00.html",
    "title": "getUnitParam (25161b00)",
    "keywords": "getUnitParam (25161b00) Other functions have the same name. Check the Disambiguation page to find them. Gets unit information by troop and index. Useful for checking if certain effects or gimmicks should be loaded. Code Information Name: getUnitParam Scope: Global PAC Instruction (Binary): 25 16 1b 00 Assembly Address in Memory : 0x891a9d0 Parameters (int)troop_side (8 bytes) : 0 is player/blue side, 1 is enemy/red side. (int)int_index (8 bytes) : Index of the unit. For player with hideout closed For pons, 0 is hero, 1 is ton, 2 is chin, 3 is kan For multi, host is 0 and guests are 1, 2, 3 in order. please describe what is 4. (int *)class_id (8 bytes) : Variable to store the Class ID of the unit. (uint *)is_hero (8 bytes) : Variable to store if the unit is hero. 1 if the unit is hero, otherwise zero. Example Here is one example in hex: 25 16 1b 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getUnitParam((int)0, (int)0, (int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a9d0(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; uint *puVar4; int iVar5; undefined4 uVar6; int iVar7; int iVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (uint *)Pac_Get_Param(param_2,3,1,4); iVar8 = *piVar1; iVar7 = *piVar2; iVar5 = Get_Some_Flag(1); iVar5 = *(int *)(iVar5 + 0x44); *puVar4 = 0; *puVar3 = 0; iVar5 = iVar7 * 0x1620 + iVar5 + iVar8 * 0x58a4; if (*(int *)(iVar5 + 0x2554) != 0) { uVar6 = Param::Get_Charaparam_Id (*(undefined4 *)(iVar5 + 0x2558),*(int *)(iVar5 + 0x2560) == 0,0); FUN_0895e9b8(uVar6,*(undefined4 *)(iVar5 + *(int *)(iVar5 + 0x2558) * 0x84 + 0x2578)); *puVar4 = (uint)(*(int *)(iVar5 + 0x2560) == 0); *puVar3 = *(undefined4 *)(iVar5 + 0x2558); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitsquadhandle.html": {
    "href": "getunitsquadhandle.html",
    "title": "getUnitSquadHandle",
    "keywords": "getUnitSquadHandle Gets handle by the unique ID of the reqactor. Does not work well gimmick reqActor. For non-unit object, use getActorHandle Code Information Name: getUnitSquadHandle Scope: Global PAC Instruction (Binary): 25 16 37 00 Assembly Address in Memory : 0x891d040 Parameters (int *)destination (8 bytes) : Variable to store the squad handle. (int)reqactor_id (8 bytes) : Unique ID of the reqactor. Example Here is one example in hex: 25 16 37 00 / 08 00 00 00 / a8 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getUnitSquadHandle(((global)int *)giVar168, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d040(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *piVar1 = -1; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((iVar3 != 0) && (iVar3 = Get_Squad_From_ReqUniqueID(iVar3,*puVar2), iVar3 != 0)) { *piVar1 = (int)*(short *)(iVar3 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitsquadhandlefromchara.html": {
    "href": "getunitsquadhandlefromchara.html",
    "title": "getUnitSquadHandleFromChara",
    "keywords": "getUnitSquadHandleFromChara Gets squad handle of an unit. Code Information Name: getUnitSquadHandleFromChara Scope: Global PAC Instruction (Binary): 25 16 38 00 Assembly Address in Memory : 0x891d100 Parameters (int *)destination (8 bytes) : Variable to store the squad handle. (int *)unit_handle (8 bytes) : Unit handle, obtained from e.g. getUnitHandle. Example Here is one example in hex: 25 16 38 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getUnitSquadHandleFromChara((int *)iVar1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d100(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *piVar1 = -1; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { *piVar1 = (int)*(short *)(*(int *)(iVar3 + 0xa14) + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getunitweight.html": {
    "href": "getunitweight.html",
    "title": "getUnitWeight",
    "keywords": "getUnitWeight Gets weight of the unit by given handle. Works on unit only. Code Information Name: getUnitWeight Scope: Global PAC Instruction (Binary): 25 16 15 01 Assembly Address in Memory : 0x89298e0 Parameters (int *)unit_handle (8 bytes) : Handle of an unit. (float *)destination (8 bytes) : Varible to store the weight of the unit. Example Here is one example in hex: 25 16 15 01 / 04 00 00 00 / 41 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: getUnitWeight((int *)iVar65, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089298e0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if ((((*piVar1 != -1) && (iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar1,1), iVar3 != 0 )) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) && (*(int *)(iVar3 + 0xcc) != 0)) { *puVar2 = *(undefined4 *)(*(int *)(*(int *)(iVar3 + 0xcc) + 0x1c) + 0xb0); // 0xb0 is weight } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversus02shootingmissilecount.html": {
    "href": "getversus02shootingmissilecount.html",
    "title": "getVersus02shootingMissileCount",
    "keywords": "getVersus02shootingMissileCount Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getVersus02shootingMissileCount Scope: Global PAC Instruction (Binary): 25 16 26 01 Assembly Address in Memory : 0x8927778 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (int)Var4 (8 bytes) Example Here is one example in hex: 25 16 26 01 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 4c 04 00 00 / 02 00 00 00 / 7e 04 00 00 / 02 00 00 00 / 0a 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getVersus02shootingMissileCount((int)3, (int)1100, (int)1150, (int)10, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927778(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int *piVar4; int *piVar5; int iVar6; int iVar7; int iVar8; int iVar9; int iVar10; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); iVar6 = *(int *)(param_1 + 0x10); iVar9 = *piVar4; iVar10 = 0; if (iVar6 == 0) { iVar6 = 0; } else { if (iVar6 == 0) { iVar6 = 0; } iVar6 = *(int *)(iVar6 + 0x108); if (iVar6 == 0) { iVar6 = 0; } } if (iVar6 != 0) { if (*piVar1 == 1) { iVar7 = *piVar1; } else { iVar7 = 0; if (0 < iVar9) { iVar8 = *piVar2; while( true ) { iVar8 = Get_Gimmick(iVar6,iVar7 + iVar8); if (((iVar8 != 0) && (*(char *)(iVar8 + 0x9c) != '\\0')) && (iVar8 = FUN_088ce294(iVar8,0), iVar8 == 1)) { iVar10 = iVar10 + 1; } iVar7 = iVar7 + 1; if (iVar9 <= iVar7) break; iVar8 = *piVar2; } } iVar7 = *piVar1; } if ((iVar7 != 0) && (iVar7 = 0, 0 < iVar9)) { iVar8 = *piVar3; while( true ) { iVar8 = Get_Gimmick(iVar6,iVar7 + iVar8); if (((iVar8 != 0) && (*(char *)(iVar8 + 0x9c) != '\\0')) && (iVar8 = FUN_088ce294(iVar8,0), iVar8 == 1)) { iVar10 = iVar10 + 1; } iVar7 = iVar7 + 1; if (iVar9 <= iVar7) break; iVar8 = *piVar3; } } } *piVar5 = iVar10; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversus03rank.html": {
    "href": "getversus03rank.html",
    "title": "getVersus03Rank",
    "keywords": "getVersus03Rank Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getVersus03Rank Scope: Global PAC Instruction (Binary): 25 16 33 01 Assembly Address in Memory : 0x8927fdc Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 33 01 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: getVersus03Rank((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927fdc(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; char cVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = -1; if (((*(int *)(param_1 + 0x10) != 0) && (iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8), iVar4 != 0)) && (iVar4 = *(int *)(iVar4 + 0x58), iVar4 != 0)) { iVar5 = *piVar1; if (iVar5 < 0) { cVar3 = -1; } else if (iVar5 < 8) { cVar3 = *(char *)(iVar5 + iVar4 + 0x4b); } else { cVar3 = -1; } *piVar2 = (int)cVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversus04panelactioncount.html": {
    "href": "getversus04panelactioncount.html",
    "title": "getVersus04PanelActionCount",
    "keywords": "getVersus04PanelActionCount Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getVersus04PanelActionCount Scope: Global PAC Instruction (Binary): 25 16 fb 00 Assembly Address in Memory : 0x8924e88 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924e88(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar2 != 0) && (iVar2 = *(int *)(iVar2 + 0x68), iVar2 != 0)) { *puVar1 = *(undefined4 *)(iVar2 + 0x54); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversus04panelcenter.html": {
    "href": "getversus04panelcenter.html",
    "title": "getVersus04PanelCenter",
    "keywords": "getVersus04PanelCenter Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getVersus04PanelCenter Scope: Global PAC Instruction (Binary): 25 16 35 01 Assembly Address in Memory : 0x8925434 Parameters (int)Var0 (8 bytes) (float)Var1 (8 bytes) (float)Var2 (8 bytes) (float)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925434(undefined4 param_1,undefined4 param_2) { int *piVar1; float *pfVar2; float *pfVar3; float *pfVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); *pfVar4 = *pfVar3 * 0.5 + *pfVar2 + *pfVar3 * (float)*piVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversus04panelindexfrompos.html": {
    "href": "getversus04panelindexfrompos.html",
    "title": "getVersus04PanelIndexFromPos",
    "keywords": "getVersus04PanelIndexFromPos Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getVersus04PanelIndexFromPos Scope: Global PAC Instruction (Binary): 25 16 36 01 Assembly Address in Memory : 0x8925500 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (float)Var2 (8 bytes) (float)Var3 (8 bytes) (int)Var4 (8 bytes) (int)Var5 (8 bytes) (float)Var6 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925500(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; float *pfVar3; float *pfVar4; int *piVar5; int *piVar6; float *pfVar7; int iVar8; int iVar9; float *pfVar10; float fVar11; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); pfVar7 = (float *)Pac_Get_Param(param_2,6,1,4); *piVar6 = -1; *pfVar7 = 0.0; iVar8 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar8 == 0) || (iVar9 = (**(code **)(*(int *)(iVar8 + 4) + 0x34))(iVar8), iVar9 != 3)) goto LAB_089256d0; fVar11 = 0.0; if (*piVar2 == 0) { pfVar10 = (float *)offset__10(iVar8 + 0x260); fVar11 = *pfVar10; LAB_08925668: *pfVar7 = fVar11; } else { iVar8 = FUN_088c5348(iVar8,0); if (iVar8 != 0) { if (*(int *)(iVar8 + 200) != 0) { fVar11 = *(float *)(*(int *)(iVar8 + 200) + 0xc0); } goto LAB_08925668; } *pfVar7 = 0.0; } fVar11 = fVar11 - *pfVar3; if ((0.0 <= fVar11) && (fVar11 < (float)(*piVar5 + 1) * *pfVar4)) { iVar8 = (int)*pfVar4; if (iVar8 == 0) { trap(7); } *piVar6 = (int)fVar11 / iVar8; } LAB_089256d0: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversuspkinfo.html": {
    "href": "getversuspkinfo.html",
    "title": "getVersusPKInfo",
    "keywords": "getVersusPKInfo Check if any unit is killed. Any VS mission continuosly calls this. Does not called with VS with pons. Code Information Name: getVersusPKInfo Scope: Global PAC Instruction (Binary): 25 16 14 01 Assembly Address in Memory : 0x8929620 Parameters (int)killed_side (8 bytes) : Killed side, 1 is blue and 2 is red. (int *)killed_unit_index (8 bytes) : Variable to store, Killed enemy index in PVE. Player index starts from 0, PVE DH index starts from 1. (int *)Var2 (8 bytes) : Variable to store. Usually -1 in PVE VS or current player kills the opponent. 4 when the opponent killed the player. Please describe this. (int *)Var3 (8 bytes) : Variable to store. Usually -1 in PVE VS or current player kills the opponent. 0 when the opponent killed the player. Please describe this. Example Here is one example in hex: 25 16 14 01 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: getVersusPKInfo((int *)iVar0, (int *)iVar1, (int *)iVar2, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08929620(int param_1,undefined4 param_2) { char cVar1; int *piVar2; int *piVar3; int *piVar4; undefined4 uVar5; int iVar6; int iVar7; int *piVar8; int iVar9; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); iVar9 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); *piVar2 = -1; *piVar3 = -1; *piVar4 = -1; uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); iVar6 = *(int *)(iVar6 + 100); if ((iVar6 != 0) && (iVar7 = Is_Multi(iVar6), iVar7 != 0)) { iVar7 = Is_Multi(iVar6); if (iVar7 == 0) { cVar1 = '\\0'; } else { cVar1 = FUN_08986d3c(iVar6); } if ((((cVar1 != '\\0') && (iVar6 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2d8) + 0x18), iVar6 != 0)) && (piVar8 = (int *)(iVar6 + 0x9c), piVar8 != (int *)0x0)) && (*piVar8 != 0)) { if (iVar9 < *piVar8) { *piVar2 = (int)*(char *)((int)piVar8 + iVar9 * 3 + 4); *piVar3 = (int)*(char *)((int)piVar8 + iVar9 * 3 + 5); *piVar4 = (int)*(char *)((int)piVar8 + iVar9 * 3 + 6); } else { *piVar8 = 0; *(undefined *)(iVar6 + 0xa0) = 0xff; *(undefined *)(iVar6 + 0xa1) = 0xff; *(undefined *)(iVar6 + 0xa2) = 0xff; *(undefined *)(iVar6 + 0xa3) = 0xff; *(undefined *)(iVar6 + 0xa4) = 0xff; *(undefined *)(iVar6 + 0xa5) = 0xff; *(undefined *)(iVar6 + 0xa6) = 0xff; *(undefined *)(iVar6 + 0xa7) = 0xff; *(undefined *)(iVar6 + 0xa8) = 0xff; *(undefined *)(iVar6 + 0xa9) = 0xff; *(undefined *)(iVar6 + 0xaa) = 0xff; *(undefined *)(iVar6 + 0xab) = 0xff; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversusplayercount.html": {
    "href": "getversusplayercount.html",
    "title": "getVersusPlayerCount",
    "keywords": "getVersusPlayerCount Counts all VS players, including enemies. Code Information Name: getVersusPlayerCount Scope: Global PAC Instruction (Binary): 25 16 31 01 Assembly Address in Memory : 0x892aa40 Parameters (int *)destination (8 bytes) : Variable to store the number of the VS players. Example Here is one example in hex: 25 16 31 01 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: getVersusPlayerCount((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892aa40(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 1; iVar2 = Get_Some_Flag(); iVar2 = *(int *)(iVar2 + 0x44); if ((((iVar2 != 0) && (iVar2 != -0x528)) && (iVar2 != -0x24b4)) && (iVar2 != -0x2540)) { *puVar1 = *(undefined4 *)(iVar2 + 0x2540); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getversusrandindex.html": {
    "href": "getversusrandindex.html",
    "title": "getVersusRandIndex",
    "keywords": "getVersusRandIndex Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getVersusRandIndex Scope: Global PAC Instruction (Binary): 25 16 ef 00 Assembly Address in Memory : 0x892531c Parameters (int...)Vars0 (>= 8 bytes) ... means any amounts of parameter. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892531c(undefined4 param_1,undefined4 param_2) { int *piVar1; int iVar2; uint uVar3; uint uVar4; uint uVar5; int **ppiVar6; int iVar7; int *local_20 [8]; iVar7 = 0; ppiVar6 = local_20; do { piVar1 = (int *)Pac_Get_Param(param_2,iVar7,1,4); *ppiVar6 = piVar1; *piVar1 = -1; iVar7 = iVar7 + 1; ppiVar6 = ppiVar6 + 1; } while (iVar7 < 8); piVar1 = (int *)Pac_Get_Param(param_2,8,1,4); iVar7 = 0; do { iVar2 = zero_if_08aabe38_is_zero(1); uVar3 = Util::Random::Get_Rand_Value(iVar2 + 0x9c8); iVar2 = 0; uVar5 = uVar3 % 9; while( true ) { uVar4 = uVar5 & 7; if (((int)uVar5 < 0) && (uVar4 != 0)) { uVar4 = uVar4 - 8; } if (*local_20[uVar4] == -1) break; iVar2 = iVar2 + 1; if (7 < iVar2) goto LAB_08925400; uVar5 = uVar3 % 9 + iVar2; } iVar2 = iVar7; if (iVar7 == *piVar1) { iVar2 = 8; } *local_20[uVar4] = iVar2; LAB_08925400: iVar7 = iVar7 + 1; if (7 < iVar7) { PAC::PAC_setCmdId(param_2,0); return; } } while( true ); }"
  },
  "getweatherinfo.html": {
    "href": "getweatherinfo.html",
    "title": "getWeatherInfo",
    "keywords": "getWeatherInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getWeatherInfo Scope: Global PAC Instruction (Binary): 25 12 09 00 Assembly Address in Memory : 0x8a1d37c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d37c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Get_Some_Flag(1); iVar3 = *(int *)(iVar3 + 0x44); *puVar1 = *(undefined4 *)(iVar3 + 0x77c); *puVar2 = *(undefined4 *)(iVar3 + 0x780); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getwinddirection.html": {
    "href": "getwinddirection.html",
    "title": "getWindDirection",
    "keywords": "getWindDirection Gets the direction of the wind. This represents direction only and does nothing with power or wind's existence. Code Information Name: getWindDirection Scope: Global PAC Instruction (Binary): 25 16 7b 00 Assembly Address in Memory : 0x8921014 Parameters (float *)destination (8 bytes) : Variable to store the wind direction. Expected -1 or 1. -1 means headwind and 1 means tailwind (Same with reversed direction too). DO NOT retrieve this to check if there is wind or not . For checking if the wind exists, use getWindLevel. Example Here is one example in hex: 25 16 7b 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getWindDirection((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921014(int param_1,undefined4 param_2) { float *pfVar1; int iVar2; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); *pfVar1 = 0.0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *pfVar1 = (float)*(int *)(iVar2 + 0x26c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getwindlevel.html": {
    "href": "getwindlevel.html",
    "title": "getWindLevel",
    "keywords": "getWindLevel Gets the wind strength. This works both in hideout and during mission. Code Information Name: getWindLevel Scope: Global PAC Instruction (Binary): 25 16 7c 00 Assembly Address in Memory : 0x89210a4 Parameters (float)strength (8 bytes) : The strength of the wind, the value is between 0~1. 0 means no wind. This will not return negative value for negative direction. For direction, use getWindDirection. Example Here is one example in hex: 25 16 7c 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: getWindLevel((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089210a4(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { *puVar1 = *(undefined4 *)(iVar2 + 0x268); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getworkvalue.html": {
    "href": "getworkvalue.html",
    "title": "getWorkValue",
    "keywords": "getWorkValue Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getWorkValue Scope: Global PAC Instruction (Binary): 25 19 0e 00 Assembly Address in Memory : 0x8941d1c Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941d1c(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { if (*puVar2 < 4) { uVar5 = *(undefined4 *)(*puVar2 * 4 + iVar4 + 0x8e0); } else { uVar5 = 0; } *puVar3 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "getworldinfo.html": {
    "href": "getworldinfo.html",
    "title": "getWorldInfo",
    "keywords": "getWorldInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: getWorldInfo Scope: Global PAC Instruction (Binary): 25 16 04 00 Assembly Address in Memory : 0x891921c Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891921c(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (Save::Get_Save_BaseAddr(1), iVar3 == 0)) { *puVar2 = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmick_gethandle.html": {
    "href": "gimmick_gethandle.html",
    "title": "gimmick_getHandle",
    "keywords": "gimmick_getHandle Gets handle with the given gimmick identifier. Code Information Name: gimmick_getHandle Scope: Global PAC Instruction (Binary): 25 19 01 00 Assembly Address in Memory : 0x8940e68 Parameters (int)gimmick_identifier (8 bytes) : Gimmick identifier from various place, e.g. addGimmick, getGateInfo or registConstGimmick. Seems like the ID from setReqActorUniqueId works too. (int *)gimmick_handle (8 bytes) : Varaible to store the gimmick handle. Example Here is one example in hex: 25 19 01 00 / 02 00 00 00 / f7 01 00 00 / 04 00 00 00 / 0a 00 00 00 Which is interpreted as: gimmick_getHandle((int)503, (int *)iVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08940e68(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Get_Gimmick(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x108),*puVar1); if (iVar3 == 0) { *piVar2 = -1; } else { *piVar2 = (int)*(short *)(iVar3 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmickgetfreeunique.html": {
    "href": "gimmickgetfreeunique.html",
    "title": "gimmickgetFreeUnique",
    "keywords": "gimmickgetFreeUnique Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: gimmickgetFreeUnique Scope: Global PAC Instruction (Binary): 25 19 1f 00 Assembly Address in Memory : 0x8942c5c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 19 1f 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: gimmickgetFreeUnique((int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942c5c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (*(int *)(param_1 + 0x10) != 0) { uVar2 = FUN_088b585c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x108)); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmickgetunique.html": {
    "href": "gimmickgetunique.html",
    "title": "gimmickgetUnique",
    "keywords": "gimmickgetUnique Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: gimmickgetUnique Scope: Global PAC Instruction (Binary): 25 19 1e 00 Assembly Address in Memory : 0x8942b98 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942b98(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *puVar2 = *(undefined4 *)(iVar3 + 0x194); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmickgetuseridf.html": {
    "href": "gimmickgetuseridf.html",
    "title": "gimmickGetUserIdF",
    "keywords": "gimmickGetUserIdF Gets the gimmick occupier as float. Code Information Name: gimmickGetUserIdF Scope: Global PAC Instruction (Binary): 25 19 06 00 Assembly Address in Memory : 0x8941708 Parameters (int *)gimmick_handle (8 bytes) : Handle of the target gimmick. (int)model_index (8 bytes) : Model index in the gimmick handle. (float *)destination (8 bytes) : Variable to store the user ID. Example Here is one example in hex: 25 19 06 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 03 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: gimmickGetUserIdF((int *)iVar1, (int)3, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941708(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { uVar5 = FUN_088ce2d4(iVar4,*puVar2); *puVar3 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmickgetuseridi.html": {
    "href": "gimmickgetuseridi.html",
    "title": "gimmickGetUserIdI",
    "keywords": "gimmickGetUserIdI Gets the gimmick occupier as int. Code Information Name: gimmickGetUserIdI Scope: Global PAC Instruction (Binary): 25 19 08 00 Assembly Address in Memory : 0x8941538 Parameters (int *)gimmick_handle (8 bytes) : Handle of the target gimmick. (int)model_index (8 bytes) : Model index in the gimmick handle. (int *)destination (8 bytes) : Variable to store the user ID. Example Here is one example in hex: 25 19 08 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: gimmickGetUserIdI((int *)iVar1, (int)0, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941538(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { uVar5 = FUN_088ce294(iVar4,*puVar2); *puVar3 = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmicksetuseridf.html": {
    "href": "gimmicksetuseridf.html",
    "title": "gimmickSetUserIdF",
    "keywords": "gimmickSetUserIdF Sets the gimmick occupier as float. Code Information Name: gimmickSetUserIdF Scope: Global PAC Instruction (Binary): 25 19 07 00 Assembly Address in Memory : 0x89417f0 Parameters (int *)gimmick_handle (8 bytes) : Handle of the target gimmick. (int)model_index (8 bytes) : Model index in the gimmick handle. (float)value (8 bytes) : Value to set the user ID. Example Here is one example in hex: 25 19 07 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 03 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: gimmickSetUserIdF((int *)iVar1, (int)3, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089417f0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { FUN_088ce2b4(*puVar3,iVar4,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gimmicksetuseridi.html": {
    "href": "gimmicksetuseridi.html",
    "title": "gimmickSetUserIdI",
    "keywords": "gimmickSetUserIdI Sets the gimmick occupier as int. Code Information Name: gimmickSetUserIdI Scope: Global PAC Instruction (Binary): 25 19 09 00 Assembly Address in Memory : 0x8941620 Parameters (int *)gimmick_handle (8 bytes) : Handle of the target gimmick. (int)model_index (8 bytes) : Model index in the gimmick handle. (int)value (8 bytes) : Value to set the user ID. Example Here is one example in hex: 25 19 09 00 / 08 00 00 00 / 7f 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: gimmickSetUserIdI(((global)int *)giVar127, (int)2, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941620(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { FUN_088ce274(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "gotomission.html": {
    "href": "gotomission.html",
    "title": "gotoMission",
    "keywords": "gotoMission Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: gotoMission Scope: Global PAC Instruction (Binary): 25 0a 1e 00 Assembly Address in Memory : 0x894b3f8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 0a 1e 00 / 08 00 00 00 / 4d 00 00 00 / 02 00 00 00 / 1e 00 00 00 / 02 00 00 00 / 63 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: gotoMission(((global)int *)giVar77, (int)30, (int)99, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b3f8(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4, undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined auStack64 [64]; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (*(int *)(param_1 + 0x10) != 0) { Data::Load_from_path (auStack64,s_Mission__02d__02d_pac_08a61664,*puVar3,*puVar4,param_5,param_6,param_7, param_8); iVar5 = Get_Some_Flag(1); iVar5 = *(int *)(iVar5 + 0x44); *(undefined4 *)(iVar5 + 0x550) = *puVar1; *(undefined4 *)(iVar5 + 0x534) = *puVar2; Syscall::strcpy(iVar5 + 0x55c,auStack64); FUN_0884f334(*(undefined4 *)(param_1 + 0x10),0,3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "guide/about-flag.html": {
    "href": "guide/about-flag.html",
    "title": "What is Flag in PACs?",
    "keywords": "What is Flag in PACs? Flag is bit array of 0 or 1 values. In easier words, it is just bunch of true(1) or false(0). The flag value is assigned with PAC instruction. Those are useful when check if the instruction has reached to certain line, and control the flow based on it. Even though you can use total 0x2000 bit (0x400 as byte) in theory, in actual code seems like 0xC00 ~ 0xF00 range is commonly used (there are some exceptions like 0x3xx) Example For example, if you set a flag to 1 with cmd_flgSet in 0xEE0, you can give that 0xEE0 to the parameter of e.g. cmd_flgAnd to check, and it will be considered as 1 in the flag calculation. So if you do like this: cmd_flgset(0xEE0) ... cmd_and(0x1234, 0xEE0) This will jump to 0x1234. What happens if I don't assign it? The unassigned flag is always zero. So do not worry of the garbage data! Note Be careful and do not edit assigned flag! Always check before assigning the new flag. (Thank you for Nemoumbra to help understanding the flag)"
  },
  "guide/about-levels.html": {
    "href": "guide/about-levels.html",
    "title": "About Levels",
    "keywords": "About Levels There are three types of levels. Quest Level Quest level (or Mission Level) is set with setQuestLevelRevise. This affects to stat, so the higher the quest level is, the stronger the enemies are. Individual Level Individual level value is set with setLevel. (More precisely, it is generator level) Offensive/Defensive level bonus calculation uses this (More information: \"Level bonus\" of this article). Final level Final_Level = Quest_Level + Individual_Level - 1 If quest level and/or individual level is not defined, it uses level from setQuestLevel. This is used for stat calculation (Wiht the \"level incremental\" values in originstatparam). Stat scale Stamina: (base_stat) + level_inc * lvl * (lvl+1) * 0.5 Damage: dmg + dmg_inc * (level * 0.9 + (level * (level + 1) * 0.0225) Others: Linear"
  },
  "guide/about-message.html": {
    "href": "guide/about-message.html",
    "title": "About Message",
    "keywords": "About Message Message ID Each message file has \"Message ID\". Usually, \"Message ID\" means Full ID ((message_file_id)*0x10000 + message_index) of the message. Those are Message table IDs: ID Message File Name Note Location 0x0 azito.msg Messages in Hideout DATA_CMN.bnd/message/azitolocal/azito_msg/ 0x0 (mission_id).msg Messages during Mission DATA_CMN.bnd/message/azitolocal/(mission_id)_msg 0x1 itemmsg.msg Item names and descriptions DATA_CMN.bnd/loadinggroup/systemlocalizedata/localize/ 0x2 unitnamemsg.msg Unit/Skill name and description DATA_CMN.bnd/loadinggroup/systemlocalizedata/localize/ 0x3 systemmsg.msg Information messages DATA_CMN.bnd/loadinggroup/systemlocalizedata/localize/ 0x5 errormessage.msg Important system notifications DATA_CMN.bnd/loadinggroup/systemlocalizedata/localize/ 0x9 tipsmsg.msg Tip messages DATA_CMN.bnd/loadinggroup/systemlocalizedata/localize/ 0xA chatmsg.msg Selectable quip messages DATA_CMN.bnd/loadinggroup/systemlocalizedata/localize/ To check each message ID, open message file and read the ID with e.g. MsgEdit tool. Or this might help if you can read the cheat codes. Message Table Message table is array of message IDs stored in PAC file. They are series of message IDs like 00 00 00 00 / 01 00 00 00 / 02 00 00 00... The message IDs in table is full message ID, so it is also possible to put other global messages there, like system messages. If you are using certain PAC instructions e.g. callMessageWindow, you must use reference from there. For example, if you want to print 0x26B speech bubble from mission_01_02.pac, search 6B 02 00 00 hex edtior to find the address (0x71C24), and pass the 0x71C24 as parameter. It is possible to define message table by extending PAC file. In this case, put the message table after cmd_end."
  },
  "guide/about-nodes.html": {
    "href": "guide/about-nodes.html",
    "title": "About Nodes",
    "keywords": "About Nodes A node (sometimes called as a bone) is specific coordinate in the model that are connected to other nodes. All nodes' top parent is a root node, except the root node itself, which has no parent. Nodes can be found in various objects, like in pons, heroes, bosses, minibosses and even in gimmicks. Every object has at least one node and each node has name. The nodes' IDs and names are stored in *.gxx file. Like the rigs, the nodes are used for animation, however, in PAC instruction context, node provides position to attach object. Adding object to a node Existing object An existing object can be added in a node, or a new effect or gimmick can be created and attached. setLink is common method to connect the existing object, and setLinkById also can be used if the node ID is known. Then, use setLinkParam to adjust the detail data of the information of the link. New object For example, when a gimmick is occupied in head-on VS, addLinkObject is called to add the turrets. For effect, callActorEffect is used to add the effect. More instructions are available in here."
  },
  "guide/about-parameters.html": {
    "href": "guide/about-parameters.html",
    "title": "PAC Parameters",
    "keywords": "PAC Parameters This requires background knowledge from Reading PAC#Basics. PAC Parameters, followed right after the instruction ID, are 4~8 bytes. As 8 bytes, first one is data type. 25 00 17 00 / 04 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 54 0E 00 00 First 25 00 17 00 is the instruction ID. Then, 04 00 00 00 here is type, and the following 01 00 00 00 here is the value (in this context it is local int parameter ID). But at last part, 54 0E 00 00 (0xE54), is 4-bytes parameter, because it is address. Sometimes, for flexible amount of parameters with same type doesn't repeat the type (best seen in e.g. cmd_flgAND). So, how do you know if it is 4 bytes or 8 bytes? That's why you have to check the document. If you see certain defined type like Int, Float, Int/Float in docs, it should be 8 bytes, if you see Address in docs, it should be 4 bytes. Beware of ... types in docs, they are multiple parameters, and the type is defined only once. Parameter types Type reference table \"Immediate\" means it is not variable, but a fixed value. Type ID As HEX Var/Imm Type Scope 0x0 00 00 00 00 none 0x1 01 00 00 00 index 0x2 02 00 00 00 Immediate int 0x4 04 00 00 00 Variable int local 0x8 08 00 00 00 Variable int global 0x10 10 00 00 00 Immediate float 0x20 20 00 00 00 Variable float local 0x40 40 00 00 00 Variable float global Example Example 1. Variable 25 10 06 00 / 04 00 00 00 / 10 00 00 00 This is getPack (25100600), which takes 1 parameter. So, the 8-bytes of 04 00 00 00 / 10 00 00 00 is the parameter. Based on the reference table, the 04 00 00 00 (0x4) means local int variable. And since this is variable, the next value is 0x10 can be considered as integer variable name. So it can be represented as iVar16 (or iVar0x10). Example 2. Address 25 00 03 00 / E8 B4 00 00 This is cmd_call, which takes 1 parameter as address. For the address value, you don't need to find it from the table. Example 3. Data Type 25 00 17 00 / 08 00 00 00 / 17 00 00 00 / 10 00 00 00 / 00 00 80 3F / 30 18 01 00 This is cmd_ifEQ, which takes two 8-bytes types, and one 4-bytes type as address as last part. 25 00 17 00 // 08 00 00 00 / 17 00 00 00 // 10 00 00 00 / 00 00 80 3F // 30 18 01 00 For first one, 08 00 00 00 (0x8) is global int variable For second one, 10 00 00 00 (0x10) is float immediate For third one, it is 4-bytes type address, so doesn't need to look up from the table. Example 4. Advanced: Simplifying Duplicated Types 25 00 2c 00 / 6C 24 01 00 / 02 00 00 00 / 69 0E 00 00 / 6A 0E 00 00 This is an example from cmd_flgAND. In the docs, there is flexible amount of variable((uint...)Var1), as seen in .... So, takes first parameter as address, and second one as the variable, it will look like this: 25 00 2c 00 // 6C 24 01 00 // 02 00 00 00 / 69 0E 00 00 / 6A 0E 00 00 Now, ONLY the first 02 00 00 00 here defines the type. For first one, it is 4-bytes type address, so doesn't need to look up from the table. For second one, 02 00 00 00 (0x2) is int immediate So it is interpreted as cmd_flgAND(0x1246C, (int)0xE69, (int)0xE6A)."
  },
  "guide/about-units.html": {
    "href": "guide/about-units.html",
    "title": "About Units",
    "keywords": "About Units Caution NOT ALL reqActors are unit squads. ReqActors/Actors can be gimmick, as been observed in generatorparam. An unit is an individual target that has run-time information, like stamina percentage or status effect. A squad is one or multiple units that shares pre-defined data, like unit type and action. A reqActor is object definitions in scope of squad, but not spawned yet. A generator is an object pool that contains definition of the reqActors. One generator can contain max 8 types of reqActors, so reqActor index in generator is expected 0~7. Next Article: How To: Create an Enemy Target"
  },
  "guide/category.html": {
    "href": "guide/category.html",
    "title": "Intruction By Category",
    "keywords": "Intruction By Category Note: Not all instructions are here. Few instructions might be mentioned more than once, but it's intended. cmd_XXX Basic Math cmd_mov (=, assign) cmd_add (+), cmd_sub (-) cmd_mul (*), cmd_div (/), cmd_mod (%) cmd_iand (&), cmd_ior (|), cmd_ixor (^) cmd_irol (<<), cmd_iror (>>) cmd_abs, cmd_sqrt, cmd_sinf, cmd_cosf, cmd_atan2f Jumping, Calling cmd_end, cmd_jmp, cmd_call If case jump cmd_ifEQ (==), cmd_ifNE (!=) cmd_ifLS (<), cmd_ifLSE (<=), cmd_ifLB (>), cmd_ifLBE (>=) cmd_ifAND (&), cmd_ifOR (|) cmd_resJmp cmd_inxJmp If case call cmd_ifCallEQ (==), cmd_ifCallNE (!=) cmd_ifCallLS (<), cmd_ifCallLSE (<=), cmd_ifCallLB (>), cmd_ifCallLBE (>=) cmd_ifCallAND (&), cmd_ifCallOR (|) cmd_resCall Flag Jumping Check About Flag. cmd_flgAnd (&), cmd_flgOr (|), cmd_flgZero cmd_flgSet, cmd_flgMov, cmd_flgClr cmd_flgSetId, cmd_flgClrId cmd_flgMemCpy, cmd_flgMemSet Other utils cmd_rand, cmd_srand cmd_WaitFrame, cmd_WaitTime, cmd_getElapsedTime cmd_addArray, cmd_getArray, cmd_setArray Unit / Gimmick setupUnit, applyUnit checkEqualHeroName getHeroCount Model addChara getModelInfo, getParent setModelInfo, setParent, setModelLowerHeight, setModelRotate, setModelColor createChangeModel, changeModel getDirection, setDirection, getTroopSign isHero, isMyHero Gimmick Unlike effect, gimmick has another \"unique ID\" that is not handle. Some gimmick related instructions gets or sets the ID value. The ID value is manually defined by giving as parameter in some instructions. addGimmick getGateInfo, setGateInfo, resetGateInfo registConstGimmick, applyConstGimmick, enableCollisionConstGimmick setActionController getChildGimmick setGimmickTimmingScript Collision getCollisionSize, getCollisionType addHit, setCollisionSize, enableCollision Effect addEffect effectGetUserID, effectGetEffectID effectSetDeleteId, effectKill setEffectTimmingScript, effectSetTimingScript, effectSetWaitTime playHitEffect Damage setDamageParam Creating / Handling Enemy Units Generator Setup Related article: How to: create an Enemy Target First, make a empty generator : create setTroopType, setLevel, setMode, setModeEx, setPosX, setDeathCall, setAdventRadius, setItemTable isActiveGen, multi_waitActiveGenerator Other troop instructions getTroopType_gimmickUId ReqActors ReqActor represents a PVE Enemy or possibly a gimmick. As a PVE enemy, they can be boss, miniboss, or small enemies like AI Dark heroes or Deths. setReqActorType, setReqActorCount, setReqActorRenderPrio, setReqActorItemTable, setReqActorUniqueId, setReqActorHp setReqActorPos, setReqActorMovePos setReqActorScale, setReqActorFixPosFlag setReqActorAdventRadius, setReqActorMoveRadius setReqActorWeapon, setReqActorHp, setReqActorLevel Control spawning: setReqActorTotal, setReqActorDelayTime Getting handle Related article: How To: Get a handle For hideout exclusive handle, check hideout section. Squad: getUnitSquadHandle (from reqActor unique ID), getSquadHandle (from generator + reqIndex), getPlayerSquadHandle (from player), getUnitSquadHandleFromChara (from unit handle) Unit: getUnitHandle, getHataponHandle, getMultiHeroHandle Effect/Gimmick: addEffect, gimmick_getHandle Any Actor : getActorHandle Generator: getHandle Squad addSquad getSquadBasePosition, getSquadClassId setSquadBasePosition setPlayerSquadType getMultiplayerSquadHandle getSquadClassId, getPlayerClassId replaceActivityTable isFrontLineEnterView, isFrontLineEnterAttack Class setClassData setSuperHero addSkill, isRegisterSkill setClassData getUnitParam Level getPlayerClassLevel, getMultiPlayerLevelMax resultLevelupCalacLabel, resultLevelupCalacGet, resultLevelupCalacSet getActorLevel, setActorLevel Equipment isPlayerEquipWeaponCategory, isEquipWeaponInTroop addEquip, addEquipSubModel getEquipItemParam Action isHeromode, isPossibleExecHeromode Position setAdvanceEnable, setAdvanceSpeedRatio movePosition, stopMove (changing model affects) Force: addVector, setVector getPlayerTroopBasePosition getTroopTopPosX, getTroopTopPosX_enemy, getTroopPosY Animation playMotion, pushMotion, clipMotion, stopMotion, pauseMotion getMotionInfo, setMotion setUnitDeadMotion Node getNodeIndex, getNodePos, getCenterNodeId setLink, setLinkParam, setLinkById, releaseLink, setLinkInfo enableRenderAttach getNodeDisp, setNodeDisp Adding an Enemy Target: callActorEffect, addLinkObject Control getActive, setActive spawn Unit Control Related article: How To Control a Squad setUnitCtrlEnable, setUnitCtrlMode setUnitCtrlStartActType, setUnitCtrlRangerActType, getUnitCtrlCurrentActType, setUnitCtrlCurrentActType (Generator), setUnitCtrlCurrentActType (SquadHandle) setUnitCtrlWatchArea setUnitCtrlTimingScript_Int, setUnitCtrlEnable, setUnitCtrlMoveEnable getUnitCtrlActivity, setUnitCtrlActivity setUnitCtrlSkill Note that squadActivity and actual march/attack/defend action can be different. Boss Control setBossMoveRange, setBossMoveRangeLimit getBossActionId, setBossActionId, enableBossManualCtrl setBossNoDamage, setBossDisableAtkMove Status kill, rebornTroop, setSuperHeroRebornEnable, getAliveUnitCount getDamageDeadFlag, getKillOrderFlag setRebornPosition, setAppearancePosition recoveryHp, recoveryHpRatio recoveryPlayerTroopHp, recoveryPlayerTroopHpRatio setHitPoint, setMaxHitPoint, getStatusInfo (hp status and hp rate) Status Effect addAbnormalStatus, addAbnormalStatusSlip, addAbnormalStatusBlowoff getAbnormalStatus Mission Information getGameMode, setGameMode getMissionAreaId, setMaxMissionAreaId, getMaxMissionAreaId, setMissionAreaId, getMissionInfo setMissionTimmingScript resultGetState, resultSetState, resultGetPhase getRetireFlag, disableRetireBox Quest Data getQuestLevelRevise, setQuestLevelRevise, getQuestLevel, setQuestLevel getQuestComplementCounter, incQuestComplementCounter setQuestPayExp, setQuestPayItem, resetQuestPay Waiting until loaded (WaitGoAhead) This is called with pons too. For multi, check network section. multi_waitGoAhead, multi_WaitGoAhead1 Cutscene sync : multi_startNoSyncEvent, multi_endNoSyncEvent multi_waitTimeSync multi_waitActiveGenerator multi_battleGoAHead, startIntroEvent, start isGoGame, startGame Mission Environment setGroundOffset Stage Related Article: How To: Setup Stages addStage, setStageParam startSetupStage, endSetupStage, applyStage Dungeon For door gimmick, see gimmick section. setupStartDungeonWall, setupAddDungeonWall, setupDungeonComment, setupEndDungeonWall Weather getRainLevel, getSnowLevel, getThunderLevel, getWindLevel, getWindDirection, getFogLevel, getSandLevel, getCloudyLevel setRainLevel, setSnowLevel, setThunderLevel, setWindLevel, setWindDirection, setFogLeve, setSandLevel, setCloudyLevel setWindColor reflectWeather Camera cameraGetPos, cameraGetPosX, cameraGetOffsetY, cameraSetPosZ, cameraSetBattleZ cameraSetScriptCmaera, cameraEnableControl, cameraEnabeControll cameraMove, cameraMoveType cameraMoveSpeedSet, cameraMoveTimeSet setCameraPosition, cameraSetOffsetY cameraActuate Music / Sound Sound: playSe, playSeFromPos Music: playAtrac, cancel, stop Bgm: setMssionBgmId Rhythm / Command getCommandId, getCommandRate, getCommandScore, getCombo, getSoundLevel Chant turn: isRhythm sendCommand, sendMiss clearAutoCommand, setAutoCommand, addAutoCommandKey, startAutoCommandKey setDisableKey Command Cancel: isEnableRhythmHit setEnableRhythmHit, isSoundDisableRhtyhmHit, setSoundDisableRhtyhmHit Drum Hit: getHitPercussion, getDisablePercussionFlag, setDisablePercussionFlag, getDisablePercussionView, setDisablePercussionView, getHitRate Drum Shout: setDiableHeroVoice, clearDisableHeroVoice VS PvE VS playtime is hardcoded and can't edit with this. getVersusPlayerCount, setVersusRule isVisibleVersusString, setVersusString getVersusPKInfo setMultiMapViewState multiSetTime (Time limit), getDeadCount (Reborn amount based VS) Scoring: multiGetScore, multiSetScore, getBrakeScore, setBrakeScore, setBreakScoreTroop Head-on getGimmickPowerGaugePoint gimmickGetUserIdI, gimmickSetUserIdI, gimmickGetUserIdF, gimmickSetUserIdF Head-on Summon getEquipSummonType, setEnemySummonType isSummonMode, startSummonMode, getSummonPlayerId Item Adding items directly: addItem (Obtain), addItem (Inventory) addItemEffect to drop item manually. getGfpData, serchGfpId clearItem, setKnownItem Item drops Related article: How To: Set Item Drops. Called in phase 1 (2nd phase) of setMissionTimmingScript. beginAppearItem, endAppearItem getAppearItem, getAppearItemEx setAppearItem, setCharinAppearParam, setAppearItemKillTime Loots itemTableAllClear resultBoxItemGet, resultBoxItemLabel, resultBoxItemSet Input getDisableKey, setDisableKey getPadDirect, getPadStand, getPadRelease Resources readArcFile, requestActor, syncReadArcFile Graphic getRenderPriority, setRenderPriority UI / Display Warning Most of the UIs exist for good reason. Messing up with the basic UI while playing is considered as bad UX design practice (and that is what DoI curse do). Consider using another method for making a mission challenging. setDisableHpGaugeView, setDisableSqudHpGaugeView, setDisableSimpleGaugeView setDisableFeverGauge, getDisableBeatGuide, setDisableBeatGuide, setDisableCommandGuide getFeverGaugePriority, setFeverGaugePriority Message / Dialog Dialog: showDialogEx, closeDialog Speech Bubble: callMessageWindow, callLocalizeMessageWindow, setMsgWndColor, setMsgWndPriority, closeMessageWindow keyCloseMessageWindow Related Guide: How To: Set Speech Bubble Information Message (above/below): callSysMsgLabel, callSysMsg, clearSysMsg Chat: setEnableLogWindow, setEnableChatWindow, sendMessage Debug: setChoice, doSelect Basic text on center : sysytemMessage, setMessageColor, getLineFeedCount Related Utils: setReplaceTextFromInt, text_setReplaceColor, text_setReplaceText Screen View: screenStartFrame, screenStartSpotLight Fade: startFade, getFadeRate, getFadeColor Timer Timer is the displayed time count on the screen (can be counter or countdown). It is used for e.g. first floor guillotine. startTimer, setTimerPos, setTimerSize, setTimerEnableSeType, addTimer getTimerSec, getCountdonwTimerStatus, setTimerPause drawTimer, Related Guide: How To: Add A Timer Screen-World Conversion worldToScreenPos Script getPack createScript, killScript, killChildren Hideout getAzitoInfo, setAzitoInfo, setFacilityInfo, getFacilityGimmickHandle setEnablePad getEventUnitHandle, getMultiHeroHandle Shop unlockShopItem, checkShopItemUnlock unlockBgm, unlockTeamCard, unlockTeamFlag setShopItemInfo unlockMedenShopItem, clearMedenShopItem Save saveMs, getResultSaveMs setIAmCheater Blacksmith getMaterialItemId, addLevelUpItemParam, getLevelUpInfo World Map addArea, addQuest, addStage (world map), resetStageParam isExistDlcQuestFile setStageCursor Scene changeScene, toTilte Tip screen (labo.pac) clearTipSelectMask, resetTips unlockTipImageId, unlockTipImageNoSave checkTipsUnlock System getLaboInfo, setLaboInfo changeLanguage Network setConnectionIconDraw, startSyncGameFlag, getSyncGameFlagResult networkErrorInvoke (Hideout), networkErrorInvoke (Mission) multi_getTweet, multi_setTweet, multi_clearTweet multi_startGoAhead, multi_isFinishGoAhead, multi_stopGoAhead"
  },
  "guide/code-of-conduct.html": {
    "href": "guide/code-of-conduct.html",
    "title": "Code of Conduct",
    "keywords": "Code of Conduct Terms Address means address from the PAC file offset. Jump means Go to the instruction in the specific Address. This does not read next line. (See also cmd_jmp) Call means Jump and go back, it is like calling function in programming. (See also cmd_call) Generator is the term here that has multiple reqActors (reqActor here means, the one that can apply setReqActorXXX etc). The constant variable is called immediate, following how assembly calls it. Notations * is marked for variables. For example, (int *) means int variable. For global, mention global like ((global) int *) Disclaimer: I am not a C++ developer or smth (shrug). If you really hate it because this is incorrect notation in C++, do not use this docs or fork by yourself, and good luck with dealing with around 900 instructions. (...) in parameter type means multiple parameters. Other notes All in-memory function addresses follow EU Vanilla version. All parameters list in # Parameters section are ordered same as the usage order. First in the list is first parameter and second in the list is second parameter and so on."
  },
  "guide/getting-started.html": {
    "href": "guide/getting-started.html",
    "title": "Getting started",
    "keywords": "Getting started Required knowledge Knowledge about hex, data type and binary calculation. e.g. \"bit\", \"byte\", and, or, xor, \"flag\", \"bitmask, ` etc. Basic programamtical arthimetic expression knowledge (Doesn't need to know C/C++). Assembly/C++/C knowledge is not necessary, unless you go deep and research them. Learning by example (Sorry we don't have good teacher or resources) Patient enough to follow the flow, since the PAC instructions are bunch of \"Goto\" spaghetti. Search and Copypasta skill (like Programmers' good ol' friend Stackoverflow :D) Being familiar with Patapon Param files. Next step: What is PAC?"
  },
  "guide/how-to-add-a-timer.html": {
    "href": "guide/how-to-add-a-timer.html",
    "title": "How To: Add A Timer",
    "keywords": "How To: Add A Timer Draw a timer Initialise the timer with startTimer. Set the position with setTimerPos. Set the timer size with setTimerSize. (Optional) Set countdown sound on with setTimerEnableSeType. If you want to add time to the timer, use addTimer. startTimer can be incremental by passing 2nd paramter to 1. Control the timer setTimerPause does stop, pause and resume. getTimerSec gets timer as seconds. Examples This is the timer in first Guillotine in Demon Forudo Mission: 0005E974 25000700:cmd_mov(40:CF, 16.0) 0005E988 25169D00:startTimer(40:CF, 2:0) 0005E99C 25169F00:setTimerPos(240.0, 24.0) 0005E9B0 2516A000:setTimerSize(32.0) 0005E9BC 25160F01:setTimerEnableSeType(2:1) This is the Defence Practice timer: 0005FF9C 25169D00:startTimer(55.0, 2:0) 0005FFB0 25169F00:setTimerPos(240.0, 24.0) 0005FFC4 2516A000:setTimerSize(32.0) This is the timer in debug mode, proving changing the order of startTimer also works. 2C7E4 : 25169F00:setTimerPos(240.0, 136.0) 2C7F8 : 2516A000:setTimerSize(21.0) 2C804 : 25169D00:startTimer(20.0, 2:0) This is the timer to trigger swinging axes in \"Eternal Archfiend and the other vessel\" 1st floor. 00064200 2516A100:getTimerSec(20:0) 0006420C 25002100:cmd_ifCallLSE(20:0, 0.0, 1:64228) 00064224 25000100:cmd_end()"
  },
  "guide/how-to-add-a-turret.html": {
    "href": "guide/how-to-add-a-turret.html",
    "title": "How To: Add A Turret",
    "keywords": "How To: Add A Turret The sequence below shoots one bullet. 1. Add a turret as a gimmick. registConstGimmick is good option. However, it doesn't need to be constGimmick if the turret can be dynamic object. It is named BATTERY_000 (gimc1210), and BATTERY_VS for VS Mission. 2. Get timing. Simple and rough method to find cannon timing is comparing 3rd and 4th parameter of getMotionInfo during animation. (The animation can be set easily with setActionController). The problem of this approach is, the turret shoots too many bullets with pons. This can be fixed with checking action type (do not shoot if it is less than 2). In this case, if the both value are same, go to the next phase. 3. Get a handle and node index. Get the handle of the turret gimmick with gimmick_getHandle. Then use getNodeIndex and getNodePos to get the node position. For turret, the node name is eff_shot_01. 4. Add the shooting effect to the handle. Both the shooting effect and cannonball effect must be added. The shooting effect is ID 0x336 (efm_225.bnd). The shooting effect must be preloaded. The cannonball effect itself is EFF_CANNONBALL_001x~EFF_CANNONBALL_004x, which is 0x319, 0x31A, 0x31D, 0x31E. 5. Set the stat. Use setDamageParam to apply damage to the cannonball. Example 0005FEA4 25170C00:getMotionInfo(8:5B, 8:1FF, 8:1FF, 20:C) /* check the motion status */ 00060250 25170C00:getMotionInfo(8:5B, 4:A, 8:1FF, 40:1FF) 00060274 25001700:cmd_ifEQ(4:A, 1.0, 1:602C0) 0006028C 25001700:cmd_ifEQ(4:A, 2.0, 1:602C4) 000602A4 25001700:cmd_ifEQ(4:A, 3.0, 1:602C8) //shooting animation //preheating condition. 000602C8 25000700:cmd_mov(20:1, 20:C) 000602DC 25000700:cmd_mov(20:2, 3.0) 000602F0 25004E00:cmd_getElapsedTime(20:3) 000602FC 25000A00:cmd_mul(20:3, 0.5) 00060310 25000800:cmd_add(20:3, 3.0) /* Check the timing */ 00060324 25000300:cmd_call(1:5FAB4) 0005FAB4 25001B00:cmd_ifLS(20:1, 20:2, 1:260) 00000250 25000400:cmd_result(2:1) 0000025C 25000100:cmd_end() 0005FACC 25001A00:cmd_ifLBE(20:1, 20:3, 1:260) 00000260 25000400:cmd_result(2:0) 0000026C 25000100:cmd_end() 0005FAE4 25000200:cmd_jmp(1:250) 0006032C 25000600:cmd_resCall(2:1, 1:60340) /* get handle and node */ 00060340 25190100:gimmick_getHandle(4:B, 8:5B) 00060354 25172000:getNodeIndex(8:5B, 8:1FF, \"eff_shot_01\") 00060374 25172100:getNodePos(8:5B, 8:1FF, 20:0, 20:1) 00060398 25000300:cmd_call(1:607E4) //just flip related 000603A0 2516D000:getTroopType_GimmickUID(4:B, 4:0) /* decides which kind of cannonball, can give fixed value instead of this */ 000603B4 25000300:cmd_call(1:6074C) 000603BC 25002C00:cmd_flgAND(1:60508, E94) /* adding cannonball */ 000603CC 25160800:addEffect(8:1FF, 4:1, 4:0, 1.0, 2:0) 000603F8 25170B00:setModelInfo(8:1FF, 20:0, 20:1, 20:2, 20:3, 20:4) //position set /* registering damage and wait time */ 0006042C 25190100:gimmick_getHandle(4:B, 8:5B) 00060440 25174400:setDamageParam(8:1FF, 8:5B) 00060454 25190500:effectSetWaitTime(8:1FF, 0.0) /* adding cannon shooting effect */ 00060468 25160800:addEffect(8:1FF, 2:336, 4:0, 1.0, 2:0) 00060494 25170B00:setModelInfo(8:1FF, 20:0, 20:1, 0.0, 0.009999999776482582, 0.0) //position set /* registering damage and wait time */ 000604C8 25190100:gimmick_getHandle(4:B, 8:5B) 000604DC 25174400:setDamageParam(8:1FF, 8:5B) 000604F0 25190500:effectSetWaitTime(8:1FF, 0.0) 00060504 25000100:cmd_end()"
  },
  "guide/how-to-control-a-squad.html": {
    "href": "guide/how-to-control-a-squad.html",
    "title": "How To: Control a Squad",
    "keywords": "How To: Control a Squad Article Before: How To: Get a Handle Controlling Bosses Marching before attacking Set mode_id of setUnitCtrlMode to 6, and setUnitCtrlWatchArea to set march distance from player position. Attacking All minibosses' and bosses' attack action are automatic, controlled by Assembly or monster.pac, which doesn't need to touch. Though, if you want to control the boss manually, consider enableBossManualCtrl. Related instructions: Boss Control Small units Related instructions: Unit Control Unlike boss, small units like deths or dark heroes are controlled by separately defined PAC instructions. Auto controlled units The \"auto control\" here means simple march and attack, like regular bonedeth units do. Set setUnitCtrlMode with zero mode_id so can perform regular march-attack. Set setUnitCtrlStartActType with zero command_id so march by default. Use setUnitCtrlActivity to connect the squadparam ID. Set setReqActorFixPosFlag with zero can_float. Note the units can do only march, attack and defend. 0005AF34 25100600:getPack(8:5B) 0005AF40 251F2600:setUnitCtrlTimingScript_Int(8:1A, 2:7, 8:5B, 1:1C010) 0005AF64 251F1700:setUnitCtrlMode(8:1A, 2:5, 2:0) 0005AF80 251F2300:setUnitCtrlStartActType(8:1A, 2:5, 2:2) 0005AF9C 251F1C00:setUnitCtrlActivity(8:1A, 2:5, 2:0, 2:5C3) 0005AFC0 251F1C00:setUnitCtrlActivity(8:1A, 2:5, 2:1, 2:5C5) 0005AFE4 251F1C00:setUnitCtrlActivity(8:1A, 2:5, 2:2, 2:5C9) 0005B008 251F1A00:setReqActorFixPosFlag(8:1A, 2:5, 2:0) Maunally controlling units Some dark heroes' actions are manually controlled for story mission balance. (If they perform heromode all the times, the gameplay will be harder). Connect to the unit activity with the setUnitCtrlActivity. Set/Change setUnitCtrlCurrentActType. This is Ragewolf action in his first encounter (Ragewolf and the Mysterious Birch Grove): /*setting up the actions */ 00062778 25004B00:cmd_getArray(4:40, 8:11B, 4:2B) 00062794 25004B00:cmd_getArray(4:40, 8:11A, 4:2A) 000627B0 251F1C00:setUnitCtrlActivity(4:2B, 4:2A, 2:0, 2:3BA) 000627D4 25004B00:cmd_getArray(4:40, 8:11B, 4:2B) 000627F0 25004B00:cmd_getArray(4:40, 8:11A, 4:2A) 0006280C 251F1C00:setUnitCtrlActivity(4:2B, 4:2A, 2:1, 2:3B2) //connects to defend squadlineparam 00062830 25004B00:cmd_getArray(4:40, 8:11B, 4:2B) 0006284C 25004B00:cmd_getArray(4:40, 8:11A, 4:2A) 00062868 251F1C00:setUnitCtrlActivity(4:2B, 4:2A, 2:2, 2:3C4) //connects to heromode squadlineparam 0006288C 25000C00:cmd_inc(8:CA) ... /* sets heromode action */ 0006289C 25004B00:cmd_getArray(4:40, 8:11B, 4:2B) 000628B8 25004B00:cmd_getArray(4:40, 8:11A, 4:2A) 000628D4 251F2700:setUnitCtrlCurrentActType(4:2B, 4:2A, 2:2) //<<- THIS 000628F0 25004A00:cmd_setArray(4:40, 8:121, -1.0) 0006290C 25000700:cmd_mov(8:5B, 4:40) ... /* sets defending action */ 000629F8 25000500:cmd_resJmp(2:0, 1:284) 00062A08 25004B00:cmd_getArray(4:40, 8:11B, 4:2B) 00062A24 25004B00:cmd_getArray(4:40, 8:11A, 4:2A) 00062A40 251F2700:setUnitCtrlCurrentActType(4:2B, 4:2A, 2:1) //<<- THIS 00062A5C 25004A00:cmd_setArray(4:40, 8:121, -1.0) Units on a structure For bonedeth dying with their tower: Create the tower using registConstGimmick. Use generator and connect with SetModeEx last parameter (to registeConstGimmick last parameter). Use setDeathCall to call specific instructions. Apply position, unit activity, fix position etc to the unit. In the spcific instructions, get that enemy squad with getUnitSquadHandle. Kill the squad with kill. /* 1. register constgimmick */ 00064900 2516BF00:registConstGimmick(2:E4, 8:32, 2:1, 2:5DC, 2:0, 2:0, 2:0, 2:1, 2:1, 2:190, 2:82) /* 2~3. set an generator with setModeEx, use setDeathCall to call when the gimmick is destroyed */ 00065E64 251F0200:create(8:1A, 2:514) ... 00065EA0 251F1B00:setModeEx(8:1A, 2:1, 2:FFFFFFFF, 2:82) //calls setDeathCall() when ID \"0x82\" structure is destroyed ... 00065ED8 25100600:getPack(4:0) 00065EE4 251F0800:setDeathCall(8:1A, 4:0, 1:66B88) //When gimmick is destroyed call 66B88 00065F00 251F0900:setReqActorType(8:1A, 2:1, 15) //NOTE THIS STARTS FROM 1, sets deth squad 00065F1C 251F0A00:setReqActorCount(8:1A, 2:1, 2:1) //one yumideth 00065F38 251F0E00:setReqActorPos(8:1A, 2:1, -44.0, 83.0) //note there is Y position ... 00065F9C 251F1800:setReqActorUniqueId(8:1A, 2:1, 2:83) //ID 83 ... 00065FE8 251F0900:setReqActorType(8:1A, 2:2, 15) 00066004 251F0A00:setReqActorCount(8:1A, 2:2, 2:4) //4 yumideths 00066020 251F0E00:setReqActorPos(8:1A, 2:2, -5.0, 140.0)//note there is Y position ... 00066084 251F1800:setReqActorUniqueId(8:1A, 2:2, 2:84) //ID 84 /* 4. Set position to the unit. */ 000663AC 251F1700:setUnitCtrlMode(8:1A, 2:1, 2:0) //normal control mode (0) somehow works. 000663C8 251F2300:setUnitCtrlStartActType(8:1A, 2:1, 2:1) //defend as default. 000663E4 251F1C00:setUnitCtrlActivity(8:1A, 2:1, 2:0, 2:5D4) //march (none) 00066408 251F1C00:setUnitCtrlActivity(8:1A, 2:1, 2:1, 2:5D6) //defend 0006642C 251F1C00:setUnitCtrlActivity(8:1A, 2:1, 2:2, 2:5D9) //attack 00066450 251F1A00:setReqActorFixPosFlag(8:1A, 2:1, 2:1) //So the units do not fall from the structure. /* 5~6. The part that is called by setDeathCall() */ 00066B88 25163700:getUnitSquadHandle(8:1A, 2:83) 00066B9C 25172600:kill(8:1A, -1.0, -1.0) //Kill all from squad ID 83. 00066BB8 25163700:getUnitSquadHandle(8:1A, 2:84) 00066BCC 25172600:kill(8:1A, -1.0, -1.0) //Kill all from squad ID 84. Units riding a gimmick or monster The key point is using nodes to set the unit position. Example This example is how Ravenous rides on the dragon in Ravenous: Duel of the Fate First, set up the unit. /* Setting up riding unit (Ravenous) */ ... 0005C8C4 25163D00:getUnitHandle(8:CB, 4:18, 2:0) 0005C8E0 25163E00:setUnitCtrlEnable(8:CB, 2:0) //The model shouldn't do anything, let the dragon attack 0005C8F4 25173E00:enableCollision(8:CB, 2:0, 2:0) //Delete collision so can't kill the unit only 0005C910 25170B00:setModelInfo(8:CB, 1367.0, 167.0, 0.0, 0.0, 0.0) 0005C944 25173700:playMotion(8:CB, 2:1, 2:1, 0.0, 0.0) 0005C970 25171000:setFixMoveEnable(8:CB, 2:1) //Fix the unit Y position so doesn't affect by gravity 0005C998 25163700:getUnitSquadHandle(4:2C, 2:CA) 0005C9AC 25163D00:getUnitHandle(4:2D, 4:2C, 2:0) ... Next, ride to the unit. 0005CBA4 25210300:enableBossManualCtrl(8:CA, 2:1) //PAC instructioni will move the dragon ... /* Attach the unit */ 0005D414 25171A00:setLink(8:CC, 8:CB, \"kubi_bone5\") 0005D434 25171B00:setLinkParam(8:CB, 2:1, 2:0, 2:0, 0.0, 18.0, 0.0) 0005D470 25174A00:setLinkInfo(8:CB, 2:1, 2:5) 0005D48C 25177100:enableRenderAttach(8:CB, 2:0) 0005D4A0 25173700:playMotion(8:CB, 2:A, 2:0, 0.0, 0.0) 0005D4CC 25213900:wakeUpForce(8:CA) //wake up the dragon ..."
  },
  "guide/how-to-create-an-enemy-target.html": {
    "href": "guide/how-to-create-an-enemy-target.html",
    "title": "How To: Create an Enemy Target",
    "keywords": "How To: Create an Enemy Target How does it work There is \"generator\" that contains object definitions. 1. Create a generator with create This is done in setMissionTimmingScript 1st phase. Related article: create. 2. Setup generator This is done in setMissionTimmingScript 1st phase, right after step above Related instructions: Generator setup Use 1st parameter from create to define the detail of the generator. setTroopType: Defines troop type (is player side or enemy side) setPosX: Defines position setDeathCall: Defines instruction set to call after the unit is dead. 3. Setup individual unit in the generator. This is done in setMissionTimmingScript 1st phase, right after step above setReqActorType: Sets actor type from generatorparam. If the target is not in the list, another method like addGimmick etc are required. setReqActorCount: Sets the spawn limit. setReqActorDelayTime: Spawn delay between next spawn. setReqActorTotal : Spawn limit (max spawn amount). Warning For Dark Hero spawn (like DoI), disabling reborn to dark hero is mandatory, otherwise the Dark Hero constantly will reborn and block the path. For this, disable reborn with setSuperHeroRebornEnable with Enemy DH squad handle. Other than that, Dark Hero spawn from structure works normally as others. Example result as visualised table Each table represents generator. ~ Generator (with create) table 1 ~ X position 3200 Calls address to cmd_end() after death ReqActor0 ReqActor1 ReqActor2 Yarideth Tatedeth Yumideth 2 units 1 unit 3 units ~ Generator (with create) table 2 ~ X position 2400 Calls address 0x2099C after death ReqActor0 Cyclops 1 unit 4. Spawn the generator This is done in setMissionTimmingScript 2nd phase. First, use getHandle to load the unit, and then Spawn. 0005C7FC 251F1500:getHandle(2:898, 8:1A) 0005C810 251F1300:spawn(8:1A) If there are many entities on the way, consider using setDeathCall to spawn the next targets. Bringing together (example) This is spawning motiti in runtime function in debug mode. 0002B514 25100600:getPack(4:0) 0002B520 251F0200:create(4:1, 2:1) 0002B534 251F1B00:setModeEx(4:1, 2:0, 2:FFFFFFFF, 2:FFFFFFFF) 0002B558 251F0500:setPosX(4:1, 150.0) 0002B56C 251F0600:setAdventRadius(4:1, 0.0) 0002B580 251F0800:setDeathCall(4:1, 4:0, 1:248CC) 0002B59C 251F0900:setReqActorType(4:1, 2:0, 24) 0002B5B8 251F0A00:setReqActorCount(4:1, 2:0, 2:1) 0002B5D4 251F0E00:setReqActorPos(4:1, 2:0, 0.0, 0.0) ... //0002B5F8 251F1300:spawn(4:1) 0002B604 25000100:cmd_end() Do not call spawn until mission timming is reached to 2nd phase. Mind that is debug mode and everything is already fully loaded. In normal mission, use getHandle and spawn later. 00000310 251F1500:getHandle(2:0, 8:1A) 00000324 251F1300:spawn(8:1A) For const structure Note that constGimmick object is loaded from very first, and can't be lazy loaded. If the structure is spawned after some point (e.g. when other structure destroyed), the structure must be called using reqActor (like above). Use registConstGimmick (MissionTimming phase 1). Set the gimmick with applyConstGimmick (MissionTimming phase 2). Call resetGateInfo right before setting gate information. Use setGateInfo (last parameter with 1st param 0) to setup the gimmick (registerConstGimmick last parameter). Control collision status with enableCollisionConstGimmick. 1st: 0005A9D4 25120200:setMissionTimmingScript(2:1, 4:0, 1:5AAA8) 0005AAA8 25000300:cmd_call(1:5A3F0) 0005A3F0 2516BF00:registConstGimmick(2:103, 8:32, 2:1, 2:12C, 2:0, 2:0, 2:1, 2:1, 2:1, 2:384, 2:186A0) ... 0005A674 2516BF00:registConstGimmick(2:117, 8:32, 2:1, 2:A8C, 2:0, 2:0, 2:1, 2:1, 2:1, 2:12C, 2:186A9) 0005A6D0 25000100:cmd_end() 2~4: 0005A9F0 25120200:setMissionTimmingScript(2:2, 4:0, 1:5D4AC) 0005D4AC 25000300:cmd_call(1:5D4E4) 0005D4B4 25000300:cmd_call(1:5D4F0) /* 2. apply const gimmicks */ 0005D4F0 2516C000:applyConstGimmick() 0005D4F4 25000100:cmd_end() ... 0005D4D4 25000300:cmd_call(1:5A6D4) /* 3. reset the gate information */ 0005A6D4 2516BC00:resetGateInfo() /* 4. setup the gates */ 0005A6D8 25000700:cmd_mov(8:46, 0.0) //8:46 index 0005A6EC 25000700:cmd_mov(8:48, -1.0) //object identifier 0005A700 2516BD00:setGateInfo(2:0, 8:46, 2:0, 8:48) 0005A724 2516BD00:setGateInfo(2:0, 8:46, 2:1, 2:0) 0005A748 2516BD00:setGateInfo(2:0, 8:46, 2:2, 1:5D5F8) 0005A76C 25000C00:cmd_inc(8:46) //increases the index 0005A778 25000700:cmd_mov(8:48, 100000.0) //identifier 0x186a0 from constgimmick 0005A78C 2516BD00:setGateInfo(2:0, 8:46, 2:0, 8:48) 0005A7B0 2516BD00:setGateInfo(2:0, 8:46, 2:1, 2:5) 0005A7D4 2516BD00:setGateInfo(2:0, 8:46, 2:2, 1:5D6A8) 0005A7F8 25000C00:cmd_inc(8:46) 0005A804 25000700:cmd_mov(8:48, 100001.0) ... 0005A9A8 25000100:cmd_end() This is how to setup the gate in phase 3 and 4: 000049CC 2516BC00:resetGateInfo() 000049D0 25000700:cmd_mov(8:46, 0.0) 000049E4 25000700:cmd_mov(8:48, -1.0) 000049F8 2516BD00:setGateInfo(2:0, 8:46, 000049F8 2516BD00:setGateInfo(2:0, 8:46, 2:0, 8:48) 00004A1C 2516BD00:setGateInfo(2:0, 8:46, 2:1, 2:0) 00004A40 2516BD00:setGateInfo(2:0, 8:46, 2:2, 1:24C) 00004A64 25000C00:cmd_inc(8:46) 00004A70 25000700:cmd_mov(8:48, -2.0) 00004A84 2516BD00:setGateInfo(2:0, 8:46, 2:0, 8:48) 00004AA8 2516BD00:setGateInfo(2:0, 8:46, 2:1, 2:0) 00004ACC 2516BD00:setGateInfo(2:0, 8:46, 2:2, 1:24C) 00004AF0 25000C00:cmd_inc(8:46) 00004AFC 25000100:cmd_end() For dungeon Use setupStartDungeonWall. Call setupAddDungeonWall. Set detail information of it with setGateInfo. If there is any lever, create the levers first and get thd ID of them. Finish with setupEndDungeonWall Grass / Obstacle Same as creating unit entities. They also have generatorparam entities, and can use them. Those are main differences from the unit creation: For grass, use hitbox layer 3 in setTroopType. Use setAdventRadius or setReqActorAdventRadius for setting distance between grasses. Spawning units from a structure ConstGimmick Method Create the tower using registConstGimmick. Use generator and connect with SetModeEx last parameter (to registeConstGimmick last parameter), and set mode_type to 3. Set the time between respawn and total respawn count. Use spawn to spawn units. /* 1. register const gimmick */ 0005DED8 2516BF00:registConstGimmick(2:118, 8:32, 2:1, 2:2BC, 2:0, 2:0, 2:0, 2:1, 2:1, 2:12C, 2:6E) ... /* 2. define a generator and set \"setModeEx\" */ 0005EAF8 251F0200:create(8:1A, 2:44C) ... 0005EB34 251F1B00:setModeEx(8:1A, 2:1, 2:FFFFFFFF, 2:6E) ... 0005EB78 251F0800:setDeathCall(8:1A, 4:0, 1:5F39C) 0005EB94 251F0900:setReqActorType(8:1A, 2:1, 16) ... /* 3. limit the spawn amount and spawn time */ 0005EF0C 251F1200:setReqActorDelayTime(8:1A, 2:1, 2.0) 0005EF28 251F0B00:setReqActorTotal(8:1A, 2:1, 2:3) ReqActor Method Use generator and set mode_type (2nd parameter) in SetModeEx to 4. Define a structure in the generator, as reqActor gimmick, as index 0. Put the units together to the same generator as the structure. Set the time between respawn and total respawn count. Use spawn to spawn units. 0005B7D4 251F0200:create(8:1A, 2:44C) 0005B7E8 251F1900:setTroopType(8:1A, 2:1) 0005B7FC 251F0400:setLevel(8:1A, 8:32) /* NOTE THE SECOND PARAM IS 4 */ 0005B810 251F1B00:setModeEx(8:1A, 2:4, 2:FFFFFFFF, 2:FFFFFFFF) ... /* Make the spawn point structure in index 0 */ 0005B870 251F0900:setReqActorType(8:1A, 2:0, 118) ... 0005B974 251F0900:setReqActorType(8:1A, 2:1, 4F) 0005B990 251F0A00:setReqActorCount(8:1A, 2:1, 2:1) ... /* Add other units */ 0005BAB0 251F1200:setReqActorDelayTime(8:1A, 2:1, 4.0) 0005BACC 251F0B00:setReqActorTotal(8:1A, 2:1, 2:9) 0005BAE8 251F0900:setReqActorType(8:1A, 2:4, 15) 0005BB04 251F0A00:setReqActorCount(8:1A, 2:4, 2:3) ... 0005BC90 251F1200:setReqActorDelayTime(8:1A, 2:4, 4.0) 0005BCAC 251F0B00:setReqActorTotal(8:1A, 2:4, 2:9) Next step How To: Get a Handle"
  },
  "guide/how-to-define-a-mission.html": {
    "href": "guide/how-to-define-a-mission.html",
    "title": "How To: Define a Mission",
    "keywords": "How To: Define a Mission See also: The Flow Caution It is strongly recommended to use existing template (editing existing mission), otherwise it might cause crashing. This is all theory and not tested yet. Please correct when this is tested. 1. Set mission information Set mission metadata, including the Quest Data. Clears or sets some flags. Loads basic data like game mode, unit param (Note unit itself is initialised in different phase!). System settings like CPU Clock mode, memset. Example Here is example for a DLC Mission: 00000000 25002700:cmd_flgSet(F15) 0000000C 25120300:setMaxMissionAreaId(2:1) 00000018 25000300:cmd_call(1:15A8) 00000020 25000700:cmd_mov(8:32, 29.0) 00000034 25000700:cmd_mov(8:33, 51.0) 00000048 2516A400:setQuestLevel(8:32) 00000054 2516A600:setQuestLevelRevise(8:33) 00000060 25002C00:cmd_flgAND(1:70, E3E) 00000070 25001700:cmd_ifEQ(8:1C, 2.0, 1:8C) 00000088 25000100:cmd_end() The 8:1C here means the Mission ID. For non-DLC mission, it is described from mission ID table. For DLC mission, it is same as the number in PAC file. For example, if the file name is dlc_mission_0010.pac, the Mission ID here is 10. 00000070 25001700:cmd_ifEQ(8:1C, 2.0, 1:8C) In non-dlc mission, there can be more than one 8:1C comparison jump, since one PAC can contain more than one mission. 00000000 25120300:setMaxMissionAreaId((int)1) //dungeon floor amount, 1 for field 0000000C 25000300:cmd_call(0x2B0) //Init Mission and Quest Data and more 00000014 25002C00:cmd_flgAND(1:24, E3E) 00000024 25001700:cmd_ifEQ(8:1C, 52.0, 1:5ACE8) 0000003C 25001700:cmd_ifEQ(8:1C, 53.0, 1:60434) 00000054 25001700:cmd_ifEQ(8:1C, 54.0, 1:66A6C) 0000006C 25001700:cmd_ifEQ(8:1C, 55.0, 1:6725C) 00000084 25001700:cmd_ifEQ(8:1C, 56.0, 1:690C4) 0000009C 25001700:cmd_ifEQ(8:1C, 57.0, 1:69930) 000000B4 25000100:cmd_end() Sets the mission level to scale with the player level This is how Kacchindonga mission level scales. 00000084 25001700:cmd_ifEQ(8:1C, 56.0, 1:690C4) //Kacchindonga mission ID is 56 000690C4 25000300:cmd_call(1:46E4) 000046E4 250A0500:getLaboInfo(2:1, 4:0) //singleplayer or multiplayer 000046F8 25001700:cmd_ifEQ(4:0, 1.0, 1:4748) /* Singleplayer */ 00004710 25165300:getPlayerClassLevel(2:0, 2:FFFFFFFF, 4:0) 0000472C 25000B00:cmd_div(4:0, 2.0) 00004740 25000200:cmd_jmp(1:4754) /* Multiplayer */ 00004748 25162A01:getMultiPlayerLevelMax(4:0) /* If player level is smaller or equal than pre-defined quest level goest to cmd_end */ 00004754 25001A00:cmd_ifLBE(8:33, 4:0, 1:24C) //cmd_end /* Sets quest level */ 0000476C 25000700:cmd_mov(8:33, 4:0) 00004780 2516A600:setQuestLevelRevise(8:33) 0000478C 25000100:cmd_end() /* sets 2x value of the level that was defined before */ 000690CC 25000A00:cmd_mul(8:33, 2.0) 000690E0 2516A600:setQuestLevelRevise(8:33) 000690EC 25100600:getPack(4:0) 2. Set MissionTimmingScript Use setMissionTimmingScript to call instructions when mission is loaded. Read resources (0) This loads not only stage, but also oter resources such as other models and messages. 00000098 25120200:setMissionTimmingScript(2:0, 4:0, 1:F0) 000000F0 25000300:cmd_call(1:A290) 000000F8 25090900:readArcFile(2:2, \"Actor/Stage/stg041.bnd\") 0000011C 25090900:readArcFile(2:2, \"Actor/Stage/stg042.bnd\") 00000140 25000100:cmd_end() Loading Resource on demand Get unit data with getUnitParam. Check if the unit is certain class with cmd_ifEQ (getUnitParam 3rd parameter). (Optional) If the character is not a hero (getUnitParam 4nd parameter 0), skips hero exclusive resource loading. (Optional) If different equipment has different effect, check the equipment type with isEquipWeaponInTroop. /* 1. getUnitParam to each team member */ 00039A64 25161B00:getUnitParam(2:1, 2:0, 4:4, 4:5) 00039A88 25000300:cmd_call(1:3F518) 00039A90 25161B00:getUnitParam(2:1, 2:1, 4:4, 4:5) 00039AB4 25000300:cmd_call(1:3F518) 00039ABC 25161B00:getUnitParam(2:1, 2:2, 4:4, 4:5) 00039AE0 25000300:cmd_call(1:3F518) 00039AE8 25161B00:getUnitParam(2:1, 2:3, 4:4, 4:5) 00039B0C 25000300:cmd_call(1:3F518) /* 2. loads instruction by class type */ 0003F518 25001700:cmd_ifEQ(4:4, 0.0, 1:39420) ... 0003F5C0 25001700:cmd_ifEQ(4:4, 13.0, 1:40190) /* 3. Skips hero specific effect for non-hero unit */ 00040190 25001700:cmd_ifEQ(4:5, 0.0, 1:407DF) /* load resources */ 000401A8 25090900:readArcFile(2:2, \"Actor/Stand/stnd003.bnd\") 000401CC 25090900:readArcFile(2:2, \"Actor/Effect/efm_108.bnd\") 00040218 25090900:readArcFile(2:2, \"Actor/Effect/efm_109.bnd\") 00040240 250A1700:requestActor(2:B, 2:C1, 2:FFFFFFFF, 2:FFFFFFFF) /* 4. Resource can be loaded by equipment */ 00040264 25162C00:isEquipWeaponInTroop(4:1, 2:4A, 4:0) 00040280 25001F00:cmd_ifCallEQ(4:0, 1.0, 1:407E4) Sets skill or class skill can be loaded on demand too, using isRegisterSkill. 00039BFC 25162E00:isRegisterSkill(4:1, 2:0, 4:3) 00039C18 25001F00:cmd_ifCallEQ(4:3, 1.0, 1:3D16C) 00039C30 25162E00:isRegisterSkill(4:1, 2:1, 4:3) 00039C4C 25001F00:cmd_ifCallEQ(4:3, 1.0, 1:3D16C) 00039C64 25162E00:isRegisterSkill(4:1, 2:2, 4:3) Make Item Tables and setup actors (1) Related article : How To: create an Enemy Target 00000674 25000300:cmd_call(1:C14) //------------------- ITEM SETUP --------------------- // 0000067C 25000300:cmd_call(1:144) 00000144 25000300:cmd_call(1:85B8) 0000014C 25080200:beginAppearItem(2:15E) 00000158 25080900:setAppearItemKillTime(26.0, 40.0) 0000016C 25080800:setCharinAppearParam(2:4, 2:A, 8:60, 8:32, 16.0, 30.0) 000001A0 25000700:cmd_mov(40:1C, 1.0) 000001B4 25080300:setAppearItem(0.02500000037252903, 2:4A, 2:0, 2:0, 2:FFFFFFFF) 000001E0 25000900:cmd_sub(40:1C, 0.02500000037252903) ... //------------------- UNIT SETUP 1 --------------------- // 000006C0 25000300:cmd_call(1:BED8) 0000BED8 25100600:getPack(4:0) 0000BEE4 251F0200:create(8:1A, 4:1) 0000BEF8 251F1900:setTroopType(8:1A, 2:1) 0000BF0C 251F1B00:setModeEx(8:1A, 2:0, 2:FFFFFFFF, 2:FFFFFFFF) 0000BF30 251F0400:setLevel(8:1A, 2:0) 0000BF44 251F0500:setPosX(8:1A, 40:14) 0000BF58 251F0600:setAdventRadius(8:1A, 0.0) 0000BF6C 251F0800:setDeathCall(8:1A, 4:0, 1:D4C) 0000BF88 251F0900:setReqActorType(8:1A, 2:0, 7E) 0000BFA4 251F1800:setReqActorUniqueId(8:1A, 2:0, 4:2) ... //------------------- UNIT SETUP 2 --------------------- // 000006C8 25000300:cmd_call(1:6D4) 000006D4 251F0200:create(8:1A, 2:3E8) 000006E8 251F1900:setTroopType(8:1A, 2:1) 000006FC 251F0400:setLevel(8:1A, 8:32) 00000710 251F1B00:setModeEx(8:1A, 2:4, 2:FFFFFFFF, 2:FFFFFFFF) 00000734 251F0500:setPosX(8:1A, 800.0) 00000748 25100600:getPack(4:0) 00000754 251F0800:setDeathCall(8:1A, 4:0, 1:8C0) 00000770 251F0900:setReqActorType(8:1A, 2:0, 65) ... 000006D0 25000100:cmd_end() Final setup (2) //------------------- Unit Information Setup --------------------- // 000008C4 25000300:cmd_call(1:910) 00000910 25000300:cmd_call(1:A36C) 0000A36C 25000700:cmd_mov(8:67, 0.0) 0000A380 25161F00:addTroop(8:68, 8:67) 0000A394 25162000:setAppearancePosition(8:68, 0.0) 0000A3A8 25162100:setRebornPosition(8:68, 0.0) 0000A3BC 25000700:cmd_mov(8:73, 1.0) 0000A3D0 25161F00:addTroop(8:74, 8:73) 0000A3E4 25162000:setAppearancePosition(8:74, 0.0) 0000A3F8 25162100:setRebornPosition(8:74, 0.0) ... 0000A49C 25163300:setupUnit() //After seting is done, call setupUnit() 0000A4A0 25163100:applyUnit() //and applyUnit() 00000918 25000100:cmd_end() //------------------- Gimmick Handle Setup --------------------- // 000008CC 25000300:cmd_call(1:91C) 0000091C 2516C000:applyConstGimmick() 00000920 2516B200:multi_waitGoAhead1() 00000924 251F1500:getHandle(2:0, 8:1A) 00000938 251F1300:spawn(8:1A) 00000944 2516B500:multi_waitActiveGenerator(2:0) 00000950 2516B200:multi_waitGoAhead1() 00000954 251F1500:getHandle(2:3E8, 8:1A) ... //------------------- STAGE SETUP --------------------- // 000008D4 25000300:cmd_call(1:9A0) 000009A0 25000300:cmd_call(1:6344) 00006344 25165E00:setStageParam(1.0, 0.800000011920929, 0.699999988079071, 2:0, \"stg041\") 00006370 25000100:cmd_end() 000009A8 25000300:cmd_call(1:6374) 00006374 25165E00:setStageParam(1.0, 0.800000011920929, 0.6000000238418579, 2:0, \"stg042\") 000063A0 25000100:cmd_end() 000009B0 25000300:cmd_call(1:AD8) 00000AD8 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg041\") 00000B0C 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg041\") ... 000009B8 25165C00:endSetupStage() 000009BC 25165F00:applyStage(2:0) 000009C8 25000100:cmd_end() 000008DC 25000300:cmd_call(1:9CC) 000008E4 25000300:cmd_call(1:9D8) 000008EC 25000300:cmd_call(1:C18) 000008F4 25000700:cmd_mov(8:1C, -1.0) 00000908 25000200:cmd_jmp(1:9E4) Looping (after 2) Some logics must be called in every frame. In this case, the instruction can be loopsed with following steps: Loop by calling prior instructions through cmd_jmp. Right above the cmd_jmp, call cmd_waitframe(1). Remember to call cmd_waitFrame so the game does not stuck. 000119D8 25002C00:cmd_flgAND(1:11A40, EE9) 000119E8 25000300:cmd_call(1:5944) 000119F0 25161700:resultGetState(8:15, 8:16, 8:17) 00011A0C 25001700:cmd_ifEQ(8:17, 1.0, 1:11A6C) 00011A24 25000300:cmd_call(1:5AAC) 00011A2C 25000F00:cmd_waitFrame(2:1) //WAIT before looping 00011A38 25000200:cmd_jmp(1:119D8) //goes to the above(0x119D8) Setting up the goal position ((global)float *)gfVar0x14 (40 00 00 00 14 00 00 00) is the mission goal position. Editing this part will move mission position. 00000280 25000700:cmd_mov(40:14, 3420.0) //goal position is 3420.0 (as psp pixels) Mission goal gimmick is created in ((global)int *)giVar0x1A (08 00 00 00 1A 00 00 00), and the generatorparam ID is 0x7E. 0000BEE4 251F0200:create(8:1A, 4:1) ... 0000BF44 251F0500:setPosX(8:1A, 40:14) //using \"40:14\" for the position. ... 0000BF88 251F0900:setReqActorType(8:1A, 2:0, 7E) However, the gimmick alone doesnn't do anything. The code below is implemented in loop (described in above). // --- if all units are dead mission fails -- // 00005B4C 25163600:getAliveUnitCount(4:0) 00005B58 25001900:cmd_ifLSE(4:0, 0.0, 1:D4C) ... // -------------- get position --------------- // 00005C14 25163400:getTroopTopPosX(20:0, 2:0) // --- compare with goal position (40:14) ---- // 00005C28 25001B00:cmd_ifLS(20:0, 40:14, 1:D4C) // --------------- if summon ---------------- // 00005C40 250C1700:isSummonMode(2:0, 4:0) 00005C54 25001800:cmd_ifNE(4:0, 0.0, 1:5C98) // ------------ or march command ------------ // 00005C6C 250C0100:getCommandId(2:FFFFFFFF, 4:0) 00005C80 25001800:cmd_ifNE(4:0, 0.0, 1:D4C) // ------- set mission status flags -------- // 00005C98 25002700:cmd_flgSet(DF6) 00005CA4 25002C00:cmd_flgAND(1:5D78, E94) 00005CB4 25002C00:cmd_flgAND(1:5D10, DFA) // -- if 8:1C is 0, instant go to hideout -- // 00005CC4 25001700:cmd_ifEQ(8:1C, 0.0, 1:5D44) 00005D44 25161900:resultSetState(2:7, 2:7, 2:0, 2:0, 2:0, \"\") 00005D74 25000100:cmd_end() // -------- normal mission success -------- // 00005CDC 25161900:resultSetState(2:2, 2:7, 2:0, 2:0, 2:0, \"\") 00005D0C 25000100:cmd_end() 3. Finish with cmd_end(). Every PAC logics are callback of the MissionTimmingScript, so mission setup is done here. Adding a mission to the world map Warning Madwig DLC has special format that can't be opened with bnd tools. One option is copy non-Mad mission and overwriting it, but still cannot guarantee to be functional in such mission. Use AddArea and addQuest for adding the mission. Always check if the map/quest is already added in the PAC file. For DLC, the PAC file is inside 98D1E9D2, for non-DLC, it is inside DATA_CMN/mission/(Mission_??_??). For DLC Mission, Madwig DLC already has all available mission indexes (file names). Check the Mission ID table. Message For non-DLC mission: The quest description is in loadinggroup/azitolocal/localize/(language)/worldmapdata/scriptlist/worldmapmsg.msg (used by addQuest) In-mission messages is are message/azitolocal/(mission_??_??).msg For DLC mission: The quest description is in 98D1E9D2 In-mission messages are in the mission file. Misc For the countdown before the battle, use startIntroEvent and then multiBattleGoAhead. Consider the followings for cutscene (do not use for disturbing gameplay): For disabling key input during cutscene, check setDisableKey. For UI removing, check UI related instructions."
  },
  "guide/how-to-get-a-handle.html": {
    "href": "guide/how-to-get-a-handle.html",
    "title": "How To: Get a Handle",
    "keywords": "How To: Get a Handle Article before: How To: Create an Enemy Target What is a handle? A handle is specific ID given to the each entity. The entity can be player unit, enemy unit, squad, troop, or even effect or gimmick. Many PAC instructions use the handle to control the entity, e.g. model info, render priority, motion, speech bubble target and more. The handle can be unit, gimmick, squad or something else. How to get a handle Check getting handle category. Units Get squad handle. Get Unit handle from the squad handle. Few PAC instructions allow handle as parameter, but this doesn't happen often. reqActor (created) unit In the prior article, there was part to set unique ID. 00067B00 251F1800:setReqActorUniqueId(8:1A, 2:1, 2:65) 2:65 (third parameter) is the one that will be used for obtaining squad handle and unit handle. 00060BD0 25163700:getUnitSquadHandle(4:1, 2:12C) //squadHandle stored in 4:1 00060BE4 25163D00:getUnitHandle(4:A, 4:1, 2:0) //unitHandle stored in 4:A, 2nd parameter is squadHandle from above Now the 4:A contains the unit handle. Note the reqActor can be either an unit or a gimmick. Player unit Use getPlayerSquadHandle and getUnitHandle. 0002A83C 25163900:getPlayerSquadHandle(4:A, 2:0) //squadHandle 4:A 0002A850 25163D00:getUnitHandle(4:B, 4:A, 2:0) //unitHandle 4:B For multiplayer, getMultiplayerSquadHandle or getMultiplayerSquadHandle_PID to get the squad handle. For Hatapon, getHataPonHandle gives unit handle without need to get squad handle. Item addItemEffect stores handle as the result. Gimmick First, get the gimmick identifier. For getGateInfo or setGateInfo, it is destination or param with param_index 0. For registConstGimmick, it is last parameter of the instruction (user-defined ID). For reqActor gimmick, getActorHandle does the job. gimmick_getHandle to get a handle of it. Hideout This is how to get a handle of a selected unit. 00009C64 251C0600:getAzitoInfo(2:7, 4:0) 00009C78 251C0900:getFacilityGimmickHandle(4:1, 4:0) 00009C8C 25170A00:getModelInfo(4:1, 20:0, 20:1, 40:1FF, 40:1FF) For obtaining Pons unit, use getEventUnitHandle. Pons can be placed in the hideout in this way. Next: How To: Control a Squad"
  },
  "guide/how-to-set-item-drops.html": {
    "href": "guide/how-to-set-item-drops.html",
    "title": "How To: Set Item Drops",
    "keywords": "How To: Set Item Drops As quest completion reward Call resetQuestPay to reset the rewards. Call setQuestPayItem to set the reward. Check item ID indexes for this. Not Items, but quest completion exp point can set with setQuestPayExp. During Mission Enemy item drop Call beginAppearItem. Setup it: setAppearItem, setAppearItemKillTime, setCharinAppearParam (Ka-ching) Finalise with endAppearItem. Put the table ID from beginAppearItem to setReqActorItemTable or setItemTable. Pre-drop or auto drop For item drop without killing enemy, use addItemEffect. If item drop is constant, put directly item ID. If item drop is not constant, and if it uses the item table, use getAppearItemEx from the table. Example This logic drops potion from an enemy: 00008334 25080200:beginAppearItem(2:320) 00008340 25080900:setAppearItemKillTime(26.0, 40.0) 00008354 25080800:setCharinAppearParam(2:4, 2:A, 8:60, 8:32, 16.0, 30.0) 00008388 25000700:cmd_mov(40:1C, 1.0) 0000839C 25080300:setAppearItem(1.0, 2:34, 2:0, 2:0, 2:FFFFFFFF) 000083C8 25000900:cmd_sub(40:1C, 1.0) 000083DC 25080400:endAppearItem() ... 0005C040 251F1F00:setReqActorItemTable(8:1A, 2:0, 2:320) Item from chests Caution For loot drop, consider every scenario for every item drop. Always set default drop that makes sense. Make sure dropped item is fair or not much rewarding (the mission is for fun anyway!). Call itemTableAllClear so it doesn't mix up with already defined item tables. Define table just like above, but only step 1~3. Decide if extra logic for item drop will be implemented, e.g. player levels. Call beginAppearItem((int)1). The parameter must be 1, otherwise it won't work. Setup it, extra logic can be added here. setAppearItem, setAppearItemKillTime is not useful here, don't know why exists Finalise with endAppearItem. Call getAppearItem to roll the item. Call resultBoxItemSet to store the result from 3. Set address of resultBoxItemLabel to the itemTableAllClear address. Example 00012294 25165100:getPlayerClassId(2:0, 4:10) 000122A8 25165300:getPlayerClassLevel(2:0, 2:FFFFFFFF, 4:11) ... /* 1. Clear the item table */ 00012364 25080700:itemTableAllClear() /* 2. Defines item table for loot */ 00012368 25080200:beginAppearItem(2:1) 00012374 25080900:setAppearItemKillTime(26.0, 40.0) 00012388 25080800:setCharinAppearParam(2:4, 2:A, 8:60, 8:32, 16.0, 30.0) 000123BC 25000700:cmd_mov(40:1C, 1.0) 000123D0 25000300:cmd_call(1:12A4C) //bunch of setAppearItem() with specific condition 000123D8 25080400:endAppearItem() /* 3. Item roll */ 000123DC 25080500:getAppearItem(2:1, 4:D, 4:E) //4:D and 4:E stores the roll result. 000123F8 25000300:cmd_call(1:1A8C8) 00012400 25000300:cmd_call(1:12454) /* 4. Store the roll result to the box */ 00012408 25166A00:resultBoxItemSet(4:D, 4:E) //Set result to 4:D and 4:E 0001241C 25000100:cmd_end() Special Case For example, for cyclops throwing loot, the chest type is decided during mission. Normal getAppearItem won't work in this case. In this case, use getAppearItemEx to roll the loot (it is still unreliable random, but better than nothing). 000010C0 25001C00:cmd_ifLB(8:2A, 0.0, 1:13B4) 000010D8 25000300:cmd_call(1:A08C) 0000A08C 25080600:getAppearItemEx(2:190, 8:2A, 8:36, 2:0) 0000A0B0 25000900:cmd_sub(8:2A, 912.0) 0000A0C4 25000C00:cmd_inc(8:2A) 0000A0D0 25000100:cmd_end() 000010E0 25000100:cmd_end()"
  },
  "guide/how-to-set-speech-bubble.html": {
    "href": "guide/how-to-set-speech-bubble.html",
    "title": "How To: Set Speech Bubble",
    "keywords": "How To: Set Speech Bubble Preparation Get the handle to speak. Check e.g. How To: Create an Enemy Target and/or How To: Get a Handle Check Message ID table of the PAC file, and get the address of it. Creating the speech bubble First, use callMessageWindow and get message handle. Set other priority with the handle. setMsgWndPriority to set message on the top (or desired priority). keyCloseMessageWindow to add X button (user input closes the speech bubble). setMsgWndColor to set background colour. Example This is speech bubble code in Perfect March Practicing. This gets talking sign handle with gimmick_getHandle. 000017B4 25190100:gimmick_getHandle(2:64, 4:A) 000017C8 250B0100:playSe(2:1D300A60, 0.0, 1.0, 0.0, 0.0, 1.0) 000017FC 25172D00:callMessageWindow(4:A, 8:37, 0.0, 60.0, -1.0, 2:FFFFFFFF, 2:0, 1:5E33C, 2:0) 00001844 25173100:setMsgWndPriority(8:37, 2:F423F) 00001858 25172F00:keyCloseMessageWindow(8:37, 2:9, 2:4000, 2:0) This is part of chat message speech bubble. 00011E9C 25172D00:callMessageWindow(4:D, 4:0, 0.0, 50.0, 3.0, 2:FFFFFFFF, 2:0, 1:60AAC, 2:1) 00011EE4 25173200:setMsgWndColor(4:0, 2:F0, 2:D2, 2:8C) 00011F08 25173100:setMsgWndPriority(4:0, 2:F423F)"
  },
  "guide/how-to-setup-stages.html": {
    "href": "guide/how-to-setup-stages.html",
    "title": "How To: Setup Stages",
    "keywords": "How To: Setup Stages The \"stage\" means a background environment of the scene. Understanding the Stage Layers There are some layers of stages background. (In here, \"uncontrollable\" means cannot change index or camera sensitivity) Topmost Layer is rendered on top of the stage background, e.g. grass, stone. Middle Object Layer is rendered back of the topmost layer. This might contain structure in index 1. Back Object Layer is far-away looking objects in the stage, but still stays front of the sky layer. Background Layer is uncontrollable layer that decides the sky colour, and some white smooth cloud. Not in the image, but some maps might have some uncontrollable objects (especially in dungeon). Note that some stages might have more complicated background, especially in dungeon (e.g. pillars). First, Decide what stages will appear, and when they will appear If the field has more than one stage: If the stage will change after certain distance, declaring the start is unnecessary. If the stage will change in certain condition (e.g. Pondora), multiple stagae must be defined, thus it needs startSetupStage. If the field has only one stage, startSetupStage is not necessary. For stage IDs, check the reference. Second, Read the resources Call readArcFile to load the stage resources. 0000008C 25100600:getPack(4:0) 00000098 25120200:setMissionTimmingScript(2:0, 4:0, 1:F0) //phase 0 ... 000000F8 25090900:readArcFile(2:2, \"Actor/Stage/stg041.bnd\") 0000011C 25090900:readArcFile(2:2, \"Actor/Stage/stg042.bnd\") 00000140 25000100:cmd_end() Third, set the stageparam When setting the stageparam, call the existing one. The camera sensitivity is pre-adjusted smoothly, so it is not necessary to define a new one. 000000D0 25120200:setMissionTimmingScript(2:2, 4:0, 1:DD4) //phase 2 ... 00000DE4 25000300:cmd_call(1:E80) 00000E80 25000300:cmd_call(1:69AC) 000069AC 25165E00:setStageParam(1.0, 0.800000011920929, 0.699999988079071, 2:0, \"stg041\") 000069D8 25000100:cmd_end() 00000E88 25000300:cmd_call(1:69DC) 000069DC 25165E00:setStageParam(1.0, 0.800000011920929, 0.6000000238418579, 2:0, \"stg042\") 00006A08 25000100:cmd_end() Finally, add and apply the stage. Simple stage change by the position For stage change after few marching, defining multiple stage will do the job. In multiple stages, one addStage defines stage after 5~6 march (with pons). So for example, if the new stage should be appeared after 10~12 march, define two same stage with addStage and change the stage in the third call. 00000E90 25000300:cmd_call(1:10E4) 000010E4 25165D00:addStage(2:0, 2:0, 2:0, 2:1, 2:0, \"stg041\") 00001118 25165D00:addStage(2:0, 2:0, 2:0, 2:1, 2:0, \"stg041\") 0000114C 25165D00:addStage(2:0, 2:0, 2:0, 2:1, 2:0, \"stg041\") 00001180 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg042\") 000011B4 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg042\") 000011E8 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg042\") 0000121C 25000100:cmd_end() 00000E98 25165C00:endSetupStage() 00000E9C 25165F00:applyStage(2:0) Do not forget to call applyStage after the setting is done. The applyStage parameter is zero in this case, because no stage group(with startSetupStage) is defined. Stage change under certain condition For calling manual scene change, multiple stage groups are required. The group starts with startSetupStage, which has stage ID as parameter. 00000CC0 25165B00:startSetupStage(2:0) 00000CCC 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg074\") 00000D00 25165C00:endSetupStage() //For closing *startSetupStage* 00000D04 25165B00:startSetupStage(2:1) 00000D10 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg076\") 00000D44 25165C00:endSetupStage() //For closing *startSetupStage* 00000D48 25165B00:startSetupStage(2:2) 00000D54 25165D00:addStage(2:0, 2:0, 2:0, 2:0, 2:0, \"stg077\") 00000D88 25165C00:endSetupStage() //For closing *startSetupStage* 00000D8C 25165C00:endSetupStage() //! DONE DEFINING ALL STAGES ! 00000D90 25165F00:applyStage(2:0) // call the stage Note that one endSetupStage in the end is not paired. Unlike other endSetupStage closing startSetupStage, the last one means done defining the whole stage setup in the mission. Changing the stage Give the stage group ID (defined with startSetupStage) to the applyStage. 0002EDEC 25165F00:applyStage(2:1) 0002EDF8 25000100:cmd_end() 0002EDFC 25165F00:applyStage(2:2) 0002EE08 25000100:cmd_end()"
  },
  "guide/index.html": {
    "href": "guide/index.html",
    "title": "Home",
    "keywords": "Welcome! Check the sidebar to start."
  },
  "guide/reading-pac.html": {
    "href": "guide/reading-pac.html",
    "title": "Reading a PAC file",
    "keywords": "Reading a PAC file They are pure binary, so you can open as hex editor and read it. For disassembled PAC, there is disassembled version of PAC as text somewhere. Basics Reading order The bytes are Little Endian. This means, you have to cut 4-bytes and read it as reversed order. For example, 25 16 2B 00 04 00 00 00 36 00 00 00 02 00 00 00 22 01 00 00 02 00 00 00 00 00 00 00 Cut to 4 bytes, 25 16 2B 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / 22 01 00 00 / 02 00 00 00 / 00 00 00 00 And reverse each block and they are the value. 00 2b 16 25 / 00 00 00 04 / 00 00 00 36 / 00 00 00 02 / 00 00 01 22 / 00 00 00 02 / 00 00 00 00 So the values are 0x2b1625 / 0x4 / 0x36 / 0x2 / 0x122 / 0x2 / 0x0 local and global There are two kinds of variables: \"local\" means variable inside one file. \"global\" means variable across multiple PAC files. Avoid using global, unless you want to use the variable for multiple PAC files. If you really have to use it, check carefully if the global variables used in any of other PAC file. Immediate and Variable So, always check example first. Reading as Hex You can open hex editor to read PAC instructions. And then, follow this: Slice them into 4 bytes. Slice if next block starts with 25. Check every block starts with 25, they are instructions. Slice parameters to 4~8 bytes. starting with 1 2, 4, 8, 10, 20, 40, 80, are potentially 8-bye parameters, but DO NOT RELY on this! You can do it inside you hread, or with help of a hex editor (e.g. ImHex). Though, the method is rough (especially in 3, or rarely, even parameter value can be 0x25 etc), that is why checking document is important. Example 25 00 08 00 08 00 00 00 62 00 00 00 10 00 00 00 00 00 20 41 25 00 01 00 25 0A 05 00 02 00 00 00 02 00 00 00 04 00 00 00 01 00 00 00 25 00 17 00 04 00 00 00 01 00 00 00 10 00 00 00 00 00 00 00 54 0E 00 00 25 00 12 00 08 00 00 00 EE 01 00 00 02 00 00 00 F0 FF 00 00 25 00 12 00 04 00 00 00 00 00 00 00 02 00 00 00 0F 00 00 00 25 00 13 00 08 00 00 00 EE 01 00 00 04 00 00 00 00 00 00 00 25 00 01 00 First, cut off them as 4 bytes for easier understanding. 25 00 08 00 / 08 00 00 00 / 62 00 00 00 / 10 00 00 00 / 00 00 20 41 / 25 00 01 00 / 25 0A 05 00 / 02 00 00 00 / 02 00 00 00 / 04 00 00 00 / 01 00 00 00 / 25 00 17 00 / 04 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 54 0E 00 00 / 25 00 12 00 / 08 00 00 00 / EE 01 00 00 / 02 00 00 00 / F0 FF 00 00 / 25 00 12 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 0F 00 00 00 / 25 00 13 00 / 08 00 00 00 / EE 01 00 00 / 04 00 00 00 / 00 00 00 00 / 25 00 01 00 Second, Cut just before 25 XX XX XX. 25 00 08 00 / 08 00 00 00 / 62 00 00 00 / 10 00 00 00 / 00 00 20 41 25 00 01 00 25 0A 05 00 / 02 00 00 00 / 02 00 00 00 / 04 00 00 00 / 01 00 00 00 25 00 17 00 / 04 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 54 0E 00 00 25 00 12 00 / 08 00 00 00 / EE 01 00 00 / 02 00 00 00 / F0 FF 00 00 25 00 12 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 0F 00 00 00 25 00 13 00 / 08 00 00 00 / EE 01 00 00 / 04 00 00 00 / 00 00 00 00 25 00 01 00 Third, Check the corresponding instructions. 25 00 08 00 / 08 00 00 00 / 62 00 00 00 / 10 00 00 00 / 00 00 20 41 cmd_add((int/float *)target, (int/float)value) 25 00 01 00 cmd_end() 25 0A 05 00 / 02 00 00 00 / 02 00 00 00 / 04 00 00 00 / 01 00 00 00 getLaboInfo((int)Var0, (uint)Var1) 25 00 17 00 / 04 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 54 0E 00 00 cmd_ifEQ((int/float)value1, (int/float)value2, (Address)address) 25 00 12 00 / 08 00 00 00 / EE 01 00 00 / 02 00 00 00 / F0 FF 00 00 cmd_iand((uint *)target, (uint)value) 25 00 12 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 0F 00 00 00 cmd_iand((uint *)target, (uint)value) 25 00 13 00 / 08 00 00 00 / EE 01 00 00 / 04 00 00 00 / 00 00 00 00 cmd_ior((uint *)target, (uint)value) 25 00 01 00 cmd_end() And then, fill the parameters. (Check About Parameters for this) Note the value is Little Endian so you have to read 4 bytes in reverse order. 25 00 08 00 / ((08 00 00 00) 62 00 00 00) , ((10 00 00 00)00 00 20 41 ) cmd_add((global)int iVar0x62, (float)10.0) 25 00 01 00 cmd_end() 25 0A 05 00 ((02 00 00 00) 02 00 00 00) , ((04 00 00 00)01 00 00 00) getLaboInfo((int)0x2, int iVar0x1) 25 00 17 00 / ((04 00 00 00)01 00 00 00) , ((10 00 00 00)00 00 00 00) , (54 0E 00 00) cmd_ifEQ((int)iVar0x1, (float)0.0, (Address)0xE54) 25 00 12 00 / ((08 00 00 00)EE 01 00 00) , ((02 00 00 00 )F0 FF 00 00) cmd_iand((global)int gVar0x1EE, (uint)0xFFF0) 25 00 12 00 / ((04 00 00 00)00 00 00 00) , ((02 00 00 00)0F 00 00 00) cmd_iand(int iVar0x0, (uint)0xF) 25 00 13 00 / ((08 00 00 00)EE 01 00 00) , ((04 00 00 00) , 00 00 00 00) cmd_ior((global)uint gVar0x1EE, uint 0x0) 25 00 01 00 cmd_end() This could be hard for first time, but if you do this enough, you will get gut to read them."
  },
  "guide/reference-table.html": {
    "href": "guide/reference-table.html",
    "title": "Reference table",
    "keywords": "Reference table Drum / Command Drum IDs Id Command 0 No input/Command Cancel 1 Pon 2 Don 3 Pata 4 Chaka Command IDs Id Command 0 March 1 Defend 2 Attack 3 Charge 4 Dodge 5 Jump 6 Party 6 Party 7 Chakapata 8 Patapon 9 Summon Input ID Flags They are flags, since multiple buttons can be pressed at same time. Id Button 0x1 Start 0x8 Select 0x10 Up Arrow 0x20 Right Arrow 0x40 Down Arrow 0x80 Left Arrow 0x100 L 0x200 R 0x1000 △ (Chaka) 0x2000 ◯ (Pon) 0x4000 ✕ (Don) 0x8000 □ (Pata) 0x40000 Scroll Up 0x10000 Scroll Down Other gameplay Status Effect table As non-flag Id Status 0 Freeze 1 Sleep 2 Poison 3 Stagger 4 Tumble 5 Knockback 6 Burn As flag Those values are bitshifted from non-flag IDs. (1 << (nonflagID)) This are used e.g. getAbnormalStatus. Id Status 0x1 Freeze 0x2 Sleep 0x4 Poison 0x8 Stagger 0x10 Tumble 0x20 Knockback 0x40 Burn Troop types Setting enemies to player troop might cause unwanted positioning. ID Layer Hits Player Hits Enemy Example 0 Player No Yes Catapult, Ziggerzank 1 Enemy Yes No All bosses, minibosses, deths etc. 2 Unused Yes Yes Unused 3 Both Yes Yes Grass, Firewall 4 None No No Talking sign Summon IDs Id Status 0x0 Yarigami 0x1 Tategami 0x2 Soragami 0x3 Yamagami 0x4 Moegami (Unused) 0x5 Super Yarigami 0x6 Super Tategami 0x7 Super Soragami 0x8 Super Yamagami Units Generatorparam Generatorparam info (html) Generatorparam info (CSV) Class IDs ID ID Hex Unit 0 0x0 Dummy 1 0x1 Hatapon 2 0x2 Yarida 3 0x3 Taterazay 4 0x4 Yumiyacha 5 0x5 Kibadda 6 0x6 Dekapon 7 0x7 Megapon 8 0x8 Mahopon 9 0x9 Destrobo 10 0xA Chakapon 11 0xB Charipon 12 0xC Piekron 13 0xD Wooyari 14 0xE Pyokorider 15 0xF Cannassault 16 0x10 Charibasa 17 0x11 Guardira 18 0x12 Tondenga 19 0x13 Myamsar 20 0x14 Bowmunk 21 0x15 Grenburr 22 0x16 Alosson 23 0x17 Wondabarappa 24 0x18 Jamsch 25 0x19 Oohoroc 26 0x1A Pingrek 27 0x1B Cannogabang 28 0x1C Ravenous 29 0x1D Sonarchy 30 0x1E Ragewolf 31 0x1F Naughtyfins 32 0x20 Slogturtle 33 0x21 Covet-Hiss 34 0x22 Buzzcrave Note that Charaparm has a bit different order from this (Yumiyacha goes first in Charaparam). Action IDs This varies depending on the model. For detali, see Tayo's table. (Credit to Tayo Fox for documenting this) SquadActivityParam IDs The squadactivity Id must be applied to the correct class/unit, otherwise it won't work. SquadActivityparam IDs (html) SquadActivityparam IDs (CSV) Other Entities Effectparam IDs Effectparam IDs (html) Effectparam IDs (CSV) Gimmickparam IDs Gimmickparam IDs (html) Gimmickparam IDs (CSV) Mission Mission IDs Mission ID table (html) Mission ID table (CSV) Stage IDs Stages with Stage IDs (Video) Cutscene IDs ID Scene 0x124 Ending (going earthend scene) 0x125 Test scene (Ragewolf and Hero Jumping) 0x126 Field of Angry Giants 1st clear scene 0x127 Field of Angry Giants 2nd clear scene 0x128 Arena of Valor clear scene (ragewolf mentioning Summon) 0x129 Shakapon Summon Teaching 0x12a (Unused Pata2 hero tortue scene... crying) 0x12b Snow of Sullied Tears 1st clear (Fins First Appear, \"What have we here!\") 0x12c Snow of Sullied Tears 2nd clear [It seems that ... Wants Selection] 0x12d Snow field Racing Alley clear (\"So this is the Tower of Purity...\") 0x12e Plateau of Pompous Wings 1st clear(Sonarchy first appear) 0x12f Plateau of Pompous Wings 2nd clear [Dialogue, might not matter] 0x130 1st Missile battle clear [Dialog, contains naughtyfins too] 0x131 Archfiend of Justice Clear (Ravenous first appear) 0x132 Greedy Mask Jungle 1st clear (Kidnapped Mecha Hoshipon, \"You can both have me\") 0x133 Greedy Mask Jungle 2nd clear [What rare item/Where is Naughtyfins] 0x134 After Earnestness VS (Mecha Hoshipon disappeared) 0x135 Bottomless Stomach Desert 1st clear (First Buzzcrave Appear) [Fins itching th say something...] 0x136 Bottomless Stomach Desert 2nd clear (Toothpick rare item lol, What was your password) 0x137 Racing Desert clear (Ravenous past) 0x138 Labyrinth of Restraint clear (Fins dying) 0x139 Volcano Zone of the Lazy Demon 1st clear 0x13a Volcano Zone of the Lazy Demon 2nd clear 0x13b Evilmass of Adamance Clear [Princess saving scene!] 0x13c Ravenous: Dule of Fate clear (Ravenous answer scene) 0x13d Covet-hiss Loves Cannon clear (Ragewolf dying) 0x13e Dark heroes last stand clear (\"Papa no medicine\") 0x13f Ending (DH talking) 0x140 Test scene (\"no translation needed\" ragewolf and hero) 0x141 Test scene (\"no translation needed\" ragewolf and hero) 0x142 Test scene (\"no translation needed\" in dark hero hideout) Hideout Facility IDs ID Type 0x0 Silver Hoshipon 0x1 Blacksmith 0x2 Herogate 0x3 Armoury 0x4 Team Totem 0x5 Barracks 0x6 sukopon 0x7 Mission Obelisk 0x8 Battle Gate 0x9 Meden 0xA Festival Item indexes Item ID + Weaponparam ID Indexes Itemparam table, with weaponparam ID (html) Itemparam table, with weaponparam ID (CSV) Equipment Group ID indexes ID Equipment 0 Sword 1 Blade 2 Spear 3 Pike 4 Lance 5 Arm 6 Dagger 7 Shiv 8 Greatsword 9 Greatblade 10 Axe 11 Hammer 12 Bow 13 Longbow 14 Crossbow 16 Horn 17 Longhorn 18 Twinhorn 19 Staff 20 Scepter 21 Cannon 22 Blunderbuss 23 Laser 24 Helm 25 Shield 26 Greatshield 27 Shoulderguards 28 Cape 29 Boots 30 Horse 31 Warhorse 32 Chariot 33 Mask 34 Rock 35 Claw 36 Scythe Enchant IDs enchant_id Enchant 0 None 1 St 2 G 3 De 4 H 5 Sl 6 Fl 7 Po 8 Hp 9 Me 10 Ar 11 W 12 En 13 Ic 14 Cu Music Theme IDs Theme ID list (html) Theme ID list (CSV) Music/Sound List (For playAtrac etc.) Warning This list is incomplete. Please describe how to get the correct sound index from a file. The ID has same order as selist.slt (in DATA_CMN\\loadinggroup\\systemdata\\sound). Here are few examples: title 507000f8: create player screen 4fd000ee: titlescreen (title_b.sgd) 50d000fe: choose starter azito 50b000fc: barracks (organization.sgd) 505000f6: hideout closed (azito.sgd) 506000f7: hideout open (ajito_multi.sgd) 50e000ff: blacksmith (workshop.sgd) 50f00100: world map (world_map.sgd) mission-story 4ff000f0: tutorial sign theme 51300104: archfiend theme (evil_and_boss.sgd) 500000f1: \"evil plan\" 51400105: suspect theme - duel tahi tahi..? 51500106: funny evil story mission 509000fa: result screen (fail) 50c000fd: result screen (success) 51000101: chest screen 4e0000d1: ??? 4e0000d2: Units battle sound 4e0000d3: Chants 508000f9: Mission success sound 50a000fb: Mission fail sound 51100102: Return to the Hideout? Find music/sound ID manually Find the music/sound in selist.spm by name. For example, azito.sgd is in 0x334c Do the data_addr = name_address-0x14. In the example, it is 0x334c - 0x14 so 0x3338. Find the data_addr from 2. In example, search by 38 33 (And the value can be found in 0x3F8) Subtract 0x20 from the result of 3. In the example, it is 0x3f8 - 0x20 = 0x3d8`. Divide to 4 from the result of 4. So 0x3d8/4 is 0xf6, which proves it is the ID of azito.sgd. Magic word list This means \\<NX> type of the text. ID Text Highlight Other player sees same value 0x0 Own almighty name No No 0x1 Player 1 hero Yes Yes 0x2 Player 1 hero No Yes 0x3 Player 2 hero No Yes 0x4 Player 3 hero No Yes 0x5 Player 4 hero No Yes 0x6 Player 1 Almighty No Yes 0x7 Unused No N/A 0x8 Unused No N/A 0x9 Unused No N/A 0xA Own ka-ching value No No 0xB Player 1 hero Yes Yes 0xC``~0xF` Dynamic data region No No, Maybe The dynamic region often can be replaced by PAC instructions. Tips ID ID Tip 0x0 Optimise Equipment 0x1 Collect Ka-ching and Materials 0x2 Equip Set Skills 0x3 Develop Class Skills 0x4 Magic-imbued Weapons 0x5 Visit Otherworlds with Herogate 0x6 Share Team Cards 0x7 Sukopon 0x8 Gear up in the Barracks! 0x9 Use the Armoury 0xa Fabulous Meden Mart 0xb Ad-lib Session with Summon 0xc Maximise Summon Potential 0xd Sutra Symbols for Summon 0xe Four-beat Commands 0xf Hatapon In The Middle 0x10 Never Neglect to Equip 0x11 Hero Mode 0x12 Effective CHAKA CHAKA 0x13 Taterazay Fever Advance 0x14 Silver Hoshipon! 0x15 Grass Fires Spread 0x16 Boost Level 0x17 Drum in Rhythm! 0x18 Cannot be Reborn in Dungeon! 0x19 Donchaka Song (□○×△) 0x1a Class Change 0x1b Tips Collection 0x1c Communicate with Chat! 0x1d Hatapon's Flag 0x1e Hatapon Damage 0x1f Stagger and Knockback 0x20 About Shield Evasion 0x21 About Shield Breaker 0x22 Level Up Blacksmith 0x23 Summon Yourself 0x24 Spear Class Tree 0x25 Shield Class Tree 0x26 Archer Class Tree 0x27 Yarida Tips 0x28 Kibadda Tips 0x29 Piekron Tips 0x2a Wooyari Tips 0x2b Pyokorider Tips 0x2c Cannassault Tips 0x2d Charibasa Tips 0x2e Taterazay Tips 0x2f Destrobo Tips 0x30 Guardira Tips 0x31 Tondenga Tips 0x32 Myamsar Tips 0x33 Bowmunk Tips 0x34 Grenburr Tips 0x35 Yumiyacha Tips 0x36 Alosson Tips 0x37 Wondabarappa Tips 0x38 Jamsch Tips 0x39 Oohoroc Tips 0x3a Pingrek Tips 0x3b Cannogabang Tips 0x3c VS Rules: Head-on 0x3d VS Rules: Racing Alley 0x3e VS Rules: Missile Battle 0x3f Cyclops Snacks on Patapons 0x40 Treants Love Rain 0x41 Dragon Puppies 0x42 Expanding Salamanders 0x43 Golems Rumble Along 0x44 Defend From Dragon Breath 0x45 Beware of Fenrir! 0x46 The Rancid Breath of Death 0x47 Balrog the Hungry Demon 0x48 Gargoyle the Tease 0x49 Unique Equipment 0x4a The Best Chests 0x4b Using the Blacksmith 0x4c Effective Use of Blacksmith 0x4d Visit Other Blacksmiths 0x4e 【Arch Item】 0x4f Change Equipment Name 0x50 Perfect Command Input 0x51 Importance of Shield Class 0x52 Hit with Charge Attack 0x53 Hunker Down with Charge Defence 0x54 Evade? Or jump? 0x55 Careful of Status Effects 0x56 Destroy Structures with 【Strike】 0x57 Pillage Bonedeth Treasure 0x58 Multiplayer Quests 0x59 Anticipate Boss Attacks 0x5a Team Up for Big Catches 0x5b Anticipate the Wind 0x5c Piekron and Rain 0x5d So Many Djinns 0x5e Boost Summon Energy 0x5f DON DODON DODON! 0x60 Remember to Data Sync 0x61 Hero Co-operation 0x62 Collect Team Points 0x63 Try VS with Battle Gate 0x64 Co-ordinate Arch Items 0x65 Hoshipon Shop and Star Shards 0x66 Search for Star Shards 0x67 Multiplayer Basics 0x68 Create a Team! 0x69 Receiving Team Cards 0x6a Rendezvous with Team 0x6b Changing Options 0x6c Using Server Mode 0x6d VS Matching 0x6e Failing Quests 0x6f Keys in Multiplayer 0x70 Status Effect Icon List 0x71 VS Odds and Ends 0x72 Pause with the PATA PON song 0x73 Congrats! Finished!♪【Bonus 1】 0x74 Congrats! Finished!♪【Bonus 2】 0x75 Congrats! Finished!♪【Bonus 3】 0x76 Multi VS: Hell Gate 0x77 Defect to the Dark Side♪"
  },
  "guide/the-flow.html": {
    "href": "guide/the-flow.html",
    "title": "The Flow",
    "keywords": "The Flow See also: How To: Define a Mission Caution This article exists for understanding the PAC instruction. Do not write the PAC instruction from bottom. There are many unknown logics e.g. bunch of unknown flags and creating it from bottom might break the game. Warmup Set Mission Data setMaxMissionAreaId setMissionAreaId setQuestLevelRevise setQuestPayExp setQuestPayItem Set logic when misison is done (item drop, levelup) Call setMissionTimmingScript (usually 0, 1, 2) Finish with cmd_end MissionTimmingScript Related article: setMissionTimmingScript MissionTimmingScript 0 readArcFile, and THEN requestActor if needed. MissionTimmingScript 1 Define item drop during mission Create Entities MissionTimmingScript2 Rest of the in-mission logic"
  },
  "guide/troubleshooting.html": {
    "href": "guide/troubleshooting.html",
    "title": "Troubleshooting",
    "keywords": "Troubleshooting How to Debug Warning Debug tool works only in Windows. Checking parameter values 0x0883ce54 (EU ver) returns address that contains parameter value. If you want to know the parameter value at certain point, in certain address: Make sure the PAC instruction will be called. If not sure, it can be started from the first. Read breakpoint the value part (not type part) of the parameter (Ctrl+D and press \"Breakpoint\" on the top). For example 04 00 00 00 08 01 00 00, set breakpoint to the 08 01 00 00. Press Step Out button once. type v0 in memory viewer Goto field, and it will lead to the actual parameter value. Editing the PAC instruction in PPSSPP Savestate is great for the troubleshooting. This is how to debug the mission. Savestate the game just before deploying. Deploy, but stay on tip screen. Find the address where the mission PAC instructions are (anywhere), and set write breakpoint to there. Load the savestate from 1 and deploy again. When the PAC instruction is written, and the breakpoint is activated, savestate it (in same or different place). Edit the desired place and press Go (F8). In this way, you can press F8 to pause at any time, and load the savestate from 5, edit, and continue. This method is good for e.g. positioning entities. Troubleshoot The instruction is not called? Find the instruction from the memory. Read breakpoint it (Ctrl+D and press \"Breakpoint\" on the top). If it is not read, check if you forgot to call the instruction. If it is read, it is another issue. If you didn't forget but it's not called, check other condition like cmd_ifEQ. Check the parameter and typo. Unfortunately, there is no way to debug like modern debugging tool, so be patient. Why the model is not loaded? Check if the handle is greater than zero. If it does, maybe it can be one of them: Make sure readArcFile and requestActor is missionTimming 0. requestActor does not need in some case like setReqActorType by the way. Make sure the position is correct and not out of the bound. If still does not work, check if the entity amount is set to 1 (default is 0 and it won't work). If the handle is negative, check out: Check if it is created with reqActorType in missionTimming 1 If it did, check if it is spawned in missionTimming 2. Last but not least, check the typo, and check the order. It crashes or does infinite loading. Do not resize the PAC instruction from middle. Check if the function calls or jumps to invalid address. Check if you forgot cmd_end. Some resources (probably from Patapon 1 or 2) don't exist, or will refuse to load normally (e.g. Gargoyle chest). Try deleting (filling the instruction to 0) them and try again, and if the game is loaded, it's probably the resource issue. Check the typo. Check if the instruction has invalid parameter (enum out of bounds). This applies to only few instructions. Still it doesn't work! Maybe the instruction might not work as your expectation. Make sure you understood the instruction correctly, and ask experienced people for help."
  },
  "guide/what-is-pac.html": {
    "href": "guide/what-is-pac.html",
    "title": "What is PAC?",
    "keywords": "What is PAC? PAC is special script owned by Pyramid Inc. The company is dead, so currently there is no learning material for this. Patapon series is their only famous game, so you can see PAC as Patapon specific instructions (even though few other unfamous games use it). Each PAC instruction has their Assembly function. Though, you will reach the limit with pure Assembly without PAC instruction. Where are the PAC? They are in many places. For example, missionXXXXXX.pac in DATA_CMN is PAC (they are gzipped). loadinggroupscript in DATA_CMN is another place for PAC instructions. Azito.pac : Hideout logic, loaded when hideout is loaded. labo.pac : Loaded between hideout and mission. Decides e.g. tip loading logic. Mission_??_??.pac : In-game logic, loaded in tip screen. mission_99_00.pac : Story cutscenes. effect.pac : Global effect logic, loaded once when Patapon 3 is launched. monster.pac : Global enemy behaviour logic, loaded when hideout or a mission is loaded. For custom mission, either Mission_??_??.pac How do I know it is PAC? PAC commands are always 25 XX XX XX. So if you see bunch of % in memory, it is probably PAC instructions. (But be careful, DxD validates PAC in end of the Mission, so editing them in Mission might cause crashing!) How to read the PAC? Related article: Reading PAC. How to write the PAC? I am assuming you are asking about modifying. Writing from the bottom is terrifying and extremely unreliable. You need Hex editor. Unfortunately, there is no intuitive graphical magic editor for writing PAC. (Modders really don't try to make it because they even can't read lol) While modders doing their work, you can check writing PAC meantime. Can I define a new PAC function? Nuh uh that's very hard and I don't know even if it is possible. And why would you?"
  },
  "guide/writing-pac.html": {
    "href": "guide/writing-pac.html",
    "title": "How to (over)write a PAC instruction",
    "keywords": "How to (over)write a PAC instruction As I said \"I am assuming you are asking about modifying. Writing from the bottom is terrifying.\" This is about modifying existing PAC instruction. Since there are bunch of common condition checking and resource/effect loading, writing from bottom is very very discouraged and you couldn't do it anyway. Also, always check context of the parameter before assigning any parameter. Otherwise it might cause potential disaster. small local parameter indexes like 0, 1, 2, 3 (e.g. 04 00 00 00 01 00 00 00) are potentially temporary parameters that can be changed at any time. Case 1: Your code occupies less space Easy, you can just fill 00 in empty spaces. Just try to fill zero just BEFORE 25 XX XX XX, which is next PAC instruction. Case 2: Your code occupies same space Just overwrite them. Case 3: Your code occupies more space Do not insert from the middle. Always append at the end of the file. The edited PAC file size can be bigger than original, and there is no issue with the size. (Unless the file size is very big so doesn't fit to the memory, which is not ordinary) Another approach is replacing unused part like debug mode code (be sure to make debug mode inaccessible in this case). 1. Using cmd_jmp Pick the instruction after the position you want to insert. If the one instruction is only 4 bytes, pick two instructions. Replace it to cmd_jmp that goes to end of the file. Insert your code in end of the file. Put the original instruction(s) from step 1 to the end of the file. Put the cmd_jmp to the end of the file! 2. Using cmd_call (Recommended) Pick the instruction after the position you want to insert. If the one instruction is only 4 bytes, pick two instructions. Replace it to cmd_call that goes to end of the file. Insert your code in end of the file. Put the original instruction(s) from step 1 to the end of the file. Put [cmd_end](../cmd_end.md) to the end of the file! DO NOT extend from the middle of the file! It will mess up a lot of jump and call condition (reminder they use offset from PAC file)."
  },
  "incquestcompletecounter.html": {
    "href": "incquestcompletecounter.html",
    "title": "incQuestCompleteCounter",
    "keywords": "incQuestCompleteCounter Adds 1 to quest completing count. DLC Quests call this with Mission ID -1. Max quest complement amount stored is 100 (0x64). Code Information Name: incQuestCompleteCounter Scope: Global PAC Instruction (Binary): 25 0a 3c 00 Assembly Address in Memory : 0x894cf34 Parameters (int)mission_id (8 bytes) : The Mission ID to increment the completing counter. Example Here is one example in hex: 25 0a 3c 00 / 08 00 00 00 / 1c 00 00 00 Which is interpreted as: incQuestCompleteCounter(((global)int *)giVar28) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cf34(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; // get quest counter addr puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = return__0x1c(*(undefined4 *)(iVar2 + 0x50)); FUN_089feaf0(iVar2 + 0xedae,*puVar1); iVar2 = Get_Some_Flag(1); Increment_QuestCounter(*(undefined4 *)(iVar2 + 0x54),*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home",
    "keywords": "Welcome! Here are some basic guides about the PAC instructions. What is PAC? Code of Conduct Getting Started Reading PAC Writing PAC Instructions by Category Reference Table Disclaimer Can't guarantee those guides are 100% correct, and the guides aren't tested well. Also there could be a lot of broken English. This happens when one person writes docs of 500 instructions + alpha If there is something incorrect, please fix this. Special Thanks This cannot be possible without them: F0NT for mapping PAC instruction name to address. Nemoumbra for sharing disassembled PAC instructions. Other modders who documented stuffs and made tools."
  },
  "initversus02commondata.html": {
    "href": "initversus02commondata.html",
    "title": "initVersus02CommonData",
    "keywords": "initVersus02CommonData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: initVersus02CommonData Scope: Global PAC Instruction (Binary): 25 16 29 01 Assembly Address in Memory : 0x8927b54 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 16 29 01 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: initVersus02CommonData((int)1, (int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927b54(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar5 != 0) { if (*piVar1 == 1) { iVar4 = *piVar2; if ((-1 < iVar4) && (iVar4 < 2)) { *(undefined4 *)(iVar4 * 4 + *(int *)(iVar5 + 0x48) + 0x44) = *puVar3; } } else if (*piVar1 == 0) { iVar4 = *piVar2; if ((-1 < iVar4) && (iVar4 < 2)) { *(undefined4 *)(iVar4 * 4 + *(int *)(iVar5 + 0x48) + 0x3c) = *puVar3; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "initversus04commondata.html": {
    "href": "initversus04commondata.html",
    "title": "initVersus04CommonData",
    "keywords": "initVersus04CommonData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: initVersus04CommonData Scope: Global PAC Instruction (Binary): 25 16 2d 01 Assembly Address in Memory : 0x8927e40 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927e40(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar5 != 0) { iVar4 = *piVar1; if (iVar4 == 2) { *(undefined *)(*(int *)(iVar5 + 0x68) + 0xc4) = 0; } else if (iVar4 == 1) { iVar4 = *piVar2; if ((-1 < iVar4) && (iVar4 < 2)) { *(undefined4 *)(iVar4 * 4 + *(int *)(iVar5 + 0x68) + 0xbc) = *puVar3; } } else if (iVar4 == 0) { *(undefined4 *)(*(int *)(iVar5 + 0x68) + 0xb8) = *puVar3; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isactivegen.html": {
    "href": "isactivegen.html",
    "title": "isActiveGen",
    "keywords": "isActiveGen check if the generator is loaded and active. Code Information Name: isActiveGen Scope: Mission PAC Instruction (Binary): 25 1f 32 00 Assembly Address in Memory : 0x8b5ee10 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (uint *)is_active (8 bytes) : Variable to store if the generator is active. Example Here is one example in hex: 25 1f 32 00 / 04 00 00 00 / 2b 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isActiveGen((int *)iVar43, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5ee10(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else if (*piVar1 == -1) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar3 + 0x2c8)); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 == 0) { *puVar2 = 0; } else { *puVar2 = (uint)*(byte *)(iVar3 + 0x24); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isdamaged.html": {
    "href": "isdamaged.html",
    "title": "isDamaged",
    "keywords": "isDamaged Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isDamaged Scope: Global PAC Instruction (Binary): 25 17 40 00 Assembly Address in Memory : 0x8915540 Parameters (int)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 17 40 00 / 04 00 00 00 / 0e 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isDamaged((int *)iVar14, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915540(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { *puVar2 = (uint)((*(byte *)(iVar3 + 0x8c) & 1) != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isenable.html": {
    "href": "isenable.html",
    "title": "isEnable",
    "keywords": "isEnable Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isEnable Scope: Global PAC Instruction (Binary): 25 17 02 00 Assembly Address in Memory : 0x8910cfc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 02 00 / 08 00 00 00 / 5b 00 00 00 / 08 00 00 00 / ff 01 00 00 Which is interpreted as: isEnable(((global)int *)giVar91, ((global)int *)giVar511) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08910cfc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if ((*(int *)(param_1 + 0x14) != 0) && (iVar3 = Find_Target_By_HandleID(*(int *)(param_1 + 0x14),*puVar1,0), iVar3 != 0)) { *puVar2 = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isenablerhythmhit.html": {
    "href": "isenablerhythmhit.html",
    "title": "isEnableRhythmHit",
    "keywords": "isEnableRhythmHit Gets if the command cancel is enabled or not. Code Information Name: isEnableRhythmHit Scope: Global PAC Instruction (Binary): 25 0c 26 00 Assembly Address in Memory : 0x89715f0 Parameters (int *)disable_commandcancel (8 bytes) : Variable to store the result. 0 is command cancel enabled, 1 is command cancel disabled. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089715f0(undefined4 param_1,undefined4 param_2) { uint *puVar1; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = (uint)DAT_08b98eb0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isequipweaponintroop.html": {
    "href": "isequipweaponintroop.html",
    "title": "isEquipWeaponInTroop",
    "keywords": "isEquipWeaponInTroop Checks if a specific weapon is equippped in the troop. Used for effect loading. Code Information Name: isEquipWeaponInTroop Scope: Global PAC Instruction (Binary): 25 16 2c 00 Assembly Address in Memory : 0x891c214 Parameters (int)troop_index (8 bytes) : Troop side, either 0 or 1 (0 for player/blue side, 1 for enemy/red side). (int)weaponparam_id (8 bytes) : Equipment ID from weaponparam. (int *)result (8 bytes) : Variable to store the result, 1 if the equipment is equipped, otherwise 0. Example Here is one example in hex: 25 16 2c 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 4a 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isEquipWeaponInTroop((int *)iVar1, (int)74, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891c214(undefined4 param_1,undefined4 param_2) { char cVar1; int *piVar2; int *piVar3; int *piVar4; undefined4 uVar5; int iVar6; int iVar7; undefined4 uVar8; int *piVar9; int iVar10; uint uVar11; int iVar12; short *psVar13; int iVar14; int iVar15; int local_3c; int local_38; undefined auStack48 [4]; char local_2c; int local_24; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); piVar3 = (int *)Pac_Get_Param(param_2,1,1,4); piVar4 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar4 = 0; uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); iVar10 = *(int *)(iVar6 + 0x44); cVar1 = *(char *)(iVar10 + 0x24); iVar6 = Get_Some_Flag(1); uVar5 = *(undefined4 *)(iVar6 + 0x34); iVar6 = 0; local_38 = iVar10 + *piVar2 * 0x58a4 + 0x2550; do { if ((3 < iVar6) || (*piVar4 != 0)) { PAC::PAC_setCmdId(param_2,0); return; } if (*(int *)(local_38 + 4) != 0) { FUN_08960154(local_38 + 4); iVar12 = 0; local_3c = local_38 + 4 + *(int *)(local_38 + 8) * 0x84 + 0x14; do { iVar14 = local_3c + 0x18; if (*(int *)(local_3c + 0x18) != 0) { uVar11 = 0; do { if (uVar11 < 6) { piVar9 = (int *)(iVar14 + 4); } else { piVar9 = (int *)0x0; } if ((int)*(char *)piVar9 << 0x1f < 0) { iVar7 = *piVar9; iVar15 = -1; if ((cVar1 == '\\0') || (iVar7 >> 1 != -2)) { FUN_08a15694(auStack48); Equipment::Get_Equipment_Name_Save_Validity(auStack48,iVar7 >> 1,uVar5); if (local_2c == '\\0') goto LAB_0891c478; if (-1 < local_24) { iVar15 = local_24; } } else { iVar7 = FUN_089880e8(iVar10 + 0x850,*piVar2,iVar6); if (iVar7 != 0) { psVar13 = (short *)(iVar7 + 0x58 + (iVar12 + uVar11) * 0xc); iVar15 = (int)*psVar13; if (iVar15 < 0) goto LAB_0891c478; uVar8 = Save::Get_Save_BaseAddr(1); iVar7 = Save::Get_BaseAddr__0x78(uVar8,1); uVar8 = Param::Get_Data_Addr(*(undefined4 *)(iVar7 + 0xa4),9); Param::Get_Line_Addr(uVar8,0,iVar15,1); iVar15 = *(int *)(psVar13 + 2); } } if ((-1 < iVar15) && (iVar15 == *piVar3)) { *piVar4 = 1; PAC::PAC_setCmdId(param_2,0); return; } } LAB_0891c478: uVar11 = uVar11 + 1; iVar14 = iVar14 + 4; } while ((int)uVar11 < 6); } iVar12 = iVar12 + 1; local_3c = local_3c + 0x34; } while (iVar12 < 1); } iVar6 = iVar6 + 1; local_38 = local_38 + 0x1620; } while( true ); }"
  },
  "isexistdlcquestfile.html": {
    "href": "isexistdlcquestfile.html",
    "title": "isExistDLCQuestFile",
    "keywords": "isExistDLCQuestFile Checks if the DLC file with the given quest ID exists. Code Information Name: isExistDLCQuestFile Scope: Azito PAC Instruction (Binary): 25 1c 35 00 Assembly Address in Memory : 0x8b505d8 Parameters (int)mission_id (8 bytes) : ID of the mission, the id is unique in the map. The mission ID can be duplicated in different world map. (uint *)destination (8 bytes) : Variable to store the existence, either 0 or 1. 0 if does not exist. Note Madwig DLC quest contains all available DLC mission IDs. There is no way to add new missions to there without editing Assembly code. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): /* `0x08874d60` in memory decides edat file name. 1st parameter \"dlc_mission_XXXX\" string address, 2nd parameter the string length, called from `08a0f680`. Seems like there are total 64 dlc mission slots available. */ void FUN_Azito__08b505d8(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; uint uVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar4 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar4 != 0)) { uVar3 = FUN_Azito__08b59210(iVar4,*puVar1); *puVar2 = uVar3 & 0xff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isflag.html": {
    "href": "isflag.html",
    "title": "isFlag",
    "keywords": "isFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isFlag Scope: Global PAC Instruction (Binary): 25 17 57 00 Assembly Address in Memory : 0x8917528 Parameters (int)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 17 57 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: isFlag((int *)iVar65, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917528(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; int iVar4; uint uVar5; undefined4 uVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { *puVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 == 0) || (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 != 9)) { if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { uVar6 = FUN_088c5348(iVar3,0); uVar5 = FUN_088b907c(uVar6); *puVar2 = uVar5 & 0xff; } } else { uVar5 = FUN_088b907c(iVar3); *puVar2 = uVar5 & 0xff; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isforceshootmissile.html": {
    "href": "isforceshootmissile.html",
    "title": "isForceShootMissile",
    "keywords": "isForceShootMissile Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isForceShootMissile Scope: Global PAC Instruction (Binary): 25 16 3c 01 Assembly Address in Memory : 0x892af88 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 3c 01 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isForceShootMissile((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892af88(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_0883c04c(param_2,0); if (((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar2 + 0x2c) + 0x54),*puVar1), iVar2 != 0)) { uVar3 = FUN_08a4e3fc(iVar2); FUN_0883c04c(param_2,uVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isfrontlineenterattack.html": {
    "href": "isfrontlineenterattack.html",
    "title": "isFrontLineEnterAttack",
    "keywords": "isFrontLineEnterAttack Check if the front of the squad is in the attack distance. Code Information Name: isFrontLineEnterAttack Scope: Global PAC Instruction (Binary): 25 16 f1 00 Assembly Address in Memory : 0x8926c24 Parameters (int *)squad_handle (8 bytes) : The target squad handle. (int)squadactivityparam_id (8 bytes) : squadActivityParam id that contains the attack distance, -1 for default. (int *)result (8 bytes) : 1 if the enemy entered the attack sight, otherwise 0. Example Here is one example in hex: 25 16 f1 00 / 04 00 00 00 / 2c 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: isFrontLineEnterAttack((int *)iVar44, (int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926c24(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; int iVar6; float fVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0; iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) { iVar5 = *(int *)(iVar4 + 0x704); iVar6 = *(int *)(iVar4 + 0x490); if (iVar6 != 0) { fVar7 = (float)FUN_088f7c70(iVar4 + 0x1f0,*puVar2); if (*(int *)(iVar5 + 0x288) == 1) { fVar7 = fVar7 + *(float *)(*(int *)(iVar6 + 200) + 0xc0); } else { fVar7 = *(float *)(*(int *)(iVar6 + 200) + 0xc0) - fVar7; } iVar4 = FUN_088f9bb8(fVar7,iVar5 + 0x170); if (iVar4 == 0) { *puVar3 = 1; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isfrontlineenterview.html": {
    "href": "isfrontlineenterview.html",
    "title": "isFrontLineEnterView",
    "keywords": "isFrontLineEnterView Check if the front of the squad got the sight. Code Information Name: isFrontLineEnterView Scope: Global PAC Instruction (Binary): 25 16 f2 00 Assembly Address in Memory : 0x8926d60 Parameters (int *)squad_handle (8 bytes) : The target squad handle. (int)squadactivityparam_id (8 bytes) : squadActivityParam id that contains the sight, -1 for default sight. (int *)result (8 bytes) : 1 if there is something on their sight, otherwise 0. Example Here is one example in hex: 25 16 f2 00 / 04 00 00 00 / 2c 00 00 00 / 02 00 00 00 / ff ff ff ff / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: isFrontLineEnterView((int *)iVar44, (int)-1, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926d60(int param_1,undefined4 param_2) { char cVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; int iVar6; float *pfVar7; int iVar8; float fVar9; float fVar10; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar4 = 0; iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if ((iVar5 != 0) && (iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5), iVar6 == 3)) { iVar6 = *(int *)(iVar5 + 0x704); iVar8 = iVar6 + 0x170; fVar9 = (float)Action::Get_Unit_Attk_Distance(iVar5 + 0x1f0,*puVar3); cVar1 = pointer_offset18(iVar5 + 0x474); if (cVar1 == '\\0') { fVar10 = *(float *)(iVar8 + *(int *)(iVar5 + 0x184) * 0x10 + 0x20); } else { pfVar7 = (float *)offset__10(iVar5 + 0x260); fVar10 = *pfVar7; } if (*(int *)(iVar6 + 0x288) == 1) { fVar10 = fVar10 + fVar9; } else { fVar10 = fVar10 - fVar9; } iVar5 = FUN_088f9bb8(fVar10,iVar8); if (iVar5 == 0) { *puVar4 = 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isgogame.html": {
    "href": "isgogame.html",
    "title": "isGoGame",
    "keywords": "isGoGame Check if the game is fully ready to go after \"press any key to continue\" in tip screen. If the this is 1, startGame is called. Code Information Name: isGoGame Scope: Global PAC Instruction (Binary): 25 16 6e 00 Assembly Address in Memory : 0x892080c Parameters (int *)is_ready (8 bytes) : Variable to store if the game is ready, 0 is not ready yet, 1 is ready. Example Here is one example in hex: 25 16 6e 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isGoGame((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892080c(int param_1,undefined4 param_2) { uint *puVar1; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; if (*(int *)(param_1 + 0x10) != 0) { *puVar1 = (uint)*(byte *)(*(int *)(param_1 + 0x10) + 0x4b); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "ishero.html": {
    "href": "ishero.html",
    "title": "isHero",
    "keywords": "isHero Checks if the given unit is hero or not. Code Information Name: isHero Scope: Global PAC Instruction (Binary): 25 17 56 00 Assembly Address in Memory : 0x891741c Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (uint *)destination (8 bytes) : Destination to store if it is hero or not. The value is either 0 or 1. Example Here is one example in hex: 25 17 56 00 / 08 00 00 00 / 6e 01 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isHero(((global)int *)giVar366, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891741c(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { *puVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 == 0) || (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 != 9)) { if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { iVar3 = Is_HeroUnit(iVar3); *puVar2 = (uint)(iVar3 != 0); } } else { *puVar2 = (uint)*(byte *)(iVar3 + 0xa04); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isheromode.html": {
    "href": "isheromode.html",
    "title": "isHeroMode",
    "keywords": "isHeroMode Checks if a unit is currently in heromode or not. Code Information Name: isHeroMode Scope: Global PAC Instruction (Binary): 25 0c 16 00 Assembly Address in Memory : 0x8970dac Parameters (Undefined)Var0 (8 bytes) : This parameter does nothing. (bool *)destination (8 bytes) : Variable to store if it is in heromode. 0 if it is not in heromode. Example Here is one example in hex: 25 0c 16 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 05 00 00 00 Which is interpreted as: isHeroMode((int)0, (int *)iVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970dac(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; Pac_Get_Param(param_2,0,1,4); puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar1 = 0; if (iVar2 != 0) { *puVar1 = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isinsiderange.html": {
    "href": "isinsiderange.html",
    "title": "isInsideRange",
    "keywords": "isInsideRange Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isInsideRange Scope: Global PAC Instruction (Binary): 25 16 55 00 Assembly Address in Memory : 0x891f5a8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (undefined4)Var5 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891f5a8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; int iVar7; int iVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); *puVar6 = 0; if (*piVar1 == -1) { iVar7 = *(int *)(param_1 + 0x10); if (iVar7 == 0) { iVar7 = 0; } else { if (iVar7 == 0) { iVar7 = 0; } iVar7 = *(int *)(iVar7 + 0xf8); if (iVar7 == 0) { iVar7 = 0; } } if (((iVar7 != 0) && (iVar7 = FUN_088a8650(iVar7,0), iVar7 != 0)) && (iVar7 = FUN_088e2800(*puVar2,*puVar3,*puVar4,*puVar5,iVar7), iVar7 != 0)) { *puVar6 = 1; } } else { iVar7 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar1,1); if (iVar7 != 0) { iVar8 = (**(code **)(*(int *)(iVar7 + 4) + 0x34))(iVar7); if (iVar8 == 9) { iVar7 = FUN_088b8f90(*puVar2,*puVar3,*puVar4,*puVar5,iVar7); if (iVar7 != 0) { *puVar6 = 1; } } else if (iVar8 == 3) { iVar7 = FUN_088c6278(*puVar2,*puVar3,*puVar4,*puVar5,iVar7); if (iVar7 != 0) { *puVar6 = 1; } } else if ((iVar8 == 2) && (iVar7 = FUN_088e2800(*puVar2,*puVar3,*puVar4,*puVar5,iVar7), iVar7 != 0)) { *puVar6 = 1; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isloadend.html": {
    "href": "isloadend.html",
    "title": "isLoadEnd",
    "keywords": "isLoadEnd Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isLoadEnd Scope: Global PAC Instruction (Binary): 25 16 6f 00 Assembly Address in Memory : 0x8920870 Parameters (uint)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920870(int param_1,undefined4 param_2) { uint *puVar1; int iVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 != 0) { if (*(int *)(iVar2 + 0x2b8) == 0) { *puVar1 = (uint)*(byte *)(iVar2 + 0x4c); } else { *puVar1 = 0 < *(int *)(*(int *)(iVar2 + 0x2b8) + 0x68) ^ 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "ismyhero.html": {
    "href": "ismyhero.html",
    "title": "isMyHero",
    "keywords": "isMyHero Checks if the given unit is current player's hero or not. The value is false if the unit isn't players', or if the unit is not a hero. Code Information Name: isMyHero Scope: Global PAC Instruction (Binary): 25 17 68 00 Assembly Address in Memory : 0x89184b4 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (uint *)destination (8 bytes) : Destination to store if it is current player's hero or not. The value is either 0 or 1. Example Here is one example in hex: 25 17 68 00 / 04 00 00 00 / 41 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isMyHero((int *)iVar65, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089184b4(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; int iVar4; int iVar5; uint uVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); iVar5 = iVar3; if ((iVar4 != 9) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar5 = 0, iVar4 == 3)) { iVar5 = Is_HeroUnit(iVar3); } if ((iVar5 != 0) && (*(char *)(iVar5 + 0xa04) != '\\0')) { uVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x10c))(iVar5); *puVar2 = uVar6 & 0xff; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isplayerequipweaponcategory.html": {
    "href": "isplayerequipweaponcategory.html",
    "title": "isPlayerEquipWeaponCategory",
    "keywords": "isPlayerEquipWeaponCategory Checks if a player equipped specific type of equipment. Code Information Name: isPlayerEquipWeaponCategory Scope: Global PAC Instruction (Binary): 25 16 b9 00 Assembly Address in Memory : 0x89235c8 Parameters (int *)unit_handle (8 bytes) : Unit handle, obtained from e.g. getUnitHandle. (int)equipment_type (8 bytes) : Type of the equipment to check. (int *)result (8 bytes) : Variable to store if the unit has the equipment. 0 if the unit didn't equip it, 1 if the unit equipped the equipment. Example This checks if the player equipped greatshield: 25 16 b9 00 / 04 00 00 00 / 06 00 00 00 / 02 00 00 00 / 1a 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isPlayerEquipWeaponCategory((int *)iVar6, (int)26, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089235c8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0; iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 9)) && (iVar4 = Equip::Item::Has_Equipment_Type(iVar4,*puVar2), iVar4 != 0)) { *puVar3 = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "ispossibleexecheromode.html": {
    "href": "ispossibleexecheromode.html",
    "title": "isPossibleExecHeroMode",
    "keywords": "isPossibleExecHeroMode Checks if a unit is able to perform the heromode or not. Code Information Name: isPossibleExecHeroMode Scope: Global PAC Instruction (Binary): 25 16 f3 00 Assembly Address in Memory : 0x8926eb8 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (bool *)destination (8 bytes) : Variable to store whether the unit can perform heromode or not. 0 can't perform, 1 can perform. Example Here is one example in hex: 25 16 f3 00 / 04 00 00 00 / 2c 00 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: isPossibleExecHeroMode((int *)iVar44, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926eb8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0; iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) && (iVar3 = Is_HeroUnit(iVar3), iVar3 != 0)) { iVar3 = FUN_088f51cc(iVar3 + 0x170); if (iVar3 == 0) { *puVar2 = 0; } else { *puVar2 = 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isreading.html": {
    "href": "isreading.html",
    "title": "isReading",
    "keywords": "isReading Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isReading Scope: Global PAC Instruction (Binary): 25 09 0b 00 Assembly Address in Memory : 0x894900c Parameters (uint)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894900c(undefined4 param_1,undefined4 param_2) { uint *puVar1; int iVar2; uint uVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); iVar2 = FUN_08842ef4(1); uVar3 = DLC::Get_Loading_Status(*(undefined4 *)(iVar2 + 0x28),0); *puVar1 = uVar3 & 0xff; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isregisterskill.html": {
    "href": "isregisterskill.html",
    "title": "isRegisterSkill",
    "keywords": "isRegisterSkill Checks if player squad have specific set skill or class skill. This can be used for loading specific effect. Code Information Name: isRegisterSkill Scope: Global PAC Instruction (Binary): 25 16 2e 00 Assembly Address in Memory : 0x891c5b8 Parameters (int)unit_type (8 bytes) : Type of the unit, 0 for hero. This is usually 0, or sometimes 1. (int)skill_id (8 bytes) : Set skill or Class skill ID to check if the player has the skill. (int *)destination (8 bytes) : Variable to store the result, either 0 (doesn't have) or 1 (do have). Example Here is one example in hex: 25 16 2e 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: isRegisterSkill((int *)iVar1, (int)0, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891c5b8(undefined4 param_1,undefined4 param_2) { char cVar1; short sVar2; int *piVar3; int *piVar4; int *piVar5; undefined4 uVar6; int iVar7; int iVar8; undefined4 uVar9; uint uVar10; int *piVar11; int ******ppppppiVar12; int iVar13; int iVar14; short *psVar15; uint uVar16; int iVar17; uint uVar18; int iVar19; int iVar20; int local_374; int local_370; int *local_354; int *local_350; undefined *local_34c; undefined auStack840 [772]; undefined *local_44; int ******local_40; int ******local_3c; int **local_38; undefined4 local_34; undefined auStack48 [4]; char local_2c; int local_24; piVar3 = (int *)Pac_Get_Param(param_2,0,1,4); piVar4 = (int *)Pac_Get_Param(param_2,1,1,4); piVar5 = (int *)Pac_Get_Param(param_2,2,1,4); *piVar5 = 0; uVar6 = Save::Get_Save_BaseAddr(1); iVar7 = Save::Get_BaseAddr__0x78(uVar6,1); iVar13 = *(int *)(iVar7 + 0x44); cVar1 = *(char *)(iVar13 + 0x24); iVar7 = Get_Some_Flag(1); uVar6 = *(undefined4 *)(iVar7 + 0x34); iVar7 = 0; local_370 = iVar13 + *piVar3 * 0x58a4 + 0x2550; do { if ((3 < iVar7) || (*piVar5 != 0)) { PAC::PAC_setCmdId(param_2,0); return; } iVar20 = local_370 + 4; if (*(int *)(local_370 + 4) != 0) { FUN_08960154(iVar20); iVar19 = 0; local_374 = iVar20 + *(int *)(local_370 + 8) * 0x84 + 0x14; do { iVar14 = local_374 + 0x18; if (*(int *)(local_374 + 0x18) != 0) { uVar18 = 0; do { if (uVar18 < 6) { piVar11 = (int *)(iVar14 + 4); } else { piVar11 = (int *)0x0; } if ((int)*(char *)piVar11 << 0x1f < 0) { iVar8 = *piVar11; iVar17 = -1; if ((cVar1 == '\\0') || (iVar8 >> 1 != -2)) { FUN_08a15694(auStack48); Equipment::Get_Equipment_Name_Save_Validity(auStack48,iVar8 >> 1,uVar6); if (local_2c == '\\0') goto LAB_0891c994; if (-1 < local_24) { iVar17 = local_24; } } else { iVar8 = FUN_089880e8(iVar13 + 0x850,*piVar3,iVar7); if (iVar8 != 0) { psVar15 = (short *)(iVar8 + 0x58 + (iVar19 + uVar18) * 0xc); iVar17 = (int)*psVar15; if (iVar17 < 0) goto LAB_0891c994; uVar9 = Save::Get_Save_BaseAddr(1); iVar8 = Save::Get_BaseAddr__0x78(uVar9,1); uVar9 = Param::Get_Data_Addr(*(undefined4 *)(iVar8 + 0xa4),9); Param::Get_Line_Addr(uVar9,0,iVar17,1); iVar17 = *(int *)(psVar15 + 2); } } if (-1 < iVar17) { uVar9 = FUN_088be6e4(iVar17); local_34c = &DAT_08a84090; local_44 = auStack840; piVar11 = (int *)(*(code *)PTR_FUN_08a84098)(&local_354); local_354 = piVar11; iVar17 = (**(code **)(local_34c + 0xc))(&local_354); local_350 = piVar11 + (iVar17 + -1) * 3; piVar11[1] = (int)&local_354; *local_350 = (int)&local_354; uVar16 = 1; uVar10 = (**(code **)(local_34c + 0xc))(&local_354); if (1 < uVar10) { do { *piVar11 = (int)(piVar11 + 3); piVar11[4] = (int)piVar11; uVar16 = uVar16 + 1; uVar10 = (**(code **)(local_34c + 0xc))(&local_354); piVar11 = piVar11 + 3; } while (uVar16 < uVar10); } local_40 = (int ******)&local_40; local_34 = 0; local_3c = local_40; local_38 = &local_354; SS_Controller::Read_From_SetSkillSlot(&local_354,iVar20,uVar9,1); if ((int *******)local_40 != &local_40) { sVar2 = *(short *)(local_40 + 2); ppppppiVar12 = local_40; while( true ) { if ((int)sVar2 == *piVar4) { *piVar5 = 1; PAC::PAC_setCmdId(param_2,0); FUN_088b6410(&local_40,0); FUN_088df524(&local_354,0); return; } ppppppiVar12 = (int ******)*ppppppiVar12; if ((int *******)ppppppiVar12 == &local_40) break; sVar2 = *(short *)(ppppppiVar12 + 2); } } FUN_088b6410(&local_40,0); FUN_088df524(&local_354,0); } } LAB_0891c994: uVar18 = uVar18 + 1; iVar14 = iVar14 + 4; } while ((int)uVar18 < 6); } iVar19 = iVar19 + 1; local_374 = local_374 + 0x34; } while (iVar19 < 1); } iVar7 = iVar7 + 1; local_370 = local_370 + 0x1620; } while( true ); }"
  },
  "isrhythm.html": {
    "href": "isrhythm.html",
    "title": "isRhythm",
    "keywords": "isRhythm Checks if the player is in the chant turn. Code Information Name: isRhythm Scope: Global PAC Instruction (Binary): 25 0c 05 00 Assembly Address in Memory : 0x8970498 Parameters (int *)chant_turn (8 bytes) : Variable to store the result, 1 if the player is in chant turn, otherwise 0 (including no combo/fever). Example Here is one example in hex: 25 0c 05 00 / 08 00 00 00 / 24 00 00 00 Which is interpreted as: isRhythm(((global)int *)giVar36) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970498(int param_1,undefined4 param_2) { uint *puVar1; int iVar2; int *piVar3; uint uVar4; int iVar5; int local_4; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar5 != 0) { iVar2 = Get_Some_Flag(1); local_4 = *(int *)(*(int *)(iVar2 + 0x44) + 0x28); if (DAT_08a71d54 < local_4) { piVar3 = &local_4; } else { piVar3 = &DAT_08a71d54; } uVar4 = func_0x08b5f7b8(iVar5,*piVar3); *puVar1 = uVar4 & 0xff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "issounddisablerhtymhit.html": {
    "href": "issounddisablerhtymhit.html",
    "title": "isSoundDisableRhtymHit",
    "keywords": "isSoundDisableRhtymHit Reads from system setting if command cancel is disabled. Code Information Name: isSoundDisableRhtymHit Scope: Global PAC Instruction (Binary): 25 0a 26 00 Assembly Address in Memory : 0x894b9a4 Parameters (uint *)disable_commandcancel (8 bytes) : 0 to enable command cancel, 1 to disable command cancel. Example Here is one example in hex: 25 0a 26 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isSoundDisableRhtymHit((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b9a4(undefined4 param_1,undefined4 param_2) { uint *puVar1; int iVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); return__0x1c(*(undefined4 *)(iVar2 + 0x50)); iVar2 = Save::Get_Save_BaseAddr(1); *puVar1 = *(char *)(*(int *)(iVar2 + 0x48) + 0x8ae) != '\\0' ^ 1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "issoundfixbeat.html": {
    "href": "issoundfixbeat.html",
    "title": "isSoundFixBeat",
    "keywords": "isSoundFixBeat Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isSoundFixBeat Scope: Global PAC Instruction (Binary): 25 0a 27 00 Assembly Address in Memory : 0x894ba20 Parameters (uint)Var0 (8 bytes) Example Here is one example in hex: 25 0a 27 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: isSoundFixBeat((int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894ba20(undefined4 param_1,undefined4 param_2) { uint *puVar1; int iVar2; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = return__0x1c(*(undefined4 *)(iVar2 + 0x50)); *puVar1 = (uint)(*(char *)(iVar2 + 0xedac) != '\\0'); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isstartbattle.html": {
    "href": "isstartbattle.html",
    "title": "isStartBattle",
    "keywords": "isStartBattle Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isStartBattle Scope: Global PAC Instruction (Binary): 25 16 6d 00 Assembly Address in Memory : 0x892078c Parameters (uint)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892078c(int param_1,undefined4 param_2) { uint *puVar1; int iVar2; uint uVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); *puVar1 = 0; iVar2 = *(int *)(param_1 + 0x10); if (iVar2 != 0) { if (*(char *)(iVar2 + 0x4a) == '\\0') { uVar3 = 0; } else { uVar3 = *(char *)(iVar2 + 0x40) != '\\0' ^ 1; } *puVar1 = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "issummonmode.html": {
    "href": "issummonmode.html",
    "title": "isSummonMode",
    "keywords": "isSummonMode Checks whose summon is going on in whose side. Code Information Name: isSummonMode Scope: Global PAC Instruction (Binary): 25 0c 17 00 Assembly Address in Memory : 0x8970e20 Parameters (int)team (8 bytes) : 0 is blue team, 1 is red team. (int *)destination (8 bytes) : Variable to store the result. 0 is no summon, 1 is own summon for the team, 2 is enemy summon for the team Example Here is one example in hex: 25 0c 17 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isSummonMode((int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970e20(int param_1,undefined4 param_2) { bool bVar1; int *piVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); *puVar3 = 0; if (iVar5 != 0) { bVar1 = false; if ((*piVar2 == 1) && (*(int *)(iVar5 + 0x3eb4) != 0)) { bVar1 = true; } if (*(char *)(*piVar2 + iVar5 + 0x3f06) == '\\0') { if (bVar1) { uVar4 = 2; } else { uVar4 = 0; } } else { uVar4 = 1; } *puVar3 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isupdateversus04panelswap.html": {
    "href": "isupdateversus04panelswap.html",
    "title": "isUpdateVersus04PanelSwap",
    "keywords": "isUpdateVersus04PanelSwap Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isUpdateVersus04PanelSwap Scope: Global PAC Instruction (Binary): 25 16 ff 00 Assembly Address in Memory : 0x8925034 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925034(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar2 != 0) && (iVar2 = *(int *)(iVar2 + 0x68), iVar2 != 0)) { if (*(char *)(iVar2 + 0xa8) == '\\0') { *puVar1 = 0; } else { *puVar1 = 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isupdateversusgoal.html": {
    "href": "isupdateversusgoal.html",
    "title": "isUpdateVersusGoal",
    "keywords": "isUpdateVersusGoal Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isUpdateVersusGoal Scope: Global PAC Instruction (Binary): 25 16 c3 00 Assembly Address in Memory : 0x89240a4 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 c3 00 / 08 00 00 00 / 9b 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isUpdateVersusGoal(((global)int *)giVar155, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089240a4(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2d8) + 0x58) + 0x10); if (*piVar1 == iVar3) { *piVar2 = 0; } else { *piVar2 = iVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "isvisibleversusstring.html": {
    "href": "isvisibleversusstring.html",
    "title": "isVisibleVersusString",
    "keywords": "isVisibleVersusString Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: isVisibleVersusString Scope: Global PAC Instruction (Binary): 25 16 f8 00 Assembly Address in Memory : 0x8927684 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (uint)Var2 (8 bytes) Example Here is one example in hex: 25 16 f8 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: isVisibleVersusString((int)2, (int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927684(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; uint *puVar3; int iVar4; undefined4 uVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); uVar5 = *(undefined4 *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x68); *puVar3 = 0; if (*piVar1 == 2) { iVar4 = func_0x08b36458(uVar5); } else if (*piVar1 == 1) { iVar4 = func_0x08b36460(uVar5,*puVar2); } else { iVar4 = func_0x08b36450(); } if (iVar4 != 0) { *puVar3 = (uint)*(byte *)(iVar4 + 4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "itemtableallclear.html": {
    "href": "itemtableallclear.html",
    "title": "itemTableAllClear",
    "keywords": "itemTableAllClear Resets the item table. Called before settling loot from the chest. Code Information Name: itemTableAllClear Scope: Global PAC Instruction (Binary): 25 08 07 00 Assembly Address in Memory : 0x896ee64 Parameters This function is parameterless. Example Here is one example in hex: 25 08 07 00 Which is interpreted as: itemTableAllClear() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896ee64(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(param_1 + 0x10); if (iVar1 == 0) { iVar1 = 0; } else { if (iVar1 == 0) { iVar1 = 0; } iVar1 = *(int *)(iVar1 + 0x188); if (iVar1 == 0) { iVar1 = 0; } } if (iVar1 != 0) { FUN_089517d0(iVar1 + 0xf7c4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "keyclosemessagewindow.html": {
    "href": "keyclosemessagewindow.html",
    "title": "keyCloseMessageWindow",
    "keywords": "keyCloseMessageWindow Adds \"X\" button to the message. See also How To: Set Speech Bubble This pauses pac instruction execution until the speech bubble is closed. Code Information Name: keyCloseMessageWindow Scope: Global PAC Instruction (Binary): 25 17 2f 00 Assembly Address in Memory : 0x8913d68 Parameters (int *)speech_bubble_id (8 bytes) : Speech Bubble window ID, obtained from callMessageWindow 2nd parameter. (Undefined)Var1 (8 bytes) : It is 9 in examples, however, this is not used. (int)close_button_Id (8 bytes) : Input Button ID to close the window. Keep 0x4000 to close with X button. (int)close_button_Id2 (8 bytes) : The other Input Button ID to close the window. Keep 0x0 to not assign them. Example Here is one example in hex: 25 17 2f 00 / 08 00 00 00 / 5b 00 00 00 / 02 00 00 00 / 09 00 00 00 / 02 00 00 00 / 00 40 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: keyCloseMessageWindow(((global)int *)giVar91, (int)9, (int)0x4000, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913d68(int param_1,undefined4 param_2) { int iVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 uVar5; iVar1 = Get_Execution_Pause_Phase(param_2); if (iVar1 == 0) { piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (*piVar2 == -1) { PAC::PAC_setCmdId(param_2,0); } else { iVar1 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar2,1); if (iVar1 == 0) { iVar1 = 0; } *(int *)(param_1 + 0x10) = iVar1; *(undefined4 *)(param_1 + 0x18) = 0; *(undefined4 *)(param_1 + 0x1c) = *puVar3; *(undefined4 *)(param_1 + 0x20) = *puVar4; if (*(int *)(param_1 + 0x18) == 0) { Pause_Execution(param_2,3); } else { *(undefined *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0xe8) + 4) + 0x2f0) = 0; Pause_Execution(param_2,1); } } } else if ((*(int *)(param_1 + 0x10) == 0) || (*(int *)(*(int *)(param_1 + 0x10) + 0xe8) == 0)) { PAC::PAC_setCmdId(param_2,0); } else { iVar1 = FUN_08851bec(1); uVar5 = *(undefined4 *)(iVar1 + 0x10c); iVar1 = Get_Execution_Pause_Phase(param_2); if (iVar1 == 1) { iVar1 = Input::Has_Input(uVar5,*(uint *)(param_1 + 0x1c) | *(uint *)(param_1 + 0x20)); if (iVar1 == 0) { iVar1 = *(int *)(param_1 + 0x18); } else { (**(code **)(*(int *)(*(int *)(param_1 + 0x10) + 4) + 0xf4))(); iVar1 = *(int *)(param_1 + 0x18); } if (iVar1 != 0) { *(int *)(param_1 + 0x18) = iVar1 + -1; return; } *(undefined *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0xe8) + 4) + 0x2f0) = 1; Pause_Execution(param_2,3); } iVar1 = Get_Execution_Pause_Phase(param_2); if (iVar1 == 2) { if (*(int *)(param_1 + 0x18) != 0) { *(int *)(param_1 + 0x18) = *(int *)(param_1 + 0x18) + -1; return; } Pause_Execution(param_2,3); } iVar1 = Get_Execution_Pause_Phase(param_2); if (iVar1 == 3) { iVar1 = FUN_08877b6c(1); iVar1 = FUN_08836f88(iVar1 + 0x10); if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x75) << 0x1d) < 0) { return; } iVar1 = FUN_08852c04(uVar5,*(uint *)(param_1 + 0x1c) | *(uint *)(param_1 + 0x20)); if (iVar1 == 0) { return; } iVar1 = (**(code **)(**(int **)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0xe8) + 4) + 0x150) + 0x74))(); if (iVar1 == 0) { (**(code **)(*(int *)(*(int *)(param_1 + 0x10) + 4) + 0xf4))(); return; } iVar1 = FUN_088e6a34(1); Sound::Play_Sound(0,0x3f800000,0,0,0,0x3f800000,0,iVar1 + 0x60,0x900002); iVar1 = *(int *)(param_1 + 0x10); } else { iVar1 = *(int *)(param_1 + 0x10); } (**(code **)(*(int *)(iVar1 + 4) + 0xf0))(); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "kill.html": {
    "href": "kill.html",
    "title": "kill",
    "keywords": "kill Kills an unit (instadeath). Used for e.g. killing bonedeths after the structure is destroyed. Code Information Name: kill Scope: Global PAC Instruction (Binary): 25 17 26 00 Assembly Address in Memory : 0x8913334 Parameters (int *)handle_id (8 bytes) : Unit or squad handle, obtained from e.g. getUnitHandle or getUnitSquadHandle. (float)delay (8 bytes) : Delay before dying, as seconds. (float)Var2 (8 bytes) : Can keep as 0. Example Here is one example in hex: 25 17 26 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: kill((int *)iVar0, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913334(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { (**(code **)(*(int *)(iVar4 + 4) + 0x88))(*puVar2,*puVar3,iVar4); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "killchildren.html": {
    "href": "killchildren.html",
    "title": "killChildren",
    "keywords": "killChildren Kill all scripts created by createScript. Code Information Name: killChildren Scope: Global PAC Instruction (Binary): 25 10 0c 00 Assembly Address in Memory : 0x890a3bc Parameters This function is parameterless. Example Here is one example in hex: 25 10 0c 00 Which is interpreted as: killChildren() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a3bc(int param_1,undefined4 param_2) { int *piVar1; piVar1 = *(int **)(*(int *)(param_1 + 0x10) + 0x4dc); if (piVar1 != (int *)0x0) { (**(code **)(*piVar1 + 0x18))(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "killgeneratorgroup.html": {
    "href": "killgeneratorgroup.html",
    "title": "killGeneratorGroup",
    "keywords": "killGeneratorGroup Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: killGeneratorGroup Scope: Global PAC Instruction (Binary): 25 19 17 00 Assembly Address in Memory : 0x89424f4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (int)Var3 (8 bytes) Example Here is one example in hex: 25 19 17 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 02 00 00 00 / 01 00 00 00 Which is interpreted as: killGeneratorGroup((int *)iVar0, (float)0, (float)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089424f4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; int iVar5; int iVar6; int iVar7; int iVar8; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar5 == 0) { iVar5 = 0; } else if (iVar5 == 0) { iVar5 = 0; } else { (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); } iVar6 = *piVar4; if (iVar5 != 0) { iVar7 = 0; iVar8 = *(uint *)(iVar5 + 0x194) - (*(uint *)(iVar5 + 0x194) / 100000) % 10; iVar5 = *(int *)(param_1 + 0x10); while( true ) { iVar5 = Get_Gimmick(*(undefined4 *)(iVar5 + 0x108),iVar8); if (iVar5 != 0) { if (iVar6 == 0) { (**(code **)(*(int *)(iVar5 + 4) + 0x88))(*puVar2,*puVar3,iVar5); } else { (**(code **)(*(int *)(iVar5 + 4) + 0x8c))(*puVar2,*puVar3,iVar5); } } iVar7 = iVar7 + 1; iVar8 = iVar8 + 100000; if (7 < iVar7) break; iVar5 = *(int *)(param_1 + 0x10); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "killgroup.html": {
    "href": "killgroup.html",
    "title": "killGroup",
    "keywords": "killGroup Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: killGroup Scope: Global PAC Instruction (Binary): 25 17 27 00 Assembly Address in Memory : 0x8913414 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913414(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); FUN_0887c108(*puVar2,*puVar3,*(undefined4 *)(param_1 + 0x14),*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "killscript.html": {
    "href": "killscript.html",
    "title": "killScript",
    "keywords": "killScript Stop executing (killing) the script, created from createScript. Code Information Name: killScript Scope: Global PAC Instruction (Binary): 25 10 0d 00 Assembly Address in Memory : 0x890a408 Parameters (int)script_id (8 bytes) : Script ID, set from createScript. Example Here is one example in hex: 25 10 0d 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: killScript((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a408(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = *(int **)(*(int *)(param_1 + 0x10) + 0x4dc); if (piVar2 != (int *)0x0) { (**(code **)(*piVar2 + 0x1c))(piVar2,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "labeltoint.html": {
    "href": "labeltoint.html",
    "title": "labelToInt",
    "keywords": "labelToInt Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: labelToInt Scope: Global PAC Instruction (Binary): 25 10 07 00 Assembly Address in Memory : 0x8909fc4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (4 bytes) Example Here is one example in hex: 25 10 07 00 / 04 00 00 00 / 01 00 00 00 / 1c c9 05 00 Which is interpreted as: labelToInt((int *)iVar1, 0x5c91c) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08909fc4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,0,4); if (*(int *)(param_1 + 0x10) != 0) { *puVar1 = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "loadactorinfo.html": {
    "href": "loadactorinfo.html",
    "title": "loadActorInfo",
    "keywords": "loadActorInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: loadActorInfo Scope: Azito PAC Instruction (Binary): 25 1c 20 00 Assembly Address in Memory : 0x8b4f988 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f988(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar5 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar2; iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = iVar5 * 0x18 + *(int *)(iVar3 + 0x50) + 0x297e0; if ((iVar3 != 0) && (iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x174) + 0xe8),uVar4, 1), iVar5 != 0)) { FUN_Azito__08b4cf28(iVar3,iVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "loadfacilityinfo.html": {
    "href": "loadfacilityinfo.html",
    "title": "loadFacilityInfo",
    "keywords": "loadFacilityInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: loadFacilityInfo Scope: Azito PAC Instruction (Binary): 25 1c 22 00 Assembly Address in Memory : 0x8b4fb60 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fb60(int param_1,undefined4 param_2) { int iVar1; int iVar2; int iVar3; int iVar4; int iVar5; iVar1 = Save::Get_Save_BaseAddr(1); iVar1 = *(int *)(iVar1 + 0x50); iVar5 = iVar1 + 0x285a8; iVar4 = 0; iVar2 = 0; do { iVar3 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + iVar2 + 0x1e0); if ((iVar3 != 0) && (*(int *)(iVar3 + 0x148) != 0)) { FUN_Azito__08b4cf28(iVar5 + 0x1418); *(bool *)(iVar3 + 0x141) = *(char *)(iVar5 + 0x141d) != '\\0'; *(bool *)(iVar3 + 0x142) = *(char *)(iVar5 + 0x141e) != '\\0'; if (*(int *)(iVar1 + 0x29af8) == iVar4) { Azito::Select_Facility(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x1c4),iVar3); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x1b4); if (iVar3 != 0) { FUN_Azito__08acdfa0(iVar3,iVar5 + 0x1428); } } } iVar4 = iVar4 + 1; iVar2 = iVar2 + 0x10; iVar5 = iVar5 + 0x18; } while (iVar4 < 0xd); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "loadflag.html": {
    "href": "loadflag.html",
    "title": "loadFlag",
    "keywords": "loadFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: loadFlag Scope: Global PAC Instruction (Binary): 25 0a 31 00 Assembly Address in Memory : 0x894bfc4 Parameters This function is parameterless. Example Here is one example in hex: 25 0a 31 00 Which is interpreted as: loadFlag() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bfc4(undefined4 param_1,undefined4 param_2) { int iVar1; int iVar2; undefined4 uVar3; undefined4 uVar4; iVar1 = FUN_08877b6c(1); iVar1 = FUN_08836f88(iVar1 + 0x10); iVar2 = FUN_08877b6c(1); uVar3 = FUN_08836f90(iVar2 + 0x10); iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = *(int *)(iVar2 + 0x50); if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cd) << 0x1a) < 0) { *(byte *)(iVar2 + 0x2b1d5) = *(byte *)(iVar2 + 0x2b1d5) | 0x20; } else { *(byte *)(iVar2 + 0x2b1d5) = *(byte *)(iVar2 + 0x2b1d5) & 0xdf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cd) << 0x19) < 0) { *(byte *)(iVar2 + 0x2b1d5) = *(byte *)(iVar2 + 0x2b1d5) | 0x40; } else { *(byte *)(iVar2 + 0x2b1d5) = *(byte *)(iVar2 + 0x2b1d5) & 0xbf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cd) << 0x18) < 0) { *(byte *)(iVar2 + 0x2b1d5) = *(byte *)(iVar2 + 0x2b1d5) | 0x80; } else { *(byte *)(iVar2 + 0x2b1d5) = *(byte *)(iVar2 + 0x2b1d5) & 0x7f; } if ((*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) & 1) == 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xfe; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 1; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x1e) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 2; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xfd; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x1d) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 4; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xfb; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x1c) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 8; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xf7; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x1b) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 0x10; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xef; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x1a) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 0x20; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xdf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x19) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 0x40; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0xbf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1ce) << 0x18) < 0) { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) | 0x80; } else { *(byte *)(iVar2 + 0x2b1d6) = *(byte *)(iVar2 + 0x2b1d6) & 0x7f; } if ((*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) & 1) == 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xfe; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 1; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x1e) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 2; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xfd; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x1d) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 4; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xfb; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x1c) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 8; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xf7; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x1b) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 0x10; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xef; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x1a) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 0x20; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xdf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x19) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 0x40; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0xbf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1cf) << 0x18) < 0) { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) | 0x80; } else { *(byte *)(iVar2 + 0x2b1d7) = *(byte *)(iVar2 + 0x2b1d7) & 0x7f; } if ((*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) & 1) == 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xfe; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 1; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x1e) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 2; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xfd; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x1d) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 4; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xfb; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x1c) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 8; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xf7; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x1b) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 0x10; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xef; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x1a) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 0x20; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xdf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x19) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 0x40; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0xbf; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d0) << 0x18) < 0) { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) | 0x80; } else { *(byte *)(iVar2 + 0x2b1d8) = *(byte *)(iVar2 + 0x2b1d8) & 0x7f; } if ((*(byte *)(*(int *)(iVar1 + 4) + 0x1d1) & 1) == 0) { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) & 0xfe; } else { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) | 1; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d1) << 0x1e) < 0) { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) | 2; } else { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) & 0xfd; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d1) << 0x1d) < 0) { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) | 4; } else { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) & 0xfb; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d1) << 0x1c) < 0) { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) | 8; } else { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) & 0xf7; } if ((int)((uint)*(byte *)(*(int *)(iVar1 + 4) + 0x1d1) << 0x1b) < 0) { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) | 0x10; } else { *(byte *)(iVar2 + 0x2b1d9) = *(byte *)(iVar2 + 0x2b1d9) & 0xef; } uVar4 = Get_Certain_Stored_Value(uVar3,0x3b); *(undefined4 *)(iVar2 + 0x2a0f4) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x3c); *(undefined4 *)(iVar2 + 0x2a0f8) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x3d); *(undefined4 *)(iVar2 + 0x2a0fc) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x3e); *(undefined4 *)(iVar2 + 0x2a100) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x3f); *(undefined4 *)(iVar2 + 0x2a104) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x40); *(undefined4 *)(iVar2 + 0x2a108) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x42); *(undefined4 *)(iVar2 + 0x2a110) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x43); *(undefined4 *)(iVar2 + 0x2a114) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x44); *(undefined4 *)(iVar2 + 0x2a118) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xc2); *(undefined4 *)(iVar2 + 0x2a310) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xfa); *(undefined4 *)(iVar2 + 0x2a3f0) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xfb); *(undefined4 *)(iVar2 + 0x2a3f4) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xfc); *(undefined4 *)(iVar2 + 0x2a3f8) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xfd); *(undefined4 *)(iVar2 + 0x2a3fc) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xfe); *(undefined4 *)(iVar2 + 0x2a400) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0xff); *(undefined4 *)(iVar2 + 0x2a404) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x100); *(undefined4 *)(iVar2 + 0x2a408) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x101); *(undefined4 *)(iVar2 + 0x2a40c) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x102); *(undefined4 *)(iVar2 + 0x2a410) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x103); *(undefined4 *)(iVar2 + 0x2a414) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x104); *(undefined4 *)(iVar2 + 0x2a418) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x105); *(undefined4 *)(iVar2 + 0x2a41c) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x106); *(undefined4 *)(iVar2 + 0x2a420) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x107); *(undefined4 *)(iVar2 + 0x2a424) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x108); *(undefined4 *)(iVar2 + 0x2a428) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x109); *(undefined4 *)(iVar2 + 0x2a42c) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x10a); *(undefined4 *)(iVar2 + 0x2a430) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x10b); *(undefined4 *)(iVar2 + 0x2a434) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x10c); *(undefined4 *)(iVar2 + 0x2a438) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x10d); *(undefined4 *)(iVar2 + 0x2a43c) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x10e); *(undefined4 *)(iVar2 + 0x2a440) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x10f); *(undefined4 *)(iVar2 + 0x2a444) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x110); *(undefined4 *)(iVar2 + 0x2a448) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x111); *(undefined4 *)(iVar2 + 0x2a44c) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x112); *(undefined4 *)(iVar2 + 0x2a450) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x113); *(undefined4 *)(iVar2 + 0x2a454) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1a7); *(undefined4 *)(iVar2 + 0x2a6a4) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1a8); *(undefined4 *)(iVar2 + 0x2a6a8) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1a9); *(undefined4 *)(iVar2 + 0x2a6ac) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1aa); *(undefined4 *)(iVar2 + 0x2a6b0) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1ab); *(undefined4 *)(iVar2 + 0x2a6b4) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1ac); *(undefined4 *)(iVar2 + 0x2a6b8) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1ad); *(undefined4 *)(iVar2 + 0x2a6bc) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1ae); *(undefined4 *)(iVar2 + 0x2a6c0) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1af); *(undefined4 *)(iVar2 + 0x2a6c4) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1b0); *(undefined4 *)(iVar2 + 0x2a6c8) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1b1); *(undefined4 *)(iVar2 + 0x2a6cc) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1b2); *(undefined4 *)(iVar2 + 0x2a6d0) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1b3); *(undefined4 *)(iVar2 + 0x2a6d4) = uVar4; uVar4 = Get_Certain_Stored_Value(uVar3,0x1b4); *(undefined4 *)(iVar2 + 0x2a6d8) = uVar4; uVar4 = FUN_0883752c(uVar3,0x96); *(undefined4 *)(iVar2 + 0x2aa60) = uVar4; uVar4 = FUN_0883752c(uVar3,0x97); *(undefined4 *)(iVar2 + 0x2aa64) = uVar4; uVar4 = FUN_0883752c(uVar3,0x98); *(undefined4 *)(iVar2 + 0x2aa68) = uVar4; uVar4 = FUN_0883752c(uVar3,0x99); *(undefined4 *)(iVar2 + 0x2aa6c) = uVar4; uVar4 = FUN_0883752c(uVar3,0x9a); *(undefined4 *)(iVar2 + 0x2aa70) = uVar4; uVar4 = FUN_0883752c(uVar3,0x9b); *(undefined4 *)(iVar2 + 0x2aa74) = uVar4; uVar4 = FUN_0883752c(uVar3,0x9c); *(undefined4 *)(iVar2 + 0x2aa78) = uVar4; uVar4 = FUN_0883752c(uVar3,0x9d); *(undefined4 *)(iVar2 + 0x2aa7c) = uVar4; uVar4 = FUN_0883752c(uVar3,0x9e); *(undefined4 *)(iVar2 + 0x2aa80) = uVar4; uVar3 = FUN_0883752c(uVar3,0x9f); *(undefined4 *)(iVar2 + 0x2aa84) = uVar3; uVar3 = FUN_08877b6c(1); FUN_08877d10(uVar3,2000); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "loadquestcompletecounter.html": {
    "href": "loadquestcompletecounter.html",
    "title": "loadQuestCompleteCounter",
    "keywords": "loadQuestCompleteCounter Reads quest complement counter address, but this does nothing. Use incQuestComplementCounter to increase quest complement counter. This is functionally identical to saveQuestCompleteCounter. Code Information Name: loadQuestCompleteCounter Scope: Global PAC Instruction (Binary): 25 0a 3a 00 Assembly Address in Memory : 0x894ce64 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894ce64(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Save::Get_Save_BaseAddr(1); return__0x1c(*(undefined4 *)(iVar1 + 0x50)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "loadversusdisplaycommon.html": {
    "href": "loadversusdisplaycommon.html",
    "title": "loadVersusDisplayCommon",
    "keywords": "loadVersusDisplayCommon Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: loadVersusDisplayCommon Scope: Global PAC Instruction (Binary): 25 16 0d 01 Assembly Address in Memory : 0x8928b94 Parameters This function is parameterless. Example Here is one example in hex: 25 16 0d 01 Which is interpreted as: loadVersusDisplayCommon() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928b94(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4, undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8) { undefined4 uVar1; int iVar2; int iVar3; undefined4 uVar4; undefined4 filepath; int iVar5; char acStack256 [64]; char acStack192 [64]; char acStack128 [64]; char acStack64 [64]; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar2 = Is_Multi(*(undefined4 *)(iVar2 + 100)); if (iVar2 == 0) { uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); uVar1 = Param::Get_Data_Addr(*(undefined4 *)(iVar2 + 0xa4),1); uVar4 = 1; Param::Get_Line_Addr(uVar1,1,0); Data::Load_from_path (acStack64,s_Actor_VSRadar__s_bnd_08a5fd9c,s_radar_53_08a5fdb4,uVar4,param_5,param_6, param_7,param_8); uVar1 = FUN_08883830(acStack64); iVar2 = FUN_08843148(acStack64,uVar1); if (iVar2 == 0) { uVar1 = FUN_0884a440(1); uVar4 = 2; param_5 = 0; param_6 = 0; param_7 = 0; param_8 = 0; Data::Load_File_From_Bnd(uVar1,acStack64,FUN_08882250,2,0,0,0,0,0,0); } Data::Load_from_path (acStack128,s_Actor_VSRadar__s_bnd_08a5fd9c,s_radar_54_08a5fdc0,uVar4,param_5,param_6, param_7,param_8); uVar1 = FUN_08883830(acStack128); iVar2 = FUN_08843148(acStack128,uVar1); if (iVar2 == 0) { uVar1 = FUN_0884a440(1); param_5 = 0; param_6 = 0; param_7 = 0; param_8 = 0; Data::Load_File_From_Bnd(uVar1,acStack128,FUN_08882250,2,0,0,0,0,0,0); } iVar2 = Get_Some_Flag(1); iVar5 = 1; iVar2 = *(int *)(iVar2 + 0x44) + 0x3b70; do { iVar3 = iVar2 + 4 + *(int *)(iVar2 + 8) * 0x84; uVar1 = Param::Get_Charaparam_Id (*(int *)(iVar2 + 8),*(int *)(iVar2 + 0x10) == 0, *(undefined4 *)(iVar3 + 0x28)); uVar1 = FUN_0895e9b8(uVar1,*(undefined4 *)(iVar3 + 0x24)); uVar4 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar4,1); uVar4 = Param::Get_Data_Addr(*(undefined4 *)(iVar3 + 0xa4),1); filepath = 1; iVar3 = Param::Get_Line_Addr(uVar4,1,uVar1); Data::Load_from_path (acStack192,s_Actor_VSRadar__s_bnd_08a5fd9c,iVar3 + 0xb0,filepath,param_5,param_6, param_7,param_8); uVar1 = FUN_08883830(acStack192); iVar3 = FUN_08843148(acStack192,uVar1); if (iVar3 == 0) { uVar1 = FUN_0884a440(1); param_5 = 0; param_6 = 0; param_7 = 0; param_8 = 0; Data::Load_File_From_Bnd(uVar1,acStack192,FUN_08882250,2,0,0,0,0,0,0); } iVar5 = iVar5 + 1; iVar2 = iVar2 + 0x1620; } while (iVar5 < 4); iVar2 = *(int *)(param_1 + 0x10); } else { FUN_0884a440(1); uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); if (*(char *)(*(int *)(iVar2 + 0x44) + 0x81c) == '\\0') { Data::Load_from_path (acStack256,s_Actor_VSRadar__s_bnd_08a5fd9c,s_radar_54_08a5fdc0,param_4,param_5, param_6,param_7,param_8); uVar1 = FUN_08883830(acStack256); iVar2 = FUN_08843148(acStack256,uVar1); if (iVar2 == 0) { uVar1 = FUN_0884a440(1); Data::Load_File_From_Bnd(uVar1,acStack256,FUN_08882250,2,0,0,0,0,0,0); } } iVar2 = *(int *)(param_1 + 0x10); } if (iVar2 != 0) { *(undefined *)(iVar2 + 0x50) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "locknotifyerror.html": {
    "href": "locknotifyerror.html",
    "title": "lockNotifyError",
    "keywords": "lockNotifyError Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: lockNotifyError Scope: Global PAC Instruction (Binary): 25 16 1f 01 Assembly Address in Memory : 0x892a200 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 1f 01 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: lockNotifyError((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a200(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); uVar2 = Debug::Get_Log_Setting(1); FUN_08957d68(uVar2,*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "makegamecompletesavedata.html": {
    "href": "makegamecompletesavedata.html",
    "title": "makeGameCompleteSaveData",
    "keywords": "makeGameCompleteSaveData Marks game save data complete for debugging purpose. This only allows to make the dark hero with the save. Code Information Name: makeGameCompleteSaveData Scope: Azito PAC Instruction (Binary): 25 1c 30 00 Assembly Address in Memory : 0x8b50248 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 30 00 Which is interpreted as: makeGameCompleteSaveData() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b50248(int param_1,undefined4 param_2) { short sVar1; int iVar2; int iVar3; undefined4 uVar4; undefined auStack48 [16]; undefined auStack32 [16]; undefined4 local_10; int *local_c; int local_8; short *local_4; if (*(int *)(param_1 + 0x10) == 0) { PAC::PAC_setCmdId(param_2,0); } else { if (DAT_08bc63d8 == '\\0') { _DAT_08bc63f0 = 0; _DAT_08bc63f4 = 0; _DAT_08bc63f8 = 0; _DAT_08bc63fc = 0; FUN_088044cc(&DAT_08bc63f0,FUN_Azito__08abb590,0x8bc63e0); DAT_08bc63d8 = '\\x01'; } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 3) { uVar4 = *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x204); iVar2 = FUN_Azito__08b51148(uVar4); if ((iVar2 == 4) || (iVar2 = FUN_Azito__08b51148(uVar4), iVar2 == 2)) { PAC::PAC_setCmdId(param_2,0); } } else if (iVar2 == 2) { iVar2 = FUN_08877b6c(1); iVar2 = FUN_08836f88(iVar2 + 0x10); *(byte *)(*(int *)(iVar2 + 4) + 0x75) = *(byte *)(*(int *)(iVar2 + 4) + 0x75) | 0x40; uVar4 = *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x204); FUN_Azito__08b50db0(uVar4,1); FUN_Azito__08b51158(uVar4,1); Pause_Execution(param_2,3); } else if (iVar2 == 1) { iVar2 = *(int *)(param_1 + 0x10); iVar3 = FUN_08a2182c(*(undefined4 *)(iVar2 + 0x224)); if (iVar3 == 0) { FUN_Azito__08b504e0(auStack48); FUN_Azito__08b504f8(auStack48,iVar2 + 0x21c); FUN_Azito__08abb590(auStack48,0xffffffff); Pause_Execution(param_2,2); } } else if (iVar2 == 0) { iVar2 = *(int *)(param_1 + 0x10); uVar4 = Save::Get_Save_BaseAddr(); FUN_088505c4(&local_10,uVar4,0); FUN_Azito__08b50540(auStack32,&local_10); FUN_Azito__08b504f8(auStack32,iVar2 + 0x21c); FUN_Azito__08abb590(auStack32,0xffffffff); if (local_8 != 0) { *local_4 = *local_4 + -1; if (local_4 == (short *)0x0) { sVar1 = 0; } else { sVar1 = *local_4; } if (sVar1 == 0) { (**(code **)(*local_c + 0xc))(local_c,local_8,local_4,local_10); FUN_Azito__08abead0(local_8,local_10); } } iVar3 = Save::Get_Save_BaseAddr(1); *(undefined4 *)(*(int *)(iVar3 + 0x48) + 0xc9c) = 1; FUN_08a216b0(*(undefined4 *)(iVar2 + 0x224),3,0); Pause_Execution(param_2,1); } } return; }"
  },
  "mastergatenextstate.html": {
    "href": "mastergatenextstate.html",
    "title": "masterGateNextState",
    "keywords": "masterGateNextState Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: masterGateNextState Scope: Azito PAC Instruction (Binary): 25 1c 23 00 Assembly Address in Memory : 0x8b4fc80 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 23 00 Which is interpreted as: masterGateNextState() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fc80(int param_1,undefined4 param_2) { int iVar1; if ((*(int *)(param_1 + 0x10) != 0) && (iVar1 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0xcdbc), iVar1 != 0)) { *(undefined *)(iVar1 + 0x151) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "messageclose.html": {
    "href": "messageclose.html",
    "title": "messageClose",
    "keywords": "messageClose Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: messageClose Scope: Global PAC Instruction (Binary): 25 03 06 00 Assembly Address in Memory : 0x892c5f4 Parameters This function is parameterless. Example Here is one example in hex: 25 03 06 00 Which is interpreted as: messageClose() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892c5f4(int param_1,undefined4 param_2) { undefined4 uVar1; if (*(int *)(param_1 + 0x28) != 0) { uVar1 = FUN_0893d4e8(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x24) + 0x28) + 0x20)); *(undefined4 *)(param_1 + 0x28) = uVar1; *(undefined4 *)(param_1 + 0x2c) = 0; } *(undefined4 *)(param_1 + 0x23c) = 0xff000000; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "moveposition.html": {
    "href": "moveposition.html",
    "title": "movePosition",
    "keywords": "movePosition Moves a target by given handle. The moving stops when the model/motion is changed. Code Information Name: movePosition Scope: Global PAC Instruction (Binary): 25 17 3c 00 Assembly Address in Memory : 0x8914f6c Parameters (int *)handle_id (8 bytes) : ID of the handle. (float)x_position (8 bytes) : X position to move. (float)y_position (8 bytes) : Y position to move. (float)delay (8 bytes) : Delay before moving. (float)speed (8 bytes) : Speed to move. 0 moves the target immediately. The bigger the value is, the faster the target moves. (bool)Var5 (8 bytes) : Please describe, can be related to the subtle animation adjustment. Example Here is one example in hex: 25 17 3c 00 / 04 00 00 00 / 40 00 00 00 / 20 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 40 40 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: movePosition((int *)iVar64, (float *)fVar1, (float)0, (float)0, (float)3, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914f6c(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int *piVar6; int iVar7; undefined *puVar8; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); if (*piVar1 != -1) { iVar7 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar7 == 0) { iVar7 = 0; } if (((iVar7 != 0) && (*(int *)(iVar7 + 200) != 0)) && (puVar8 = *(undefined **)(*(int *)(iVar7 + 200) + 0x1ec), puVar8 != (undefined *)0x0)) { *puVar8 = 1; FUN_089846d0(puVar8); FUN_089841f4(*puVar5,0x3f000000,0x3f000000,puVar8); local_8 = *puVar3; local_c = *puVar2; local_4 = 0; FUN_089840dc(*puVar4,puVar8,&local_c,*piVar6 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_battlegoahead.html": {
    "href": "multi_battlegoahead.html",
    "title": "multi_battleGoAHead",
    "keywords": "multi_battleGoAHead Performs countdown before the battle. This can be called without countdown. Code Information Name: multi_battleGoAHead Scope: Global PAC Instruction (Binary): 25 16 b6 00 Assembly Address in Memory : 0x891b06c Parameters This function is parameterless. Remarks If the Mission is with pons, or if the countdown is once performed, this is called but doesn't do any countdown. To make countdown possible, call startIntroEvent first and call this. Example Here is one example in hex: 25 16 b6 00 Which is interpreted as: multi_battleGoAHead() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b06c(int param_1,undefined4 param_2) { bool bVar1; char cVar2; undefined4 uVar3; int iVar4; int iVar5; uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); uVar3 = *(undefined4 *)(iVar4 + 100); iVar5 = *(int *)(param_1 + 0x10); iVar4 = *(int *)(*(int *)(iVar5 + 0x2b8) + 0x5c); if ((iVar4 == 0) || (*(char *)(iVar4 + 0x23) == '\\0')) { if (iVar5 == 0) { iVar5 = 0; } *(undefined *)(iVar5 + 0x51) = 1; PAC::PAC_setCmdId(param_2,0); } else { iVar4 = Is_Multi(uVar3); if (iVar4 == 0) { cVar2 = '\\0'; } else { cVar2 = FUN_08986d3c(uVar3); } if (cVar2 != '\\0') { uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); bVar1 = *(char *)(*(int *)(iVar4 + 0x94) + 0x3d8) != '\\0'; if (bVar1) { bVar1 = *(int *)(*(int *)(iVar4 + 0x94) + 0x3f0) != 0; } if (bVar1) { return; } } iVar4 = Get_Execution_Pause_Phase(param_2); if (iVar4 == 0) { func_0x08b54b20(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x5c)); Pause_Execution(param_2,1); } else { iVar4 = *(int *)(param_1 + 0x10); if (*(char *)(*(int *)(*(int *)(iVar4 + 0x2b8) + 0x5c) + 0x21) != '\\0') { if (iVar4 == 0) { DAT_00000051 = 1; } else { *(undefined *)(iVar4 + 0x51) = 1; } PAC::PAC_setCmdId(param_2,0); } } } return; }"
  },
  "multi_cleartweet.html": {
    "href": "multi_cleartweet.html",
    "title": "multi_clearTweet",
    "keywords": "multi_clearTweet Sets loading phase to -1. Code Information Name: multi_clearTweet Scope: Global PAC Instruction (Binary): 25 0a 32 00 Assembly Address in Memory : 0x894c99c Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894c99c(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); FUN_089d16bc(*(undefined4 *)(*(int *)(iVar2 + 100) + 0x18c)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_disablescore.html": {
    "href": "multi_disablescore.html",
    "title": "multi_disableScore",
    "keywords": "multi_disableScore Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multi_disableScore Scope: Global PAC Instruction (Binary): 25 16 0b 01 Assembly Address in Memory : 0x8928a48 Parameters (int)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 16 0b 01 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: multi_disableScore((int)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928a48(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x58); if (iVar3 != 0) { if (*piVar1 == 0) { *(uint *)(iVar3 + 0x400) = *(uint *)(iVar3 + 0x400) & ~*puVar2; } else { *(uint *)(iVar3 + 0x400) = *(uint *)(iVar3 + 0x400) | *puVar2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_endnosyncevent.html": {
    "href": "multi_endnosyncevent.html",
    "title": "multi_endNosyncEvent",
    "keywords": "multi_endNosyncEvent Indicates no-sync event has ended and sync is required now. Code Information Name: multi_endNosyncEvent Scope: Global PAC Instruction (Binary): 25 16 e4 00 Assembly Address in Memory : 0x891b5a4 Parameters This function is parameterless. Example Here is one example in hex: 25 16 e4 00 Which is interpreted as: multi_endNosyncEvent() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b5a4(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); if (*(char *)(*(int *)(iVar2 + 100) + 0xa7) == '\\0') { *(undefined *)(*(int *)(iVar2 + 100) + 0xa6) = 0; PAC::PAC_setCmdId(param_2,0); } else { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multi_getroundtriptime.html": {
    "href": "multi_getroundtriptime.html",
    "title": "multi_getRoundTripTime",
    "keywords": "multi_getRoundTripTime Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multi_getRoundTripTime Scope: Global PAC Instruction (Binary): 25 0a 35 00 Assembly Address in Memory : 0x894cb08 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cb08(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); iVar5 = *(int *)(iVar4 + 100); iVar4 = Is_Multi(iVar5); if (iVar4 == 0) { *puVar2 = 0; } else { uVar3 = FUN_089d14e0(*(undefined4 *)(iVar5 + 0x18c),*puVar1); *puVar2 = uVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_gettweet.html": {
    "href": "multi_gettweet.html",
    "title": "multi_getTweet",
    "keywords": "multi_getTweet Loads other players' loading status in multi. Code Information Name: multi_getTweet Scope: Global PAC Instruction (Binary): 25 0a 34 00 Assembly Address in Memory : 0x894ca70 Parameters (int)player_index (8 bytes) : Index of the player in multi. expected 0~3, host is 0. (int)phase (8 bytes) : Expected 0~6. 0~3 is used while loading mission. Details in example. Example Here is one example in hex: 25 0a 34 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 10 00 00 00 Which is interpreted as: multi_getTweet((int *)iVar0, (int *)iVar16) This shows speech bubbles while other player is waiting: 00011BC4 250A3400:multi_getTweet(4:0, 4:10) /* player is ready. */ 00011BD8 25001700:cmd_ifEQ(4:10, 1.0, 1:11C6C) /* player is viewing event. */ 00011BF0 25001700:cmd_ifEQ(4:10, 2.0, 1:11D04) /* player is reading tips */ 00011C08 25001700:cmd_ifEQ(4:10, 3.0, 1:11D9C) /* player is checking treasure chests. */ 00011C20 25001700:cmd_ifEQ(4:10, 4.0, 1:11E34) /* player is checking results. */ 00011C38 25001700:cmd_ifEQ(4:10, 5.0, 1:11ECC) /* player is loading data. */ 00011C50 25001700:cmd_ifEQ(4:10, 6.0, 1:11F64) 00011C68 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894ca70(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); iVar4 = FUN_089d13bc(*(undefined4 *)(*(int *)(iVar4 + 100) + 0x18c),*puVar1); *puVar2 = *(undefined4 *)(iVar4 + 0x10); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_isfinishgoahead.html": {
    "href": "multi_isfinishgoahead.html",
    "title": "multi_isFinishGoAhead",
    "keywords": "multi_isFinishGoAhead After multi_startGoAhead, checks if players are ready. Code Information Name: multi_isFinishGoAhead Scope: Global PAC Instruction (Binary): 25 16 e7 00 Assembly Address in Memory : 0x891b7c8 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 e7 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: multi_isFinishGoAhead((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b7c8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); uVar2 = *(undefined4 *)(iVar3 + 100); iVar3 = Is_Multi(uVar2); if (iVar3 != 0) { iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } if (*(int *)(iVar3 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } } iVar3 = FUN_089872b0(uVar2,0); if (iVar3 == 0) { *puVar1 = 0; } else { *puVar1 = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_iswaitsync.html": {
    "href": "multi_iswaitsync.html",
    "title": "multi_isWaitSync",
    "keywords": "multi_isWaitSync Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multi_isWaitSync Scope: Global PAC Instruction (Binary): 25 16 b7 00 Assembly Address in Memory : 0x891b3e0 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 b7 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: multi_isWaitSync((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b3e0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); iVar4 = *(int *)(iVar3 + 100); *puVar1 = 0; iVar3 = Is_Multi(iVar4); if (iVar3 == 0) { PAC::PAC_setCmdId(param_2,0); } else if (*(char *)(iVar4 + 0xa4) == '\\x01') { *puVar1 = 1; PAC::PAC_setCmdId(param_2,0); } else { iVar3 = FUN_08987188(iVar4); if (iVar3 == 0) { *puVar1 = 1; PAC::PAC_setCmdId(param_2,0); } else { iVar3 = FUN_08987300(iVar4); if (iVar3 == 0) { *puVar1 = 1; PAC::PAC_setCmdId(param_2,0); } else { PAC::PAC_setCmdId(param_2,0); } } } return; }"
  },
  "multi_settweet.html": {
    "href": "multi_settweet.html",
    "title": "multi_setTweet",
    "keywords": "multi_setTweet Sends player loading status to the other player(s). Code Information Name: multi_setTweet Scope: Global PAC Instruction (Binary): 25 0a 33 00 Assembly Address in Memory : 0x894c9e8 Parameters (int)phase (8 bytes) : Expected 0~6. 0~3 is used while loading mission. Details in example. Example Here is one example in hex: 25 0a 33 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: multi_setTweet((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894c9e8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); iVar4 = *(int *)(iVar3 + 100); iVar3 = Is_Multi(iVar4); if (iVar3 != 0) { FUN_089d1628(*(undefined4 *)(iVar4 + 0x18c),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_startgoahead.html": {
    "href": "multi_startgoahead.html",
    "title": "multi_startGoAhead",
    "keywords": "multi_startGoAhead Called in multi only, after confirming tips, Indicates the player is ready. Code Information Name: multi_startGoAhead Scope: Global PAC Instruction (Binary): 25 16 e5 00 Assembly Address in Memory : 0x891b608 Parameters This function is parameterless. Example Here is one example in hex: 25 16 e5 00 Which is interpreted as: multi_startGoAhead() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b608(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; int iVar3; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar3 = *(int *)(iVar2 + 100); iVar2 = Is_Multi(iVar3); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } if (*(char *)(iVar3 + 0xa6) != '\\0') { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 0) { iVar2 = Is_Multi(iVar3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } Pause_Execution(param_2,1); iVar2 = FUN_08987190(iVar3,0); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_startnosyncevent.html": {
    "href": "multi_startnosyncevent.html",
    "title": "multi_startNosyncEvent",
    "keywords": "multi_startNosyncEvent Caution DO NOT SPEED UP IN MULTI even if this is called. It still causes desync (best seen in custcene). The real 'speedup allowed' part (e.g. chest open scene) doesn't call this. Indicates this event is not synced, e.g. tips and event scenes. This state will continue until multi_endOfSyncEvent is called. Code Information Name: multi_startNosyncEvent Scope: Global PAC Instruction (Binary): 25 16 e3 00 Assembly Address in Memory : 0x891b4ec Parameters This function is parameterless. Example Here is one example in hex: 25 16 e3 00 Which is interpreted as: multi_startNosyncEvent() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b4ec(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar2 = *(int *)(iVar2 + 100); if (*(char *)(iVar2 + 0xa7) == '\\0') { if (*(char *)(iVar2 + 0xa6) == '\\0') { *(undefined *)(iVar2 + 0xa6) = 1; uVar1 = Save::Get_Save_BaseAddr(); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); uVar1 = zero_if_08aabe38_is_zero(1); FUN_0886cff8(uVar1,*(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x784)); PAC::PAC_setCmdId(param_2,0); } else { PAC::PAC_setCmdId(param_2,0); } } else { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multi_stopgoahead.html": {
    "href": "multi_stopgoahead.html",
    "title": "multi_stopGoAhead",
    "keywords": "multi_stopGoAhead Inidicates that every player is ready. Code Information Name: multi_stopGoAhead Scope: Global PAC Instruction (Binary): 25 16 e6 00 Assembly Address in Memory : 0x891b724 Parameters This function is parameterless. Example Here is one example in hex: 25 16 e6 00 Which is interpreted as: multi_stopGoAhead() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b724(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); uVar1 = *(undefined4 *)(iVar2 + 100); iVar2 = Is_Multi(uVar1); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } } Set_Execution_Pause_Phase(uVar1,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multi_waitactivegenerator.html": {
    "href": "multi_waitactivegenerator.html",
    "title": "multi_waitActiveGenerator",
    "keywords": "multi_waitActiveGenerator Waits until generating is done in specific generator. Followed after spawn. Code Information Name: multi_waitActiveGenerator Scope: Global PAC Instruction (Binary): 25 16 b5 00 Assembly Address in Memory : 0x891b1c8 Parameters (int)generator_identifier (8 bytes) : Identifier of the generator, 2nd parameter of create. Example Here is one example in hex: 25 16 b5 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: multi_waitActiveGenerator((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b1c8(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; int iVar3; undefined4 *puVar4; int iVar5; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar5 = *(int *)(iVar2 + 100); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } uVar1 = *(undefined4 *)(iVar2 + 0x2c8); iVar2 = Get_Execution_Pause_Phase(param_2); iVar3 = Is_Multi(iVar5); if (iVar3 != 0) { iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } if (*(int *)(iVar3 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } if (*(char *)(iVar5 + 0xa6) != '\\0') { PAC::PAC_setCmdId(param_2,0); return; } } if (iVar2 == 3) { iVar2 = FUN_089872b0(iVar5,2); if (iVar2 != 0) { Set_Execution_Pause_Phase(iVar5,2); PAC::PAC_setCmdId(param_2,0); *(undefined *)(iVar5 + 0xa4) = 0; } } else if (iVar2 == 2) { Pause_Execution(param_2); iVar2 = FUN_08987190(iVar5,2); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); *(undefined *)(iVar5 + 0xa4) = 0; } } else if (iVar2 == 1) { iVar2 = Get_Pool_BaseAddr(uVar1,*(undefined4 *)(param_1 + 0x34)); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); *(undefined *)(iVar5 + 0xa4) = 0; } else if (*(char *)(iVar2 + 0x24) != '\\0') { Pause_Execution(param_2,2); } } else if (iVar2 == 0) { puVar4 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Multi(iVar5); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); } else { Pause_Execution(param_2,1); *(undefined4 *)(param_1 + 0x30) = *puVar4; iVar2 = func_0x08b5ac20(uVar1); *(int *)(param_1 + 0x34) = iVar2; if (iVar2 < 0) { PAC::PAC_setCmdId(param_2,0); } else { *(undefined *)(iVar5 + 0xa4) = 1; } } } return; }"
  },
  "multi_waitgoahead.html": {
    "href": "multi_waitgoahead.html",
    "title": "multi_waitGoAhead",
    "keywords": "multi_waitGoAhead Called in dungeon boss scene in story, including gheek dongora. Code Information Name: multi_waitGoAhead Scope: Global PAC Instruction (Binary): 25 16 b1 00 Assembly Address in Memory : 0x891b04c Parameters This function is parameterless. Example Here is one example in hex: 25 16 b1 00 Which is interpreted as: multi_waitGoAhead() Code Ths PAC instruction calls this function (Decompiled by Ghidra): //Jumps to 0x0891af04, setting 3rd parameter to 0 void FUN_0891af04(int param_1,undefined4 param_2,undefined4 param_3) { undefined4 uVar1; int iVar2; int iVar3; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar3 = *(int *)(iVar2 + 100); iVar2 = Is_Multi(iVar3); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } if (*(char *)(iVar3 + 0xa6) != '\\0') { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 0) { iVar2 = Is_Multi(iVar3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } Pause_Execution(param_2,1); iVar2 = FUN_08987190(iVar3,param_3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = FUN_089872b0(iVar3,param_3); if (iVar2 != 0) { Set_Execution_Pause_Phase(iVar3,param_3); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multi_waitgoahead1.html": {
    "href": "multi_waitgoahead1.html",
    "title": "multi_waitGoAhead1",
    "keywords": "multi_waitGoAhead1 This is called twice. Once while setting up, and once the the mission is ready. Code Information Name: multi_waitGoAhead1 Scope: Global PAC Instruction (Binary): 25 16 b2 00 Assembly Address in Memory : 0x891b054 Parameters This function is parameterless. Example Here is one example in hex: 25 16 b2 00 Which is interpreted as: multi_waitGoAhead1() Code Ths PAC instruction calls this function (Decompiled by Ghidra): //Jumps to 0x0891af04, setting 3rd parameter to 1 void FUN_0891af04(int param_1,undefined4 param_2,undefined4 param_3) { undefined4 uVar1; int iVar2; int iVar3; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar3 = *(int *)(iVar2 + 100); iVar2 = Is_Multi(iVar3); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } if (*(char *)(iVar3 + 0xa6) != '\\0') { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 0) { iVar2 = Is_Multi(iVar3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } Pause_Execution(param_2,1); iVar2 = FUN_08987190(iVar3,param_3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = FUN_089872b0(iVar3,param_3); if (iVar2 != 0) { Set_Execution_Pause_Phase(iVar3,param_3); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multi_waitgoahead2.html": {
    "href": "multi_waitgoahead2.html",
    "title": "multi_waitGoAhead2",
    "keywords": "multi_waitGoAhead2 Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multi_waitGoAhead2 Scope: Global PAC Instruction (Binary): 25 16 b3 00 Assembly Address in Memory : 0x891b05c Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): //Jumps to 0x0891af04, setting 3rd parameter to 2 void FUN_0891af04(int param_1,undefined4 param_2,undefined4 param_3) { undefined4 uVar1; int iVar2; int iVar3; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar3 = *(int *)(iVar2 + 100); iVar2 = Is_Multi(iVar3); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } if (*(char *)(iVar3 + 0xa6) != '\\0') { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 0) { iVar2 = Is_Multi(iVar3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } Pause_Execution(param_2,1); iVar2 = FUN_08987190(iVar3,param_3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = FUN_089872b0(iVar3,param_3); if (iVar2 != 0) { Set_Execution_Pause_Phase(iVar3,param_3); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multi_waitgoahead3.html": {
    "href": "multi_waitgoahead3.html",
    "title": "multi_waitGoAhead3",
    "keywords": "multi_waitGoAhead3 Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multi_waitGoAhead3 Scope: Global PAC Instruction (Binary): 25 16 b4 00 Assembly Address in Memory : 0x891b064 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): //Jumps to 0x0891af04, setting 3rd parameter to 3 void FUN_0891af04(int param_1,undefined4 param_2,undefined4 param_3) { undefined4 uVar1; int iVar2; int iVar3; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); iVar3 = *(int *)(iVar2 + 100); iVar2 = Is_Multi(iVar3); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } if (*(char *)(iVar3 + 0xa6) != '\\0') { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 0) { iVar2 = Is_Multi(iVar3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } Pause_Execution(param_2,1); iVar2 = FUN_08987190(iVar3,param_3); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = FUN_089872b0(iVar3,param_3); if (iVar2 != 0) { Set_Execution_Pause_Phase(iVar3,param_3); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multi_waittimesync.html": {
    "href": "multi_waittimesync.html",
    "title": "multi_waitTimeSync",
    "keywords": "multi_waitTimeSync Called right before the mission (and right before the countdown), waiting until every player is ready. Calld with pons too. Code Information Name: multi_waitTimeSync Scope: Global PAC Instruction (Binary): 25 16 b0 00 Assembly Address in Memory : 0x891adec Parameters This function is parameterless. Example Here is one example in hex: 25 16 b0 00 Which is interpreted as: multi_waitTimeSync() This is another example to start the mission. 000114D4 2516B000:multi_waitTimeSync() 000114D8 2516B600:multi_battleGoAHead() 000114DC 250C1E00:start(2:0) 000114E8 250C0700:setDisableKey(2:0, 2:1) 000114FC 25000F00:cmd_waitFrame(2:1) 00011508 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891adec(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar1,1); uVar1 = *(undefined4 *)(iVar2 + 100); iVar2 = Is_Multi(uVar1); if (iVar2 != 0) { iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } if (*(int *)(iVar2 + 0x44) != 0xd) { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = Get_Execution_Pause_Phase(param_2); if (iVar2 == 0) { iVar2 = Is_Multi(uVar1); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } Pause_Execution(param_2,1); iVar2 = FUN_089870b4(uVar1); if (iVar2 == 0) { PAC::PAC_setCmdId(param_2,0); return; } } iVar2 = FUN_08987188(uVar1); if (iVar2 != 0) { FUN_08987144(uVar1); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "multiaddmapicon.html": {
    "href": "multiaddmapicon.html",
    "title": "multiAddMapIcon",
    "keywords": "multiAddMapIcon Adds an icon to the VS map. Code Information Name: multiAddMapIcon Scope: Global PAC Instruction (Binary): 25 16 0e 00 Assembly Address in Memory : 0x8919a64 Parameters (int *)handle (8 bytes) : Gimmick handle. (undefined4)Var1 (8 bytes) : Please describe. 0 deletes the icon. Incorrect value might crash the game. Example Here is one example in hex: 25 16 0e 00 / 04 00 00 00 / 0f 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: multiAddMapIcon((int *)iVar15, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919a64(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; int iVar5; undefined4 local_40; undefined4 local_3c; undefined4 local_38; undefined4 local_34; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 10)) && (iVar3 != 0)) && (((*(uint *)(iVar3 + 400) < 4 && (*(int *)(param_1 + 0x10) != 0)) && (iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar4 != 0)))) { iVar4 = *(int *)(*(int *)(iVar4 + 0x2c) + 0x54); switch(*puVar2) { case 0: case 4: case 0xc: iVar5 = func_0x08b2aa18(iVar4); if (iVar5 != 0) { (**(code **)(*(int *)(iVar5 + 0x10) + 0x44)) (iVar5,*(undefined4 *)(iVar4 + 0x14),iVar3,iVar4 + 0x4500,*puVar2); } break; case 1: iVar5 = func_0x08b2ab98(iVar4); if (iVar5 != 0) { local_8 = 0; local_4 = 0; local_c = 0; local_10 = 0xc1000000; (**(code **)(*(int *)(iVar5 + 0x10) + 0x44)) (iVar5,*(undefined4 *)(iVar4 + 0x14),iVar3,iVar4 + 0x4500,1,1,&local_8,&local_10); } break; case 2: iVar5 = func_0x08b2ab98(iVar4); if (iVar5 != 0) { local_18 = 0; local_14 = 0; local_20 = 0; local_1c = 0; (**(code **)(*(int *)(iVar5 + 0x10) + 0x44)) (iVar5,*(undefined4 *)(iVar4 + 0x14),iVar3,iVar4 + 0x4500,0,2,&local_18,&local_20) ; } break; case 3: case 6: case 7: case 8: iVar5 = func_0x08b2ab98(iVar4); if (iVar5 != 0) { local_38 = 0; local_34 = 0; local_40 = 0; local_3c = 0; (**(code **)(*(int *)(iVar5 + 0x10) + 0x44)) (iVar5,*(undefined4 *)(iVar4 + 0x14),iVar3,iVar4 + 0x4500,*puVar2,0,&local_38, &local_40); } break; case 9: iVar5 = func_0x08b2ac28(iVar4); if (iVar5 != 0) { (**(code **)(*(int *)(iVar5 + 0x10) + 0x44)) (iVar5,*(undefined4 *)(iVar4 + 0x14),iVar3,iVar4 + 0x4500); } break; case 10: case 0xb: iVar5 = func_0x08b2ab98(iVar4); if (iVar5 != 0) { local_28 = 0; local_24 = 0; local_30 = 0; local_2c = 0; (**(code **)(*(int *)(iVar5 + 0x10) + 0x44)) (iVar5,*(undefined4 *)(iVar4 + 0x14),iVar3,iVar4 + 0x4500,*puVar2,2,&local_28, &local_30); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multiaddmapunit.html": {
    "href": "multiaddmapunit.html",
    "title": "multiAddMapUnit",
    "keywords": "multiAddMapUnit Adds a unit to the troop directly. Code Information Name: multiAddMapUnit Scope: Global PAC Instruction (Binary): 25 16 0f 00 Assembly Address in Memory : 0x8919e10 Parameters (int *)troop_handle (8 bytes) : The troop handle. (int *)handle_to_add (8 bytes) : This can be obtained from e.g. addChara. Example Here is one example in hex: 25 16 0f 00 / 04 00 00 00 / 36 00 00 00 / 04 00 00 00 / 32 00 00 00 Which is interpreted as: multiAddMapUnit((int *)iVar54, (int *)iVar50) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919e10(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); Get_Some_Flag(1); Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multigetscore.html": {
    "href": "multigetscore.html",
    "title": "multiGetScore",
    "keywords": "multiGetScore Gets the current VS score of a given team. Code Information Name: multiGetScore Scope: Global PAC Instruction (Binary): 25 16 11 00 Assembly Address in Memory : 0x8919ffc Parameters (int)team_side (8 bytes) : Team to get, 0 is blue team and 1 is red team. (int *)score (8 bytes) : Variable to store the current VS score. Example Here is one example in hex: 25 16 11 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: multiGetScore((int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919ffc(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = *(undefined4 *) (*piVar1 * 4 + *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x58) + 0x424); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multigettime.html": {
    "href": "multigettime.html",
    "title": "multiGetTime",
    "keywords": "multiGetTime Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multiGetTime Scope: Global PAC Instruction (Binary): 25 16 15 00 Assembly Address in Memory : 0x891a0f0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 15 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: multiGetTime((float *)fVar0, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a0f0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x2c), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x58), iVar3 != 0)) { uVar4 = func_0x08b2f050(iVar3); *puVar1 = uVar4; uVar4 = func_0x08b2f010(iVar3); *puVar2 = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multipausetime.html": {
    "href": "multipausetime.html",
    "title": "multiPauseTime",
    "keywords": "multiPauseTime Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multiPauseTime Scope: Global PAC Instruction (Binary): 25 16 16 00 Assembly Address in Memory : 0x891a1b0 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 16 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: multiPauseTime((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a1b0(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x58), iVar2 != 0)) { *(bool *)(iVar2 + 0x410) = *piVar1 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multisetmultiparam.html": {
    "href": "multisetmultiparam.html",
    "title": "multiSetMultiParam",
    "keywords": "multiSetMultiParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: multiSetMultiParam Scope: Global PAC Instruction (Binary): 25 16 0d 00 Assembly Address in Memory : 0x8919d2c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 16 0d 00 / 10 00 00 00 / 00 00 7a 44 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / cd cc 4c 3e / 10 00 00 00 / 89 88 88 3e Which is interpreted as: multiSetMultiParam((float)1000, (float)0, (float)0.2, (float)0.26666668) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919d2c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined4 uVar6; undefined4 uVar7; undefined4 uVar8; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x54); if (iVar5 != 0) { uVar7 = *puVar4; uVar8 = *puVar2; uVar6 = *puVar1; *(undefined4 *)(iVar5 + 0x4500) = *puVar3; *(undefined4 *)(iVar5 + 0x4504) = uVar7; *(undefined4 *)(iVar5 + 0x4508) = uVar6; *(undefined4 *)(iVar5 + 0x450c) = uVar8; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multisetscore.html": {
    "href": "multisetscore.html",
    "title": "multiSetScore",
    "keywords": "multiSetScore Adds VS score to a team's current VS score. Code Information Name: multiSetScore Scope: Global PAC Instruction (Binary): 25 16 10 00 Assembly Address in Memory : 0x8919e98 Parameters (int)team_side (8 bytes) : Team to get, 0 is blue team and 1 is red team. (int)score_type (8 bytes) : Expected 0~3. Keep 2 for regular action. (int)score (8 bytes) : Score to add. (uint *)occupying_flag (8 bytes) : Obtained from getGimmickPowerGaugePoint, 0x1 blue, 0x10 red. score_type scoring 3 unused, sets the score to just the given value without adding. 2 regular score setting 1 unused 0 like 1 but in a loop, observed in racing VS mission. Example Here is one example in hex: 25 16 10 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: multiSetScore((int)0, (int)2, (int *)iVar0, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919e98(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; undefined4 *puVar4; int iVar5; int iVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *piVar2; iVar7 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x58); iVar6 = *piVar1; if (iVar5 == 3) { iVar5 = *(int *)(iVar6 * 4 + iVar7 + 0x424); if (iVar5 != *piVar3) { Add_VS_Score(iVar7,iVar6,*piVar3 - iVar5); } } else if (iVar5 == 2) { Add_VS_Score(iVar7,iVar6,*piVar3); func_0x08b2f248(iVar7,*piVar3,*puVar4); } else if (iVar5 == 1) { func_0x08b2eb18(iVar7); } else if (iVar5 == 0) { func_0x08b2ecd8(iVar7); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "multisettime.html": {
    "href": "multisettime.html",
    "title": "multiSetTime",
    "keywords": "multiSetTime Sets time limit for the VS game. Code Information Name: multiSetTime Scope: Global PAC Instruction (Binary): 25 16 14 00 Assembly Address in Memory : 0x891a08c Parameters (float)time (8 bytes) : VS time limit to set as seconds. -1 is unlimited time. Example Here is one example in hex: 25 16 14 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: multiSetTime((float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a08c(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); func_0x08b2ed20(*puVar1,*(undefined4 *) (*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x58)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "networkErrorInvoke.html": {
    "href": "networkErrorInvoke.html",
    "title": "networkErrorInvoke",
    "keywords": "networkErrorInvoke There are few functions with the same name: networkErrorInvoke (2516e800) (Global) networkErrorInvoke (251c2c00) (Azito)"
  },
  "networkerrorinvoke_2516e800.html": {
    "href": "networkerrorinvoke_2516e800.html",
    "title": "networkErrorInvoke (2516e800)",
    "keywords": "networkErrorInvoke (2516e800) Other functions have the same name. Check the Disambiguation page to find them. During mission, check if there is network error or not. This is called every time even when the hideout is closed. Code Information Name: networkErrorInvoke Scope: Global PAC Instruction (Binary): 25 16 e8 00 Assembly Address in Memory : 0x891b89c Parameters This function is parameterless. Example Here is one example in hex: 25 16 e8 00 Which is interpreted as: networkErrorInvoke() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b89c(int param_1,undefined4 param_2) { int iVar1; iVar1 = FUN_08990e6c(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x2d8)); if (iVar1 != 0) { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "networkerrorinvoke_251c2c00.html": {
    "href": "networkerrorinvoke_251c2c00.html",
    "title": "networkErrorInvoke (251c2c00)",
    "keywords": "networkErrorInvoke (251c2c00) Other functions have the same name. Check the Disambiguation page to find them. In hideout, check if there is network error or not. This is called every time even when the hideout is closed. Code Information Name: networkErrorInvoke Scope: Azito PAC Instruction (Binary): 25 1c 2c 00 Assembly Address in Memory : 0x8b50028 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 2c 00 Which is interpreted as: networkErrorInvoke() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b50028(int param_1,undefined4 param_2) { int iVar1; iVar1 = FUN_Azito__08accd40(*(undefined4 *)(*(int *)(param_1 + 0x10) + 500)); if (iVar1 != 0) { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "nextappearmissile.html": {
    "href": "nextappearmissile.html",
    "title": "nextAppearMissile",
    "keywords": "nextAppearMissile Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: nextAppearMissile Scope: Global PAC Instruction (Binary): 25 16 39 01 Assembly Address in Memory : 0x892ac88 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 39 01 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: nextAppearMissile((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892ac88(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar2 + 0x2c) + 0x54),*puVar1), iVar2 != 0)) { FUN_08a4e80c(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "notifyerrorunknowndlcquest.html": {
    "href": "notifyerrorunknowndlcquest.html",
    "title": "notifyErrorUnknownDLCQuest",
    "keywords": "notifyErrorUnknownDLCQuest Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: notifyErrorUnknownDLCQuest Scope: Azito PAC Instruction (Binary): 25 1c 31 00 Assembly Address in Memory : 0x8b50588 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b50588(int param_1,undefined4 param_2) { if ((*(int *)(param_1 + 0x10) != 0) && (*(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14) != 0)) { FUN_Azito__08b59320(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "obstaclecheckendmove.html": {
    "href": "obstaclecheckendmove.html",
    "title": "obstacleCheckEndMove",
    "keywords": "obstacleCheckEndMove Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: obstacleCheckEndMove Scope: Global PAC Instruction (Binary): 25 21 36 00 Assembly Address in Memory : 0x89b4350 Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) Example Here is one example in hex: 25 21 36 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: obstacleCheckEndMove((int *)iVar20, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b4350(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int iVar3; uint uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 1; iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { uVar4 = FUN_0897ee74(iVar3); *puVar2 = uVar4 & 0xff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "obstacleclear.html": {
    "href": "obstacleclear.html",
    "title": "obstacleClear",
    "keywords": "obstacleClear Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: obstacleClear Scope: Global PAC Instruction (Binary): 25 21 34 00 Assembly Address in Memory : 0x89b4254 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 21 34 00 / 04 00 00 00 / 14 00 00 00 Which is interpreted as: obstacleClear((int *)iVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b4254(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { *(undefined4 *)(iVar2 + 0x570) = 0; *(undefined4 *)(iVar2 + 0x574) = 0; *(undefined4 *)(iVar2 + 0x578) = 0; *(undefined *)(iVar2 + 0x57c) = 1; *(undefined *)(iVar2 + 0x57d) = 0; *(undefined *)(iVar2 + 0x57e) = 0; *(undefined *)(iVar2 + 0x57f) = 1; *(undefined *)(iVar2 + 0x580) = 0; *(undefined *)(iVar2 + 0x581) = 0; *(undefined *)(iVar2 + 0x582) = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "obstaclecreateeffect.html": {
    "href": "obstaclecreateeffect.html",
    "title": "obstacleCreateEffect",
    "keywords": "obstacleCreateEffect Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: obstacleCreateEffect Scope: Global PAC Instruction (Binary): 25 21 35 00 Assembly Address in Memory : 0x89b42e0 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 21 35 00 / 04 00 00 00 / 14 00 00 00 Which is interpreted as: obstacleCreateEffect((int *)iVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b42e0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { (**(code **)(*(int *)(iVar2 + 0xc) + 0x120))(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "obstaclegetmoveratio.html": {
    "href": "obstaclegetmoveratio.html",
    "title": "obstacleGetMoveRatio",
    "keywords": "obstacleGetMoveRatio Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: obstacleGetMoveRatio Scope: Global PAC Instruction (Binary): 25 21 37 00 Assembly Address in Memory : 0x89b43ec Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 21 37 00 / 04 00 00 00 / 14 00 00 00 / 20 00 00 00 / 2c 00 00 00 / 40 00 00 00 / ff 01 00 00 Which is interpreted as: obstacleGetMoveRatio((int *)iVar20, (float *)fVar44, ((global)float *)gfVar511) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b43ec(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar2 = 0; iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar4 != 0) { uVar5 = FUN_0897ef4c(iVar4,1); *puVar2 = uVar5; *puVar3 = *(undefined4 *)(iVar4 + 0x90); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "openalltips.html": {
    "href": "openalltips.html",
    "title": "openAllTips",
    "keywords": "openAllTips Unlocks all tips. This exists for debugging purpose. Code Information Name: openAllTips Scope: Azito PAC Instruction (Binary): 25 1c 2b 00 Assembly Address in Memory : 0x8b4ffd8 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 2b 00 Which is interpreted as: openAllTips() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4ffd8(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Save::Get_Save_BaseAddr(1); Syscall::Kernel::Kernel_Memset(*(int *)(iVar1 + 0x50) + 0x2b808,0xffffffff,0x10); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "pan.html": {
    "href": "pan.html",
    "title": "pan",
    "keywords": "pan Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: pan Scope: Global PAC Instruction (Binary): 25 0b 06 00 Assembly Address in Memory : 0x896fb34 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 0b 06 00 / 02 00 00 00 / be 00 90 3f / 10 00 00 00 / 00 00 00 00 / 20 00 00 00 / 05 00 00 00 Which is interpreted as: pan((int)1066401982, (float)0, (float *)fVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896fb34(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); FUN_088eb36c((float)*piVar3,0,(float)*piVar2,*(int *)(param_1 + 0x14) + 0x60,*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "pausemotion.html": {
    "href": "pausemotion.html",
    "title": "pauseMotion",
    "keywords": "pauseMotion Pauses the animation. Please describe difference from stopMotion. Code Information Name: pauseMotion Scope: Global PAC Instruction (Binary): 25 17 3b 00 Assembly Address in Memory : 0x8914d34 Parameters (int *)handle_id (8 bytes) : The target handle. (int)pause (8 bytes) : 0 is resume, 1 is pause. (float)fVar1 (8 bytes) : Keep this as zero. (Supposed to be time related but doesn't work correctly) Example Here is one example in hex: 25 17 3b 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: pauseMotion((int *)iVar0, (int)1, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914d34(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; float *pfVar3; int iVar4; int iVar5; float fVar6; float fVar7; undefined local_c; undefined local_b; undefined local_a; undefined local_9; undefined4 local_8; uint local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (((iVar4 != 0) && (iVar4 = *(int *)(iVar4 + 200), iVar4 != 0)) && (iVar5 = *(int *)(iVar4 + 0x1e8), iVar5 != 0)) { if (*pfVar3 <= 0.0) { *(bool *)(iVar4 + 0xb9) = *piVar2 != 0; } else { *(undefined *)(iVar5 + 0xb9) = 1; fVar7 = *pfVar3; if (*piVar2 == 0) { local_c = 0xfe; fVar6 = fVar7 * 4800.0; if (fVar6 < 2.147484e+09) { local_4 = (uint)fVar6; } else { local_4 = (int)(fVar6 - 2.147484e+09) | 0xffff8000; } if (fVar7 < 0.0) { local_4 = 0; } } else { local_c = 0xff; fVar6 = fVar7 * 4800.0; if (fVar6 < 2.147484e+09) { local_4 = (uint)fVar6; } else { local_4 = (int)(fVar6 - 2.147484e+09) | 0xffff8000; } if (fVar7 < 0.0) { local_4 = 0; } } local_a = fVar7 < 0.0; local_8 = 0; local_9 = 1; local_b = 0; FUN_08981000(iVar5,&local_c); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "playSe.html": {
    "href": "playSe.html",
    "title": "playSe",
    "keywords": "playSe There are few functions with the same name: playSe (25176f00) (Global) playSe (250b0100) (Global)"
  },
  "playatrac.html": {
    "href": "playatrac.html",
    "title": "playAtrac",
    "keywords": "playAtrac Starts playing Atrac (music) file. The music files are sgd that does not start with ptp_. Code Information Name: playAtrac Scope: Global PAC Instruction (Binary): 25 0b 02 00 Assembly Address in Memory : 0x896f7fc Parameters (int)atrac_id (8 bytes) : ID of the Atrac. (float)delay (8 bytes) : Delay before playing the Atrac, as seconds. (float)volume (8 bytes): The music volume, 1 is 100%. (float)pan_left (8 bytes): The pan left volume, keep 0 for normal volume. (float_)pan_right (8 bytes): The pan right volume, keep 0 for normal volume. (float)speed (8 bytes): The music speed (with pitch change). About Atrac ID, first 4 byte (for example, 0x5070 in 0x507000f8 is related to selist.spm). Last 3 bytes (in the example above, 0x0f8) are the real Atrac ID. The ID must be less than 300 (< 0x12C). When pausing/disaling sound with stop or cancel, use same atrac_id as the one that used in playAtrac. Example Here is one example in hex: 25 0b 02 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 3f / 10 00 00 00 / cd cc 4c 3e / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: playAtrac((int *)iVar0, (float)0.5, (float)0.2, (float)0, (float)0, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896f7fc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); Sound::PlayMusic(*puVar2,*puVar3,*puVar4,*puVar5,0,*puVar6,0,*(int *)(param_1 + 0x14) + 0x60, *puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "playhiteffect.html": {
    "href": "playhiteffect.html",
    "title": "playHitEffect",
    "keywords": "playHitEffect Displays damage number. This is meant for cutscene and does not deal actual damage. Code Information Name: playHitEffect Scope: Global PAC Instruction (Binary): 25 16 12 01 Assembly Address in Memory : 0x89297d8 Parameters (float)position_x (8 bytes) : X Position to display, as PSP pixels in world screen. (float)position_y (8 bytes) : Y position to display, as PSP pixels in world screen, relative to the ground. (int)damage_amount (8 bytes) : Damage amount to display. (int)display_type (8 bytes) : 0 is normal damage display, 1 is critical, 2 is healing. Note that PSP screen size is 480 x 272. Example Here is one example in hex: 25 16 12 01 / 10 00 00 00 / 00 00 b9 44 / 10 00 00 00 / 00 00 f0 41 / 02 00 00 00 / 9f 86 01 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: playHitEffect((float)1480, (float)30, (int)99999, (int)1) This is from the hero kick scene. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089297d8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 uVar5; int iVar6; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x128); if (iVar6 != 0) { local_c = *puVar2; local_10 = *puVar1; local_4 = 0x3f800000; local_8 = 0; uVar5 = FUN_088ad944(iVar6,1); Damage::Display_Damage(uVar5,*puVar4,*puVar3,&local_10,0,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "playmotion.html": {
    "href": "playmotion.html",
    "title": "playMotion",
    "keywords": "playMotion Plays certain motion of a given character or any object. Please describe difference from pushMotion. Code Information Name: playMotion Scope: Global PAC Instruction (Binary): 25 17 37 00 Assembly Address in Memory : 0x89146e0 Parameters (int *)handle_id (8 bytes) : The target handle. (int)action_id (8 bytes) : The Action ID to perform. (bool)loop (8 bytes) : If it is 0, animation is played once and character is paused. Otherwise the animation loops. (float)offset (8 bytes) : Start offset of the animation. (Maybe 1.0 represents around 0.2sec) Usual hero animation offset length seems like around 6~10. Please tell more about this parameter. (float)delay (8 bytes) : Delay before starting the animation. This can be -1. Remarks Somehow playing motion is not immediate and has delay. Please describe if this issue is for gimmick only. Example Here is one example in hex: 25 17 37 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: playMotion((int *)iVar0, (int)1, (int)1, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089146e0(int param_1,undefined4 param_2) { int *piVar1; undefined2 *puVar2; int *piVar3; undefined4 *puVar4; float *pfVar5; int iVar6; int iVar7; float fVar8; float fVar9; undefined local_c; char local_b; undefined local_a; undefined local_9; undefined4 local_8; uint local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined2 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); pfVar5 = (float *)Pac_Get_Param(param_2,4,1,4); if (*piVar1 != -1) { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar6 == 0) { iVar6 = 0; } // skipping this = executes id 0 animation if (((iVar6 != 0) && (iVar6 = *(int *)(iVar6 + 200), iVar6 != 0)) && (iVar7 = *(int *)(iVar6 + 0x1e8), iVar7 != 0)) { *(undefined *)(iVar6 + 0xb9) = 0; *(undefined *)(iVar7 + 0xb9) = 1; local_8 = *puVar4; fVar9 = *pfVar5; local_b = -(*piVar3 != 0); fVar8 = fVar9 * 4800.0; local_c = (undefined)*puVar2; // decides anim if (fVar8 < 2.147484e+09) { local_4 = (uint)fVar8; } else { local_4 = (int)(fVar8 - 2.147484e+09) | 0xffff8000; } local_a = fVar9 < 0.0; local_9 = 1; if (fVar9 < 0.0) { local_4 = 0; } FUN_08980f68(iVar7,&local_c); if (*pfVar5 == 0.0) { FUN_08980b24(iVar7,iVar6,0); (**(code **)(*(int *)(iVar6 + 0x7c) + 0xc))(iVar6,0); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "playse_250b0100.html": {
    "href": "playse_250b0100.html",
    "title": "playSe (250b0100)",
    "keywords": "playSe (250b0100) Other functions have the same name. Check the Disambiguation page to find them. Starts playing Se (sound effect). The sound files are sgd that does start with ptp_. Code Information Name: playSe Scope: Global PAC Instruction (Binary): 25 0b 01 00 Assembly Address in Memory : 0x896f6e4 Parameters (int)se_id (8 bytes) : ID of the Sound effect. (float)delay (8 bytes) : Delay before playing the sound, as seconds. (float)volume_multiplier (8 bytes): 1 for max voulme. (float)volume (8 bytes): (float)pan (8 bytes): -1 is whole left, +1 is whole right. (float)speed (8 bytes): The sound speed (with pitch change). About Sound ID, first 4 byte (for example, 0x5070 in 0x507000f8 is related to selist.spm). Last 3 bytes (in the example above, 0x0f8) are the real Sound ID. The ID must be less than 300 (< 0x12C). When pausing/disaling sound with stop or cancel, use same se_id as the one that used in playSe. Example Here is one example in hex: 25 0b 01 00 / 02 00 00 00 / 02 0a e0 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: playSe((int)14682626, (float)0, (float)1, (float)0, (float)0, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896f6e4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); Sound::Play_Sound(*puVar2,*puVar3,*puVar4,*puVar5,0,*puVar6,0,*(int *)(param_1 + 0x14) + 0x60, *puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "playse_25176f00.html": {
    "href": "playse_25176f00.html",
    "title": "playSe (25176f00)",
    "keywords": "playSe (25176f00) Other functions have the same name. Check the Disambiguation page to find them. Play a sound effect from position of a handle. Code Information Name: playSe Scope: Global PAC Instruction (Binary): 25 17 6f 00 Assembly Address in Memory : 0x89189ec Parameters (int *)handle (8 bytes) : The handle object to cast the sound. (bool)Var1 (8 bytes) (int)se_id (8 bytes) : ID of the Sound effect. (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (undefined4)Var5 (8 bytes) (undefined4)Var6 (8 bytes) (undefined4)Var7 (8 bytes) Example Here is one example in hex: 25 17 6f 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 5f 08 b0 1c / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: playSe((int *)iVar1, (int)1, (int)481298527, (float)0, (float)1, (float)0, (float)0, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089189ec(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; undefined4 *puVar8; int iVar9; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); iVar9 = FUN_088e6a34(1); if (*piVar1 == -1) { Sound::Play_Sound(*puVar4,*puVar5,*puVar6,*puVar7,0,*puVar8,0,iVar9 + 0x60,*puVar3); } else { iVar9 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar9 == 0) { iVar9 = 0; } if (iVar9 != 0) { FUN_08880ea0(*puVar4,*puVar5,*puVar6,*puVar7,0,*puVar8,0,iVar9,*puVar3,*piVar2 == 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "playsefrompos.html": {
    "href": "playsefrompos.html",
    "title": "playSeFromPos",
    "keywords": "playSeFromPos Starts playing Se (sound effect) from specific pan (position). The sound files are sgd that does start with ptp_. Code Information Name: playSeFromPos Scope: Global PAC Instruction (Binary): 25 0b 08 00 Assembly Address in Memory : 0x896fc18 Parameters (float)pos (8 bytes) : X Position to set the sound effect pan. Might be PSP screen pixels, please tell if it is screen or world position. (int)enable_pos_listen (8 bytes) : If this is not zero, pan becomes zero and volume_multiplier becomes one, ignoring those two parameters. (int)se_id (8 bytes) : ID of the Sound effect. (float)delay (8 bytes) : Delay before playing the sound, as seconds. (float)volume_multiplier (8 bytes): Tell more about this, if you found something. Until then keep this to 1. (float)volume (8 bytes) (float)pan (8 bytes): -1 is whole left, +1 is whole right. The value will be clamped to -1 ~ 1. (float)speed (8 bytes) : The sound speed (with pitch change). About Sound ID, first 4 byte (for example, 0x5070 in 0x507000f8 is related to selist.spm). Last 3 bytes (in the example above, 0x0f8) are the real Sound ID. The ID must be less than 300 (< 0x12C). When pausing/disaling sound with stop or cancel, use same se_id as the one that used in playSe. Example Here is one example in hex: 25 0b 08 00 / 20 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 11 0c 30 08 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / cd cc 4c 3f Which is interpreted as: playSeFromPos((float *)fVar0, (int)1, (int)137366545, (float)0, (float)1, (float)0, (float)0, (float)0.8) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896fc18(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; undefined4 *puVar4; float *pfVar5; undefined4 *puVar6; float *pfVar7; undefined4 *puVar8; int iVar9; float fVar10; undefined4 uVar11; float local_8; float local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); pfVar5 = (float *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); pfVar7 = (float *)Pac_Get_Param(param_2,6,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); iVar9 = FUN_088e726c(*(undefined4 *)(param_1 + 0x14),*piVar3,0xfffffffe); if (iVar9 == 0) { if (*piVar2 != 0) { local_8 = 0.0; local_4 = 1.0; iVar9 = *piVar3; goto LAB_0896fdb8; } uVar11 = *puVar1; } else { uVar11 = *puVar1; } FUN_088e7114(uVar11,*(undefined4 *)(param_1 + 0x14),&local_4,&local_8); local_4 = local_4 * *pfVar5; fVar10 = local_8 + *pfVar7; if (1.0 < fVar10) { local_8 = 1.0; } else { local_8 = -1.0; if (-1.0 <= fVar10) { local_8 = fVar10; } } iVar9 = *piVar3; LAB_0896fdb8: if (iVar9 == 0x401000c4) { Sound::Play_Sound(*puVar4,local_4,*puVar6,local_8,0x3fb33333,*puVar8,0, *(int *)(param_1 + 0x14) + 0x60, *puVar3); } else { Sound::Play_Sound(*puVar4,local_4,*puVar6,local_8,0,*puVar8,0,*(int *)(param_1 + 0x14) + 0x60, *puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "pushmotion.html": {
    "href": "pushmotion.html",
    "title": "pushMotion",
    "keywords": "pushMotion Plays certain motion of a given object. Please describe difference from playMotion. Code Information Name: pushMotion Scope: Global PAC Instruction (Binary): 25 17 38 00 Assembly Address in Memory : 0x89148f4 Parameters (int *)handle_id (8 bytes) : The target handle. (int)action_id (8 bytes) : The Action ID to perform. (int)loop (8 bytes) : If it is 0, animation is played once and character is paused. Otherwise the animation loops. (float)offset (8 bytes) : Start offset of the animation. (Maybe 1.0 represents around 0.2sec) Usual hero animation offset length seems like around 6~10. Please tell more about this parameter. (float)delay (8 bytes) : Delay before starting the animation. This can be -1. Example Here is one example in hex: 25 17 38 00 / 04 00 00 00 / 0a 00 00 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 bf Which is interpreted as: pushMotion((int *)iVar10, (int)3, (int)1, (float)0, (float)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089148f4(int param_1,undefined4 param_2) { int *piVar1; undefined2 *puVar2; int *piVar3; undefined4 *puVar4; float *pfVar5; int iVar6; int iVar7; float fVar8; float fVar9; undefined local_c; char local_b; undefined local_a; undefined local_9; undefined4 local_8; uint local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined2 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); pfVar5 = (float *)Pac_Get_Param(param_2,4,1,4); if (*piVar1 != -1) { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar6 == 0) { iVar6 = 0; } if (((iVar6 != 0) && (iVar6 = *(int *)(iVar6 + 200), iVar6 != 0)) && (iVar7 = *(int *)(iVar6 + 0x1e8), iVar7 != 0)) { *(undefined *)(iVar6 + 0xb9) = 0; *(undefined *)(iVar7 + 0xb9) = 1; fVar9 = *pfVar5; local_8 = *puVar4; local_b = -(*piVar3 != 0); fVar8 = fVar9 * 4800.0; local_c = (undefined)*puVar2; if (fVar8 < 2.147484e+09) { local_4 = (uint)fVar8; } else { local_4 = (int)(fVar8 - 2.147484e+09) | 0xffff8000; } local_a = fVar9 < 0.0; local_9 = 1; if (fVar9 < 0.0) { local_4 = 0; } FUN_08981000(iVar7,&local_c); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "readarcfile.html": {
    "href": "readarcfile.html",
    "title": "readArcFile",
    "keywords": "readArcFile Warning Call requestActor after this, after loading equipment, character, gimmick or effect. Reads a resource file in a given file path. The path is relative to DATA_CMN or DATAMS, in DLC Mission, it can be relative to DLC Mission BND. For an actor, this loads model only, so requestActor might be required. Note that resource is loaded asynchrnously because reading them takes time, resulting bottleneck of the performance. Code Information Name: readArcFile Scope: Global PAC Instruction (Binary): 25 09 09 00 Assembly Address in Memory : 0x8948d9c Parameters (int)resource_type_id (8 bytes) : See the resource type table below. If not sure, set it to 2 (Loadinggroup_Scene). (String)resource_name : Resource name to read. ID Resource type 0x0 LoadingGroup_System 0x1 LoadingGroup_SystemLocalize 0x2 LoadingGroup_Scene 0x3 LoadingGroup_World 0x4 LoadingGroup_SceneLocal 0x5 LoadingGroup_Sound 0x6 LoadingGroup_Work 0x7 LoadingGroup_Work2 0x8 LoadingGroup_Work3 0x9 LoadingGroup_Test 0xA LoadingGroup_AzitoLocal 0xB (null) However, the table above does not need to be strictly followed. Remarks In current PAC instruction, 4 empty bytes follow after the readArcFile. Example Here is one example in hex: 25 09 09 00 / 02 00 00 00 / 0b 00 00 00 / 41 63 74 6f / 72 2f 43 68 / 61 72 61 2f / 63 68 72 30 / 32 5f 30 33 / 5f 30 30 32 / 2e 62 6e 64 / 00 00 00 00 Which is interpreted as: readArcFile((int)11, \"Actor/Chara/chr02_03_002.bnd\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948d9c(undefined4 param_1,undefined4 param_2) { char *pcVar1; undefined4 uVar2; uint uVar3; int iVar4; int iVar5; undefined4 *puVar6; char *pcVar7; undefined4 uVar8; char *pcVar9; undefined4 uVar10; code *pcVar11; undefined4 uVar12; char local_100 [256]; uVar2 = FUN_08842ef4(1); uVar3 = FUN_08843910(uVar2); iVar4 = FUN_08843900(uVar2); if (uVar3 <= (uint)(iVar4 >> 3)) { iVar4 = FUN_088438ec(uVar2); iVar5 = FUN_08843900(uVar2); if (iVar4 <= iVar5 + -0x10) { puVar6 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pcVar7 = &DAT_00000100; pcVar9 = local_100; pcVar1 = pcVar9; while (pcVar1 != (char *)0x0) { *pcVar9 = '\\0'; pcVar9 = pcVar9 + 1; pcVar7 = pcVar7 + -1; pcVar1 = pcVar7; } Pac_Get_StringParam(param_2,local_100); iVar4 = Syscall::strlen(local_100); if (iVar4 != 0) { uVar2 = FUN_08883830(local_100); iVar4 = FUN_08843148(local_100,uVar2); if (iVar4 != 0) { PAC::PAC_setCmdId(param_2,0); return; } uVar2 = FUN_0884a440(1); uVar12 = *puVar6; pcVar11 = FUN_08882250; uVar10 = 0; uVar8 = FUN_08873e20(local_100); iVar4 = Syscall::strcmp(uVar8,s_lbnd_08a60b80); if (iVar4 == 0) { pcVar11 = FUN_08883100; uVar10 = 0x800; } Data::Load_File_From_Bnd(uVar2,local_100,pcVar11,uVar12,uVar10,0,0,0,0,0); } PAC::PAC_setCmdId(param_2,0); } } return; }"
  },
  "readcachefile.html": {
    "href": "readcachefile.html",
    "title": "readCacheFile",
    "keywords": "readCacheFile Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: readCacheFile Scope: Global PAC Instruction (Binary): 25 09 0f 00 Assembly Address in Memory : 0x8949198 Parameters (undefined4)Var0 (8 bytes) (String)Var1 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949198(undefined4 param_1,undefined4 param_2) { char *pcVar1; undefined4 *puVar2; char *pcVar3; undefined4 uVar4; char *pcVar5; char local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pcVar3 = &DAT_00000100; pcVar5 = local_100; pcVar1 = pcVar5; while (pcVar1 != (char *)0x0) { *pcVar5 = '\\0'; pcVar5 = pcVar5 + 1; pcVar3 = pcVar3 + -1; pcVar1 = pcVar3; } Pac_Get_StringParam(param_2,local_100); uVar4 = FUN_0884a440(1); Data::Load_File_From_Bnd(uVar4,local_100,FUN_08882570,*puVar2,0x1000,0,0,0,0,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "readfileunit.html": {
    "href": "readfileunit.html",
    "title": "readFileUnit",
    "keywords": "readFileUnit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: readFileUnit Scope: Global PAC Instruction (Binary): 25 16 32 00 Assembly Address in Memory : 0x891cc20 Parameters This function is parameterless. Example Here is one example in hex: 25 16 32 00 Which is interpreted as: readFileUnit() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891cc20(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = FUN_08842ef4(1); iVar2 = FUN_08843888(uVar1,0); if (iVar2 == 0) { FUN_088a8f5c(); FUN_08843908(uVar1); PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "readsymbolmarkfile.html": {
    "href": "readsymbolmarkfile.html",
    "title": "readSymbolMarkFile",
    "keywords": "readSymbolMarkFile Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: readSymbolMarkFile Scope: Global PAC Instruction (Binary): 25 16 e0 00 Assembly Address in Memory : 0x892663c Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 e0 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: readSymbolMarkFile((int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892663c(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4, undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8) { undefined *puVar1; char *pcVar2; int *piVar3; undefined *puVar4; char *pcVar5; undefined *puVar6; char *pcVar7; int discpath; undefined4 uVar8; char local_140 [256]; undefined local_40 [64]; uVar8 = 4; piVar3 = (int *)Pac_Get_Param(param_2,0,1); discpath = *piVar3; puVar4 = (undefined *)0x40; puVar6 = local_40; puVar1 = puVar6; while (puVar1 != (undefined *)0x0) { *puVar6 = 0; puVar6 = puVar6 + 1; puVar4 = puVar4 + -1; puVar1 = puVar4; } if (discpath == -1) { Data::Load_from_path (local_40,s_TeamFlagMissionDefault_08a5fd70,0xffffffff,uVar8,param_5,param_6,param_7, param_8); } else { Data::Load_from_path (local_40,s_TeamFlagMission_04d_08a5fd88,discpath,uVar8,param_5,param_6,param_7, param_8); } pcVar5 = &DAT_00000100; pcVar7 = local_140; pcVar2 = pcVar7; while (pcVar2 != (char *)0x0) { *pcVar7 = '\\0'; pcVar7 = pcVar7 + 1; pcVar5 = pcVar5 + -1; pcVar2 = pcVar5; } Data::Load_from_path (local_140,s_Actor_Reload_TeamFlagMission__s__08a5fd4c,local_40,uVar8,param_5,param_6, param_7,param_8); uVar8 = FUN_0884a440(1); Data::Load_File_From_Bnd(uVar8,local_140,FUN_08882250,3,0,0,0,0,0,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "rebornsquad.html": {
    "href": "rebornsquad.html",
    "title": "rebornSquad",
    "keywords": "rebornSquad Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: rebornSquad Scope: Global PAC Instruction (Binary): 25 16 1a 01 Assembly Address in Memory : 0x8929eb8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) Example Here is one example in hex: 25 16 1a 01 / 04 00 00 00 / 2c 00 00 00 / 10 00 00 00 / 00 00 80 3f / 02 00 00 00 / 01 00 00 00 Which is interpreted as: rebornSquad((int *)iVar44, (float)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08929eb8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; int iVar4; int iVar5; int iVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); iVar6 = 0; if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) { iVar6 = iVar4; } if (iVar6 != 0) { FUN_088c5514(*puVar2,0x3e99999a,iVar6,0,*piVar3 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "reborntroop.html": {
    "href": "reborntroop.html",
    "title": "rebornTroop",
    "keywords": "rebornTroop Makes the player team reborn. This recovers only dead units and does not recover the stamina for the alive units. Code Information Name: rebornTroop Scope: Global PAC Instruction (Binary): 25 16 50 00 Assembly Address in Memory : 0x891e9a0 Parameters (int *)troop_handle (8 bytes) : Troop handle of the target to reborn. -1 reborns all player troops. (float)stamina_amount (8 bytes) : % amount of stamina to set when the unit is reborn. Expected 0~1. 0 will give 1 stamina. (bool)always_reborn (8 bytes) : Reborn even if the player is blocked from performing any command. Since the \"block command\" happens rarely, this can be kept 0. Note that the \"cannot perform command\" flag is different from disabling input, there is separate flag for the command performing. (bool)reborn_allies (8 bytes) : Recommended to set to 1. If this is set to 1, it reborns everyone in multi. Otherwise only self is reborn. Example Here is one example in hex: 25 16 50 00 / 02 00 00 00 / ff ff ff ff / 10 00 00 00 / 00 00 80 3f / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: rebornTroop((int)-1, (float)1, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e9a0(int param_1,undefined4 param_2) { char cVar1; int *piVar2; undefined4 *puVar3; int *piVar4; int *piVar5; int iVar6; undefined4 uVar7; uint uVar8; int iVar9; float *pfVar10; uint uVar11; int iVar12; undefined4 *****pppppuVar13; undefined4 *******pppppppuVar14; undefined4 ******ppppppuVar15; undefined4 *puVar16; float local_1d0; float local_1cc; float local_1c8; float local_1c4; int *local_1a4; int *local_1a0; undefined *local_19c; undefined auStack408 [388]; undefined *local_14; undefined4 *******local_10; undefined4 *******local_c; int **local_8; undefined4 local_4; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar4 = (int *)Pac_Get_Param(param_2,2,1,4); piVar5 = (int *)Pac_Get_Param(param_2,3,1,4); iVar12 = 0; if (*piVar2 == -1) { iVar6 = *(int *)(param_1 + 0x10); if (iVar6 == 0) { iVar6 = 0; } else { if (iVar6 == 0) { iVar6 = 0; } iVar6 = *(int *)(iVar6 + 0xf8); if (iVar6 == 0) { iVar6 = 0; } } if (iVar6 != 0) { iVar12 = FUN_088a8650(iVar6,0); } } else { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar2,1); if ((iVar6 != 0) && (iVar9 = (**(code **)(*(int *)(iVar6 + 4) + 0x34))(iVar6), iVar9 == 2)) { iVar12 = iVar6; } } if (iVar12 != 0) { uVar7 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar7,1); if ((*piVar5 == 0) || (iVar6 = Is_Multi(*(undefined4 *)(iVar6 + 100)), iVar6 == 0)) { FUN_088e3858(iVar12,0); FUN_088de0a0(*puVar3,0x3e99999a,iVar12,0,*piVar4 != 0); } else { FUN_088e3858(iVar12,0); local_19c = &DAT_08a840a0; local_14 = auStack408; local_8 = &local_1a4; piVar2 = (int *)(*(code *)PTR_FUN_08a840a8)(local_8); local_1a4 = piVar2; iVar6 = (**(code **)(local_19c + 0xc))(local_8); local_1a0 = piVar2 + (iVar6 + -1) * 3; piVar2[1] = (int)local_8; *local_1a0 = (int)local_8; uVar11 = 1; uVar8 = (**(code **)(local_19c + 0xc))(local_8); if (1 < uVar8) { do { *piVar2 = (int)(piVar2 + 3); piVar2[4] = (int)piVar2; uVar11 = uVar11 + 1; uVar8 = (**(code **)(local_19c + 0xc))(local_8); piVar2 = piVar2 + 3; } while (uVar11 < uVar8); } local_10 = &local_10; local_4 = 0; local_c = local_10; FUN_088dfd3c(iVar12,0xffffffff,&local_1a4); iVar6 = FUN_088e1fd0(iVar12,1); if ((undefined4 ********)local_10 != &local_10) { ppppppuVar15 = local_10[2]; pppppppuVar14 = local_10; while( true ) { pppppuVar13 = ppppppuVar15[0x285]; iVar9 = Is_Player_Dead(ppppppuVar15); if (iVar9 == 0) { pppppppuVar14 = (undefined4 *******)*pppppppuVar14; } else { pfVar10 = (float *)FUN_088b8f84(ppppppuVar15); local_1d0 = *pfVar10; local_1cc = pfVar10[1]; local_1c8 = pfVar10[2]; local_1c4 = pfVar10[3]; if (iVar6 != 0) { pfVar10 = (float *)offset__10(iVar6); local_1cc = pfVar10[1]; local_1c8 = pfVar10[2]; local_1c4 = pfVar10[3]; local_1d0 = *pfVar10 + (float)(int)*(short *)((int)pppppuVar13 + 0x32e) * (float)*(int *)(iVar12 + 0x288); } FUN_088c5514(*puVar3,0x3e99999a,pppppuVar13,&local_1d0,0); pppppuVar13 = ppppppuVar15[0x285]; puVar16 = pppppuVar13[4][9][0xb6][6]; cVar1 = (*(code *)pppppuVar13[1][0x58])(pppppuVar13); FUN_089c4324(puVar16,(int)cVar1,(int)*(char *)(pppppuVar13 + 0x61)); pppppppuVar14 = (undefined4 *******)*pppppppuVar14; } if ((undefined4 ********)pppppppuVar14 == &local_10) break; ppppppuVar15 = pppppppuVar14[2]; } } FUN_088de56c(&local_10,0); FUN_088de508(&local_1a4,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus02commondata.html": {
    "href": "receiveversus02commondata.html",
    "title": "receiveVersus02CommonData",
    "keywords": "receiveVersus02CommonData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus02CommonData Scope: Global PAC Instruction (Binary): 25 16 28 01 Assembly Address in Memory : 0x8927a40 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 16 28 01 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 0a 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: receiveVersus02CommonData((int)1, (int *)iVar10, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927a40(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0; iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar6 != 0) { if (*piVar1 == 1) { iVar5 = *piVar2; if ((iVar5 < 0) || (1 < iVar5)) { uVar4 = 0xffffffff; } else { uVar4 = *(undefined4 *)(iVar5 * 4 + *(int *)(iVar6 + 0x48) + 0x44); } *puVar3 = uVar4; } else if (*piVar1 == 0) { iVar5 = *piVar2; if ((iVar5 < 0) || (1 < iVar5)) { uVar4 = 0xffffffff; } else { uVar4 = *(undefined4 *)(iVar5 * 4 + *(int *)(iVar6 + 0x48) + 0x3c); } *puVar3 = uVar4; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus02enemyctrl.html": {
    "href": "receiveversus02enemyctrl.html",
    "title": "receiveVersus02EnemyCtrl",
    "keywords": "receiveVersus02EnemyCtrl Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus02EnemyCtrl Scope: Global PAC Instruction (Binary): 25 16 cc 00 Assembly Address in Memory : 0x8924904 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924904(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; int iVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); *puVar1 = 0; iVar7 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar7 != 0) && (*(char *)(*(int *)(iVar7 + 0x48) + 0x10) != '\\0')) { *puVar1 = 1; iVar6 = *(int *)(iVar7 + 0x48); *puVar2 = *(undefined4 *)(iVar6 + 0x14); *puVar3 = *(undefined4 *)(iVar6 + 0x18); *puVar4 = *(undefined4 *)(iVar6 + 0x1c); *puVar5 = *(undefined4 *)(iVar6 + 0x20); *(undefined *)(*(int *)(iVar7 + 0x48) + 0x10) = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus02missileinfo.html": {
    "href": "receiveversus02missileinfo.html",
    "title": "receiveVersus02MissileInfo",
    "keywords": "receiveVersus02MissileInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus02MissileInfo Scope: Global PAC Instruction (Binary): 25 16 ca 00 Assembly Address in Memory : 0x8924690 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (int)Var3 (8 bytes) (int)Var4 (8 bytes) Example Here is one example in hex: 25 16 ca 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 20 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: receiveVersus02MissileInfo((int *)iVar0, (int *)iVar1, (float *)fVar1, (int *)iVar2, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924690(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int *piVar4; int *piVar5; int iVar6; int iVar7; char *pcVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar6 != 0) { iVar7 = *piVar1; if ((iVar7 < 0) && (1 < iVar7)) { pcVar8 = (char *)0x0; } else { iVar6 = iVar7 * 0xc + *(int *)(iVar6 + 0x48); if (*(char *)(iVar6 + 0x25) == '\\x01') { *(undefined *)(iVar6 + 0x25) = 0; pcVar8 = (char *)(iVar6 + 0x24); } else { pcVar8 = (char *)0x0; } } if (pcVar8 == (char *)0x0) { *piVar1 = -1; *piVar2 = 0; *puVar3 = 0; *piVar4 = -1; *piVar5 = -1; } else { *piVar1 = (int)*pcVar8; *piVar2 = (int)*(short *)(pcVar8 + 2); *puVar3 = *(undefined4 *)(pcVar8 + 4); *piVar4 = (int)pcVar8[8]; *piVar5 = (int)pcVar8[9]; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus03enemyctrl.html": {
    "href": "receiveversus03enemyctrl.html",
    "title": "receiveVersus03EnemyCtrl",
    "keywords": "receiveVersus03EnemyCtrl Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus03EnemyCtrl Scope: Global PAC Instruction (Binary): 25 16 c6 00 Assembly Address in Memory : 0x89242d0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089242d0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; int iVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); *puVar1 = 0; iVar7 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar7 != 0) && (*(char *)(*(int *)(iVar7 + 0x58) + 0x34) != '\\0')) { *puVar1 = 1; iVar6 = *(int *)(iVar7 + 0x58); *puVar2 = *(undefined4 *)(iVar6 + 0x38); *puVar3 = *(undefined4 *)(iVar6 + 0x3c); *puVar4 = *(undefined4 *)(iVar6 + 0x40); *puVar5 = *(undefined4 *)(iVar6 + 0x44); *(undefined *)(*(int *)(iVar7 + 0x58) + 0x34) = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus03lastonegoal.html": {
    "href": "receiveversus03lastonegoal.html",
    "title": "receiveVersus03LastOneGoal",
    "keywords": "receiveVersus03LastOneGoal Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus03LastOneGoal Scope: Global PAC Instruction (Binary): 25 16 c8 00 Assembly Address in Memory : 0x8924490 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 c8 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: receiveVersus03LastOneGoal((int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924490(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar1 = 0; *puVar2 = 0; iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar3 != 0) { if (*(char *)(*(int *)(iVar3 + 0x58) + 0x48) == '\\0') { iVar3 = *(int *)(iVar3 + 0x58); } else { *puVar1 = 1; iVar3 = *(int *)(iVar3 + 0x58); } if (*(char *)(iVar3 + 0x49) != '\\0') { *puVar2 = 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus04commondata.html": {
    "href": "receiveversus04commondata.html",
    "title": "receiveVersus04CommonData",
    "keywords": "receiveVersus04CommonData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus04CommonData Scope: Global PAC Instruction (Binary): 25 16 2c 01 Assembly Address in Memory : 0x8927d34 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (uint)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927d34(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; uint *puVar3; uint uVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); *puVar3 = 0; iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar6 != 0) { iVar5 = *piVar1; if (iVar5 == 2) { *puVar3 = (uint)*(byte *)(*(int *)(iVar6 + 0x68) + 0xc4); } else if (iVar5 == 1) { iVar5 = *piVar2; if ((iVar5 < 0) || (1 < iVar5)) { uVar4 = 0xffffffff; } else { uVar4 = *(uint *)(iVar5 * 4 + *(int *)(iVar6 + 0x68) + 0xbc); } *puVar3 = uVar4; } else if (iVar5 == 0) { *puVar3 = *(uint *)(*(int *)(iVar6 + 0x68) + 0xb8); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus04knockoutinfo.html": {
    "href": "receiveversus04knockoutinfo.html",
    "title": "receiveVersus04KnockOutInfo",
    "keywords": "receiveVersus04KnockOutInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus04KnockOutInfo Scope: Global PAC Instruction (Binary): 25 16 ea 00 Assembly Address in Memory : 0x8924a9c Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924a9c(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; char *pcVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); *piVar2 = -1; *puVar3 = 0xffffffff; iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar4 != 0) && (iVar4 = *(int *)(iVar4 + 0x68) + 0x10, iVar4 != 0)) { iVar5 = *piVar1; if (iVar5 < 0) { pcVar6 = (char *)0x0; } else if (iVar5 < 8) { pcVar6 = (char *)(iVar4 + iVar5 * 8 + 4); } else { pcVar6 = (char *)0x0; } if (pcVar6 != (char *)0x0) { *piVar2 = (int)*pcVar6; *puVar3 = *(undefined4 *)(pcVar6 + 4); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus04panelaction.html": {
    "href": "receiveversus04panelaction.html",
    "title": "receiveVersus04PanelAction",
    "keywords": "receiveVersus04PanelAction Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus04PanelAction Scope: Global PAC Instruction (Binary): 25 16 fa 00 Assembly Address in Memory : 0x8924cf8 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (int)Var4 (8 bytes) (int)Var5 (8 bytes) (int)Var6 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924cf8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; int *piVar4; int *piVar5; int *piVar6; int *piVar7; int iVar8; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); piVar7 = (int *)Pac_Get_Param(param_2,6,1,4); *piVar2 = -1; *piVar3 = -1; *piVar4 = 0; *piVar5 = 0; *piVar6 = 0; *piVar7 = 0; iVar8 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (((iVar8 != 0) && (iVar8 = *(int *)(iVar8 + 0x68), iVar8 != 0)) && (iVar8 = FUN_089f030c(iVar8,*puVar1), iVar8 != 0)) { *piVar2 = (int)*(char *)(iVar8 + 1); *piVar3 = (int)*(short *)(iVar8 + 2); *piVar4 = (int)*(char *)(iVar8 + 4); *piVar5 = (int)*(char *)(iVar8 + 5); *piVar6 = (int)*(short *)(iVar8 + 6); *piVar7 = (int)*(short *)(iVar8 + 8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus04panelswap.html": {
    "href": "receiveversus04panelswap.html",
    "title": "receiveVersus04PanelSwap",
    "keywords": "receiveVersus04PanelSwap Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus04PanelSwap Scope: Global PAC Instruction (Binary): 25 16 fe 00 Assembly Address in Memory : 0x8924f24 Parameters (uint...)Vars0 (>= 8 bytes) ... means any amounts of parameter. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924f24(int param_1,undefined4 param_2) { uint *puVar1; uint **ppuVar2; int iVar3; byte local_28; byte local_27; byte local_26; byte local_25; byte local_24; byte local_23; byte local_22; byte local_21; uint *local_20 [4]; uint *local_10; uint *local_c; uint *local_8; uint *local_4; iVar3 = 0; ppuVar2 = local_20; do { puVar1 = (uint *)Pac_Get_Param(param_2,iVar3,1,4); *ppuVar2 = puVar1; *puVar1 = 0xffffffff; iVar3 = iVar3 + 1; ppuVar2 = ppuVar2 + 1; } while (iVar3 < 8); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (((iVar3 != 0) && (iVar3 = *(int *)(iVar3 + 0x68), iVar3 != 0)) && (*(char *)(iVar3 + 0xa8) != '\\0')) { FUN_089f03a8(iVar3,&local_28); *local_20[0] = (uint)local_28; *local_20[1] = (uint)local_27; *local_20[2] = (uint)local_26; *local_20[3] = (uint)local_25; *local_10 = (uint)local_24; *local_c = (uint)local_23; *local_8 = (uint)local_22; *local_4 = (uint)local_21; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "receiveversus04requestwave.html": {
    "href": "receiveversus04requestwave.html",
    "title": "receiveVersus04RequestWave",
    "keywords": "receiveVersus04RequestWave Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: receiveVersus04RequestWave Scope: Global PAC Instruction (Binary): 25 16 1e 01 Assembly Address in Memory : 0x892a18c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a18c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); *puVar1 = 0xffffffff; if (iVar2 != 0) { *puVar1 = *(undefined4 *)(*(int *)(iVar2 + 0x68) + 0xb4); *(undefined4 *)(*(int *)(iVar2 + 0x68) + 0xb4) = 0xffffffff; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "recoveryhp.html": {
    "href": "recoveryhp.html",
    "title": "recoveryHP",
    "keywords": "recoveryHP Fully recovers stamina of a given target. Code Information Name: recoveryHP Scope: Global PAC Instruction (Binary): 25 16 4e 00 Assembly Address in Memory : 0x891e7d0 Parameters (int *)handle_id (8 bytes) : Unit/Squad/troop handle, obtained from e.g. getUnitHandle or getUnitSquadHandle. Example Here is one example in hex: 25 16 4e 00 / 08 00 00 00 / 68 00 00 00 Which is interpreted as: recoveryHP(((global)int *)giVar104) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e7d0(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar2 != 0) { iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2); if (iVar3 == 9) { //single unit Damage::Heal::HealOne(0x3f800000,iVar2); } else if (iVar3 == 3) { //squad Damage::Heal::HealAll2(0x3f800000,iVar2); } else if (iVar3 == 2) { //troop Damage::Heal::HealAll(0x3f800000,iVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "recoveryhpratio.html": {
    "href": "recoveryhpratio.html",
    "title": "recoveryHPRatio",
    "keywords": "recoveryHPRatio Recovers stamina of a given target for a given percentage of amount. Code Information Name: recoveryHPRatio Scope: Global PAC Instruction (Binary): 25 16 4f 00 Assembly Address in Memory : 0x891e8ac Parameters (int *)handle_id (8 bytes) : Unit/Squad/Troop handle, obtained from e.g. getUnitHandle or getUnitSquadHandle. (float)amount_percentage (8 bytes) : Recovery amount as percentage, in range of 0~1. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e8ac(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 != 0) { iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); if (iVar4 == 9) { Damage::Heal::HealOne(*puVar2,iVar3); } else if (iVar4 == 3) { Damage::Heal::HealAll2(*puVar2,iVar3); } else if (iVar4 == 2) { Damage::Heal::HealAll(*puVar2,iVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "recoveryplayertroophp.html": {
    "href": "recoveryplayertroophp.html",
    "title": "recoveryPlayerTroopHP",
    "keywords": "recoveryPlayerTroopHP Fully recovers every unit in the player team. Code Information Name: recoveryPlayerTroopHP Scope: Global PAC Instruction (Binary): 25 16 4c 00 Assembly Address in Memory : 0x891e6ac Parameters This function is parameterless. Example Here is one example in hex: 25 16 4c 00 Which is interpreted as: recoveryPlayerTroopHP() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e6ac(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(param_1 + 0x10); if (iVar1 == 0) { iVar1 = 0; } else { if (iVar1 == 0) { iVar1 = 0; } iVar1 = *(int *)(iVar1 + 0xf8); if (iVar1 == 0) { iVar1 = 0; } } if ((iVar1 != 0) && (iVar1 = FUN_088a8650(iVar1,0), iVar1 != 0)) { Damage::Heal::HealAll(0x3f800000,iVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "recoveryplayertroophpratio.html": {
    "href": "recoveryplayertroophpratio.html",
    "title": "recoveryPlayerTroopHPRatio",
    "keywords": "recoveryPlayerTroopHPRatio Recovers certain percentage of stamina of every unit in the player team. Code Information Name: recoveryPlayerTroopHPRatio Scope: Global PAC Instruction (Binary): 25 16 4d 00 Assembly Address in Memory : 0x891e728 Parameters (float)heal_ratio (8 bytes) : Amount to recover as %. expected 0~1. Example Here is one example in hex: 25 16 4d 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: recoveryPlayerTroopHPRatio((float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e728(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0xf8); if (iVar2 == 0) { iVar2 = 0; } } if ((iVar2 != 0) && (iVar2 = FUN_088a8650(iVar2,0), iVar2 != 0)) { Damage::Heal::HealAll(*puVar1,iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "recvmonsterinfoaction.html": {
    "href": "recvmonsterinfoaction.html",
    "title": "recvMonsterInfoAction",
    "keywords": "recvMonsterInfoAction Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: recvMonsterInfoAction Scope: Global PAC Instruction (Binary): 25 21 2c 00 Assembly Address in Memory : 0x89b3d48 Parameters (undefined4)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Here is one example in hex: 25 21 2c 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: recvMonsterInfoAction((int *)iVar20, (int *)iVar0, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3d48(undefined4 param_1,undefined4 param_2) { undefined uVar1; undefined4 *puVar2; undefined4 uVar3; undefined4 uVar4; int iVar5; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = Pac_Get_Param(param_2,1,1,4); uVar4 = Pac_Get_Param(param_2,2,1,4); iVar5 = FUN_089b12c4(param_1,*puVar2); if (iVar5 != 0) { uVar1 = FUN_0896dca4(iVar5,uVar3,uVar4); FUN_0883c04c(param_2,uVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "recvmonsterinfostate.html": {
    "href": "recvmonsterinfostate.html",
    "title": "recvMonsterInfoState",
    "keywords": "recvMonsterInfoState Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: recvMonsterInfoState Scope: Global PAC Instruction (Binary): 25 21 2e 00 Assembly Address in Memory : 0x89b3e98 Parameters (undefined4)Var0 (8 bytes) (Undefined)Var1 (8 bytes) Example Here is one example in hex: 25 21 2e 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: recvMonsterInfoState((int *)iVar20, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3e98(undefined4 param_1,undefined4 param_2) { undefined uVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = Pac_Get_Param(param_2,1,1,4); iVar4 = FUN_089b12c4(param_1,*puVar2); if (iVar4 != 0) { uVar1 = FUN_0896dd08(iVar4,uVar3); FUN_0883c04c(param_2,uVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "reflectqcompdatatocompdata.html": {
    "href": "reflectqcompdatatocompdata.html",
    "title": "reflectQCompDataToCompData",
    "keywords": "reflectQCompDataToCompData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: reflectQCompDataToCompData Scope: Azito PAC Instruction (Binary): 25 1c 17 00 Assembly Address in Memory : 0x8b4f0a8 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 1c 17 00 / 04 00 00 00 / 41 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: reflectQCompDataToCompData((int *)iVar65, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f0a8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; int iVar5; undefined4 uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar6 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar2; iVar3 = FUN_Azito__08b5a618(*(undefined4 *) (*(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14) + 0x38),2,uVar6,1); if (iVar3 != 0) { uVar6 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar6,1); if (iVar5 == 0) { iVar5 = *(int *)(iVar4 + 0x44) + 2000; } else { iVar5 = *(int *)(iVar4 + 0x44) + 0x788; } FUN_08a15674(iVar5,*(undefined4 *)(iVar3 + 0xb8)); if (-1 < *(int *)(iVar3 + 0xbc)) { FUN_08a15550(iVar5,*(int *)(iVar3 + 0xbc),*(undefined4 *)(iVar3 + 0xc0)); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "reflectweather.html": {
    "href": "reflectweather.html",
    "title": "reflectWeather",
    "keywords": "reflectWeather Please describe what this does. Potentially visual related, but there is no visible difference. Code Information Name: reflectWeather Scope: Global PAC Instruction (Binary): 25 16 78 00 Assembly Address in Memory : 0x8920e04 Parameters (float)reflect_scale (8 bytes) : Usually this is 3~4. Do not put 0. Example Here is one example in hex: 25 16 78 00 / 10 00 00 00 / 00 00 80 40 Which is interpreted as: reflectWeather((float)4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920e04(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_08900678(*puVar1,iVar2 + 0x1b0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "registconstgimmick.html": {
    "href": "registconstgimmick.html",
    "title": "registConstGimmick",
    "keywords": "registConstGimmick Defines a structure gimmick. This also can be a spawn point. Code Information Name: registConstGimmick Scope: Global PAC Instruction (Binary): 25 16 bf 00 Assembly Address in Memory : 0x8923ddc Parameters (int)gimmick_id (8 bytes) : ID of the gimmick, from generatorparam. If it is not a gimmick, the game will crash (int)level (8 bytes) : Level of the gimmick. (int)troop_type (8 bytes) : Troop type of the gimmick. (int)x_pos (8 bytes) : X position of the gimmick, as PSP pixels. (int)y_pos (8 bytes) : Y position of the gimmick, as PSP pixels. (int)z_index (8 bytes) : Render priority, the higher the value is, the more top the gimmick is. usually 0~1 is normal value. (bool)Var6 (8 bytes) : Boolean, please describe what this does. Might be visual related. (bool)Var7 (8 bytes) : Boolean, please describe what this does. (bool)Var8 (8 bytes) : Boolean, please describe what this does. (int)itemtable_id (8 bytes) : Item table ID to give as reward, when gimmick is destroyed. (int)gimmick_identifier (8 bytes) : Unique Id to register. If this is not used, keep -1. Can be used with e.g. setModeEx, gimmick_getHandle. Example Here is one example in hex: 25 16 bf 00 / 02 00 00 00 / 17 01 00 00 / 08 00 00 00 / 32 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / dc 05 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 90 01 00 00 / 02 00 00 00 / a0 86 01 00 Which is interpreted as: registConstGimmick((int)279, ((global)int *)giVar50, (int)1, (int)1500, (int)0, (int)0, (int)1, (int)1, (int)0, (int)400, (int)100000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923ddc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; int *piVar5; undefined4 *puVar6; undefined4 *puVar7; undefined4 *puVar8; undefined4 *puVar9; undefined4 *puVar10; undefined4 *puVar11; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); puVar9 = (undefined4 *)Pac_Get_Param(param_2,8,1,4); puVar10 = (undefined4 *)Pac_Get_Param(param_2,9,1,4); puVar11 = (undefined4 *)Pac_Get_Param(param_2,10,1,4); FUN_089f05bc((float)*piVar4,(float)*piVar5,*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x7e44, *puVar1,*puVar2,*puVar3,*puVar6,*puVar7,*puVar8,*puVar9,*puVar10,*puVar11); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "releaselink.html": {
    "href": "releaselink.html",
    "title": "releaseLink",
    "keywords": "releaseLink Detach an object from its parent node. Code Information Name: releaseLink Scope: Global PAC Instruction (Binary): 25 17 1d 00 Assembly Address in Memory : 0x8912b2c Parameters (int *)handle_id (8 bytes) : The target handle of the attached object. Example Here is one example in hex: 25 17 1d 00 / 04 00 00 00 / 0d 00 00 00 Which is interpreted as: releaseLink((int *)iVar13) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912b2c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar2 == 0) { iVar2 = 0; } if (iVar2 != 0) { FUN_0887ddd0(iVar2,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "replaceactivitytable.html": {
    "href": "replaceactivitytable.html",
    "title": "replaceActivityTable",
    "keywords": "replaceActivityTable Overwrites squadactivityparam ID in squadlineparam. Code Information Name: replaceActivityTable Scope: Global PAC Instruction (Binary): 25 16 25 01 Assembly Address in Memory : 0x892a740 Parameters (int *)squad_handle (8 bytes) : The squad handle to change the action. (int)from_id (8 bytes) : The target squadactivityparam ID that will be changed. (int)to_id (8 bytes) : The desired squadactivityparam ID. Example Here is one example in hex: 25 16 25 01 / 04 00 00 00 / 18 00 00 00 / 02 00 00 00 / f2 03 00 00 / 02 00 00 00 / f4 03 00 00 Which is interpreted as: replaceActivityTable((int *)iVar24, (int)1010, (int)1012) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a740(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) && (iVar4 + 0x1f0 != 0)) { Action::Overwrite_SquadlineAction(iVar4 + 0x1f0,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "requestactor.html": {
    "href": "requestactor.html",
    "title": "requestActor",
    "keywords": "requestActor Gets actor of the certain resources, after loading equipment, character, gimmick or effect with readArcFile. This instruction connects to the actual param, while readArcFile loads models without the param information. If the resource is not an actor (e.g. item like pink jewelled chest, stage, sound etc), this is not necesary. Code Information Name: requestActor Scope: Global PAC Instruction (Binary): 25 0a 17 00 Assembly Address in Memory : 0x894aab8 Parameters (int)actor_type (8 bytes) : Actor Type, 5 is Equipment, 9 is Character, A is Gimmick, and B is Effect. (int)actor_id (8 bytes) : ID of the actor. actor_type 0x5: weaponparam actor_type 0x9: charaparam actor_type0xA: gimmickparam actor_type0xB: effectparam If the actor type is none of the above, it probably does not require this instruction. (undefined4)Var2 (8 bytes) : Keep as -1 if it is not a weapon. Otherwise keep 0. (undefined4)Var3 (8 bytes) : Keep as -1 if it is not a weapon. Otherwise keep 0. Remarks This is related to resource loading and does not create any object. Creating object in different mission phase is required for making object instance. Example Here is one example in hex: 25 0a 17 00 / 02 00 00 00 / 0a 00 00 00 / 02 00 00 00 / b1 02 00 00 / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / ff ff ff ff Which is interpreted as: requestActor((int)10, (int)689, (int)-1, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894aab8(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 uVar3; int iVar4; undefined2 *puVar5; int iVar6; undefined4 uVar7; undefined4 uVar8; int iVar9; undefined4 uVar10; undefined2 local_8; undefined2 local_6; undefined2 local_4; undefined2 local_2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar9 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar10 = *puVar2; puVar2 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar8 = *puVar2; puVar2 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar7 = *puVar2; uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,0); iVar6 = *(int *)(iVar4 + 0xa4); local_4 = (undefined2)uVar8; local_2 = (undefined2)uVar7; local_6 = (undefined2)uVar10; local_8 = (undefined2)iVar9; iVar4 = FUN_08a0ea54(iVar6,&local_8); if (iVar4 == 0) { if (iVar9 == 0xb) { iVar4 = *(int *)(iVar6 + 0x10888); } else { if (((iVar9 != 10) && (iVar9 != 5)) && (iVar9 != 9)) goto LAB_0894ac60; iVar4 = *(int *)(iVar6 + 0x10888); } if (iVar4 == 0x120) { iVar4 = *(int *)(iVar6 + 0x11194); } else { puVar5 = (undefined2 *)(*(int *)(iVar6 + 0x10884) + iVar4 * 8); if (puVar5 == (undefined2 *)0x0) { iVar4 = *(int *)(iVar6 + 0x10888); } else { *puVar5 = local_8; puVar5[1] = local_6; puVar5[2] = local_4; puVar5[3] = local_2; iVar4 = *(int *)(iVar6 + 0x10888); } *(int *)(iVar6 + 0x10888) = iVar4 + 1; iVar4 = *(int *)(iVar6 + 0x11194); } if (iVar4 != 0x120) { puVar5 = (undefined2 *)(*(int *)(iVar6 + 0x11190) + iVar4 * 8); if (puVar5 == (undefined2 *)0x0) { iVar4 = *(int *)(iVar6 + 0x11194); } else { *puVar5 = local_8; puVar5[1] = local_6; puVar5[2] = local_4; puVar5[3] = local_2; iVar4 = *(int *)(iVar6 + 0x11194); } *(int *)(iVar6 + 0x11194) = iVar4 + 1; } } LAB_0894ac60: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "requestexpandparam.html": {
    "href": "requestexpandparam.html",
    "title": "requestExpandParam",
    "keywords": "requestExpandParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: requestExpandParam Scope: Global PAC Instruction (Binary): 25 0a 18 00 Assembly Address in Memory : 0x894ac88 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 0a 18 00 / 02 00 00 00 / 09 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: requestExpandParam((int)9, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894ac88(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; undefined4 uVar4; undefined4 uVar5; undefined2 local_8; undefined2 local_6; undefined2 local_4; undefined2 local_2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar5 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar1; uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,0); uVar2 = *(undefined4 *)(iVar3 + 0xa4); local_8 = (undefined2)uVar5; local_6 = (undefined2)uVar4; local_4 = 0; local_2 = 0; FUN_08a0eaec(uVar2,&local_8); FUN_08a0d7fc(uVar2,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "reset.html": {
    "href": "reset.html",
    "title": "reset",
    "keywords": "reset Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: reset Scope: Global PAC Instruction (Binary): 25 20 02 00 Assembly Address in Memory : 0x89b0e28 Parameters This function is parameterless. Example Here is one example in hex: 25 20 02 00 Which is interpreted as: reset() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b0e28(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x14) != 0) { FUN_0898e004(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetabnormal.html": {
    "href": "resetabnormal.html",
    "title": "resetAbnormal",
    "keywords": "resetAbnormal Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resetAbnormal Scope: Global PAC Instruction (Binary): 25 21 20 00 Assembly Address in Memory : 0x89b3554 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3554(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { (**(code **)(*(int *)(iVar2 + 0xc) + 0x30))(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetattackuniqueid.html": {
    "href": "resetattackuniqueid.html",
    "title": "resetAttackUniqueId",
    "keywords": "resetAttackUniqueId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resetAttackUniqueId Scope: Global PAC Instruction (Binary): 25 17 19 00 Assembly Address in Memory : 0x89125c0 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 17 19 00 / 04 00 00 00 / 40 00 00 00 Which is interpreted as: resetAttackUniqueId((int *)iVar64) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089125c0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { uVar2 = FUN_08875ca8(); *(undefined4 *)(iVar3 + 0x100) = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetcollisionshapebox.html": {
    "href": "resetcollisionshapebox.html",
    "title": "resetCollisionShapeBox",
    "keywords": "resetCollisionShapeBox Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Effect only. Code Information Name: resetCollisionShapeBox Scope: Global PAC Instruction (Binary): 25 21 26 00 Assembly Address in Memory : 0x89b3928 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Here is one example in hex: 25 21 26 00 / 08 00 00 00 / 37 01 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 80 3f Which is interpreted as: resetCollisionShapeBox(((global)int *)giVar311, (float)0, (float)0, (float)1, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3928(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; int iVar7; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); iVar6 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar6 != 0) && (iVar7 = (**(code **)(*(int *)(iVar6 + 4) + 0x34))(iVar6), iVar7 == 0xb)) && (iVar6 = FUN_088dcfcc(*(undefined4 *)(iVar6 + 0xd0)), iVar6 != 0)) { local_c = *puVar5; local_10 = *puVar4; local_4 = *puVar3; local_8 = *puVar2; FUN_0886f4dc(iVar6,&local_8,&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetgateinfo.html": {
    "href": "resetgateinfo.html",
    "title": "resetGateInfo",
    "keywords": "resetGateInfo Resets the gate info setup done by setGateInfo. Code Information Name: resetGateInfo Scope: Global PAC Instruction (Binary): 25 16 bc 00 Assembly Address in Memory : 0x8923b90 Parameters This function is parameterless. Example Here is one example in hex: 25 16 bc 00 Which is interpreted as: resetGateInfo() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923b90(int param_1,undefined4 param_2) { FUN_088b2448(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetobject.html": {
    "href": "resetobject.html",
    "title": "resetObject",
    "keywords": "resetObject Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resetObject Scope: Global PAC Instruction (Binary): 25 21 21 00 Assembly Address in Memory : 0x89b35c4 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 21 21 00 / 04 00 00 00 / 14 00 00 00 Which is interpreted as: resetObject((int *)iVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b35c4(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { FUN_08976b48(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetquestparam.html": {
    "href": "resetquestparam.html",
    "title": "resetQuestParam",
    "keywords": "resetQuestParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resetQuestParam Scope: Azito PAC Instruction (Binary): 25 1c 16 00 Assembly Address in Memory : 0x8b4ee90 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (Int/Float)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4ee90(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; float *pfVar3; uint uVar4; int iVar5; int iVar6; float fVar7; int iVar8; undefined4 uVar9; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar9 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar8 = *piVar2; pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_ParamType(param_2,2); if (((*(int *)(param_1 + 0x10) != 0) && (iVar5 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar5 != 0)) && (iVar5 = FUN_Azito__08b5a618(*(undefined4 *)(iVar5 + 0x38),2,uVar9,1), iVar5 != 0)) { iVar6 = Save::Get_Save_BaseAddr(1); if (iVar8 == 4) { if ((uVar4 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } *(float *)(iVar5 + 0xc0) = fVar7; } else if (iVar8 == 3) { if ((uVar4 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } *(float *)(iVar5 + 0xbc) = fVar7; } else if (iVar8 == 2) { if ((uVar4 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } *(float *)(iVar5 + 0xb8) = fVar7; } else if (iVar8 == 1) { if ((uVar4 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } uVar9 = FUN_Azito__08b50680(param_1); uVar9 = Message::Get_Message(iVar6 + 0x98,uVar9,fVar7); *(undefined4 *)(iVar5 + 0xb4) = uVar9; } else if (iVar8 == 0) { if ((uVar4 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } uVar9 = FUN_Azito__08b50680(param_1); uVar9 = Message::Get_Message(iVar6 + 0x98,uVar9,fVar7); *(undefined4 *)(iVar5 + 0xb0) = uVar9; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetquestpay.html": {
    "href": "resetquestpay.html",
    "title": "resetQuestPay",
    "keywords": "resetQuestPay Resets all quest finishing reward (setQuestPayExp, setQuestPayItem) Code Information Name: resetQuestPay Scope: Global PAC Instruction (Binary): 25 16 d4 00 Assembly Address in Memory : 0x8925f18 Parameters This function is parameterless. Example Here is one example in hex: 25 16 d4 00 Which is interpreted as: resetQuestPay() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925f18(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Get_Some_Flag(1); iVar1 = *(int *)(iVar1 + 0x44); FUN_08a15500(iVar1 + 0x788); FUN_08a15500(iVar1 + 2000); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resetstageparam.html": {
    "href": "resetstageparam.html",
    "title": "resetStageParam",
    "keywords": "resetStageParam World map related. Resets part of the current mission information when snaps out from the mission barracks. Code Information Name: resetStageParam Scope: Azito PAC Instruction (Binary): 25 1c 15 00 Assembly Address in Memory : 0x8b4ec18 Parameters (undefined4)Var0 (8 bytes) (int)param_type (8 bytes) : Expected 0~6. 0 description message, 1 title message. Please describe what others mean. (Int/Float)Var2 (8 bytes) : Value to set. Example Here is one example in hex: 25 1c 15 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 05 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: resetStageParam((int)1, (int)5, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4ec18(int param_1,undefined4 param_2) { undefined4 *puVar1; float *pfVar2; uint uVar3; int iVar4; int iVar5; int iVar6; float fVar7; undefined4 uVar8; undefined4 uVar9; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar8 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar9 = *puVar1; pfVar2 = (float *)Pac_Get_Param(param_2,2,1,4); uVar3 = Pac_Get_ParamType(param_2,2); iVar4 = FUN_0883bc1c(param_2); if (((*(int *)(param_1 + 0x10) != 0) && (iVar5 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar5 != 0)) && (iVar5 = FUN_Azito__08b5a618(*(undefined4 *)(iVar5 + 0x38),1,uVar8,1), iVar5 != 0)) { iVar6 = Save::Get_Save_BaseAddr(1); switch(uVar9) { case 0: if ((uVar3 & 0x70) == 0) { fVar7 = *pfVar2; } else { fVar7 = (float)(int)*pfVar2; } uVar8 = FUN_Azito__08b50680(param_1); uVar8 = Message::Get_Message(iVar6 + 0x98,uVar8,fVar7); *(undefined4 *)(iVar5 + 0xbc) = uVar8; break; case 1: if ((uVar3 & 0x70) == 0) { fVar7 = *pfVar2; } else { fVar7 = (float)(int)*pfVar2; } uVar8 = FUN_Azito__08b50680(param_1); uVar8 = Message::Get_Message(iVar6 + 0x98,uVar8,fVar7); *(undefined4 *)(iVar5 + 0xc0) = uVar8; break; case 2: if ((uVar3 & 0x70) == 0) { fVar7 = *pfVar2; } else { fVar7 = (float)(int)*pfVar2; } *(float *)(iVar5 + 0xd4) = fVar7; break; case 3: if ((uVar3 & 0x70) == 0) { fVar7 = (float)(int)*pfVar2; } else { fVar7 = *pfVar2; } *(float *)(iVar5 + 0xd8) = fVar7; break; case 4: if ((uVar3 & 0x70) == 0) { fVar7 = (float)(int)*pfVar2; } else { fVar7 = *pfVar2; } *(float *)(iVar5 + 0xdc) = fVar7; break; case 5: if ((uVar3 & 0x70) == 0) { fVar7 = *pfVar2; } else { fVar7 = (float)(int)*pfVar2; } *(bool *)(iVar5 + 0xe0) = fVar7 != 0.0; break; case 6: if ((uVar3 & 0x70) == 0) { fVar7 = *pfVar2; } else { fVar7 = (float)(int)*pfVar2; } *(int *)(iVar5 + 0xac) = iVar4 + (int)fVar7; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resettips.html": {
    "href": "resettips.html",
    "title": "resetTips",
    "keywords": "resetTips Resets the current tip status, does not reset with tip album. Code Information Name: resetTips Scope: Global PAC Instruction (Binary): 25 0a 1f 00 Assembly Address in Memory : 0x894b504 Parameters (Undefined)Var0 (8 bytes) : Only -1 is observed. Example Here is one example in hex: 25 0a 1f 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: resetTips((int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b504(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 uVar2; Pac_Get_Param(param_2,0,1,4); uVar1 = FUN_08a16cc8(1); uVar2 = Add_New_Tips(); FUN_08a18184(uVar1,uVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "restartmission.html": {
    "href": "restartmission.html",
    "title": "restartMission",
    "keywords": "restartMission Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: restartMission Scope: Global PAC Instruction (Binary): 25 12 05 00 Assembly Address in Memory : 0x8a1d1e4 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 12 05 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: restartMission((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d1e4(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x540) = *puVar1; *(undefined *)(*(int *)(param_1 + 0x10) + 0x14a0) = 1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultboxitemget.html": {
    "href": "resultboxitemget.html",
    "title": "resultBoxItemGet",
    "keywords": "resultBoxItemGet Gets the chest information of the chest before deciding an item. Called through resultBoxItemLabel. This is called in start of the item drop logic, before setting the dropped item from the chest. See also: How To:Set Item Drops. Code Information Name: resultBoxItemGet Scope: Global PAC Instruction (Binary): 25 16 69 00 Assembly Address in Memory : 0x89205e8 Parameters (int *)chest_type (8 bytes) : The type of the chest. 0 is Wooden, 1 is Iron, 2 is Gold, 3 is Jewel, 4 is Pink. -1 if the chest is invalid. (int *)chest_index (8 bytes) : Index of the chest, starts from 1. (int *)chest_level (8 bytes) : Level of the chest. Example Here is one example in hex: 25 16 69 00 / 04 00 00 00 / 0a 00 00 00 / 04 00 00 00 / 0b 00 00 00 / 04 00 00 00 / 0c 00 00 00 Which is interpreted as: resultBoxItemGet((int *)iVar10, (int *)iVar11, (int *)iVar12) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089205e8(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; uVar1 = Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_Param(param_2,2,1,4); uVar4 = FUN_08a50110(1); Loot::Save_ChestData(uVar4,uVar1,uVar2,uVar3); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultboxitemlabel.html": {
    "href": "resultboxitemlabel.html",
    "title": "resultBoxItemLabel",
    "keywords": "resultBoxItemLabel Call specific instructions (chest item drop logic) when player goes hideout with chests. This is called per chest. For detail, check How To:Set Item Drops. This is part of the starting logic, which means it lies before MissionTimmingScript. Code Information Name: resultBoxItemLabel Scope: Global PAC Instruction (Binary): 25 16 68 00 Assembly Address in Memory : 0x8920570 Parameters (index)address (8 bytes) : Address in the PAC instruction file. Example Here is one example in hex: 25 16 68 00 / 01 00 00 00 / f8 df 00 00 Which is interpreted as: resultBoxItemLabel((index)57336) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920570(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 *puVar2; undefined4 uVar3; uVar1 = FUN_0883bc1c(param_2); puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = FUN_08a50110(1); FUN_08a50188(uVar3,uVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultboxitemset.html": {
    "href": "resultboxitemset.html",
    "title": "resultBoxItemSet",
    "keywords": "resultBoxItemSet Settles the item drop from the chest. The item data is decided from getAppearItem. Code Information Name: resultBoxItemSet Scope: Global PAC Instruction (Binary): 25 16 6a 00 Assembly Address in Memory : 0x8920690 Parameters (int)item_id (8 bytes) : The item ID to drop in the current chest. (int)item_level (8 bytes) : Level of the item to drop in the current chest. Example Here is one example in hex: 25 16 6a 00 / 04 00 00 00 / 0d 00 00 00 / 04 00 00 00 / 0e 00 00 00 Which is interpreted as: resultBoxItemSet((int *)iVar13, (int *)iVar14) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920690(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 uVar2; undefined4 uVar3; uVar1 = Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = FUN_08a50110(1); FUN_08a501cc(uVar3,uVar1,uVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultgetchange.html": {
    "href": "resultgetchange.html",
    "title": "resultGetChange",
    "keywords": "resultGetChange Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resultGetChange Scope: Global PAC Instruction (Binary): 25 16 1a 00 Assembly Address in Memory : 0x891a970 Parameters (int)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a970(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); *piVar1 = (int)*(char *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c) + 0x1a7); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultgetchangeparam.html": {
    "href": "resultgetchangeparam.html",
    "title": "resultGetChangeParam",
    "keywords": "resultGetChangeParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resultGetChangeParam Scope: Global PAC Instruction (Binary): 25 16 18 00 Assembly Address in Memory : 0x891a64c Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) (Undefined)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a64c(int param_1,undefined4 param_2) { undefined4 uVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; int iVar5; uVar1 = Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); (**(code **)(*(int *)(iVar5 + 4) + 0x40))(iVar5,uVar1,uVar2,uVar3,uVar4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultgetphase.html": {
    "href": "resultgetphase.html",
    "title": "resultGetPhase",
    "keywords": "resultGetPhase Gets current phase of the step when the mission is ended. The mission end status can be anything - sucess, failure or accession. Code Information Name: resultGetPhase Scope: Global PAC Instruction (Binary): 25 16 eb 00 Assembly Address in Memory : 0x8926a00 Parameters (int *)destination (8 bytes) : Variable to store the result phase. ID Meaning 1 Mission status determined 3 Decided what to do, performing animation 4 After headline (Quest complete/Defeat etc) message appeared 5 Chest box scene 6 Going to result screen / Next Floor / Going to hideout Example Here is one example in hex: 25 16 eb 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: resultGetPhase((int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926a00(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar3 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); *puVar1 = 0; if (iVar3 != 0) { uVar2 = (**(code **)(*(int *)(iVar3 + 4) + 0x44))(); *puVar1 = uVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultgetstate.html": {
    "href": "resultgetstate.html",
    "title": "resultGetState",
    "keywords": "resultGetState Gets current mission status. Called every time in the mission to check the mission status. Code Information Name: resultGetState Scope: Global PAC Instruction (Binary): 25 16 17 00 Assembly Address in Memory : 0x891a568 Parameters (int *)mission_status (8 bytes) : See resultSetState for detail. (int *)result_state (8 bytes) : See resultSetState for detail. (bool *)is_mission_end (8 bytes) : If the mission is finished or not. 0 is ongoing, 1 is finished. Example Here is one example in hex: 25 16 17 00 / 08 00 00 00 / 15 00 00 00 / 08 00 00 00 / 16 00 00 00 / 08 00 00 00 / 17 00 00 00 Which is interpreted as: resultGetState(((global)int *)giVar21, ((global)int *)giVar22, ((global)int *)giVar23) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a568(int param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); (**(code **)(*(int *)(iVar4 + 4) + 0x3c))(iVar4,piVar1,uVar2); uVar2 = (**(code **)(*(int *)(iVar4 + 4) + 0x30))(iVar4); *puVar3 = uVar2; if (*piVar1 == 1) { *puVar3 = 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultlevelupcalacget.html": {
    "href": "resultlevelupcalacget.html",
    "title": "resultLevelupCalacGet",
    "keywords": "resultLevelupCalacGet Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resultLevelupCalacGet Scope: Global PAC Instruction (Binary): 25 16 ac 00 Assembly Address in Memory : 0x892328c Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892328c(int param_1,undefined4 param_2) { undefined4 uVar1; undefined4 uVar2; undefined4 uVar3; int iVar4; uVar1 = Pac_Get_Param(param_2,0,1,4); uVar2 = Pac_Get_Param(param_2,1,1,4); uVar3 = Pac_Get_Param(param_2,1,1,4); iVar4 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); if (iVar4 != 0) { func_0x08b41388(*(undefined4 *)(iVar4 + 0x528),uVar1,uVar2,uVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultlevelupcalaclabel.html": {
    "href": "resultlevelupcalaclabel.html",
    "title": "resultLevelupCalacLabel",
    "keywords": "resultLevelupCalacLabel Call specific instructions when a unit levels up. This is called per one level-up. Usually this leads to cmd_end. This is part of the starting logic, which means it lies before MissionTimmingScript. Code Information Name: resultLevelupCalacLabel Scope: Global PAC Instruction (Binary): 25 16 ab 00 Assembly Address in Memory : 0x892322c Parameters (index)address (8 bytes) : Address in PAC instruction file. Example Here is one example in hex: 25 16 ab 00 / 01 00 00 00 / cc c8 00 00 Which is interpreted as: resultLevelupCalacLabel((index)51404) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892322c(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 *puVar2; uVar1 = FUN_0883bc1c(param_2); puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); func_0x08b41370(uVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultlevelupcalacset.html": {
    "href": "resultlevelupcalacset.html",
    "title": "resultLevelupCalacSet",
    "keywords": "resultLevelupCalacSet Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resultLevelupCalacSet Scope: Global PAC Instruction (Binary): 25 16 ad 00 Assembly Address in Memory : 0x8923340 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923340(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); if (iVar4 != 0) { func_0x08b413a8(*(undefined4 *)(iVar4 + 0x528),*puVar1,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultreadygo.html": {
    "href": "resultreadygo.html",
    "title": "resultReadyGo",
    "keywords": "resultReadyGo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: resultReadyGo Scope: Global PAC Instruction (Binary): 25 16 02 01 Assembly Address in Memory : 0x8928280 Parameters This function is parameterless. Example Here is one example in hex: 25 16 02 01 Which is interpreted as: resultReadyGo() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928280(int param_1,undefined4 param_2) { int iVar1; int iVar2; if (*(int *)(param_1 + 0x10) != 0) { iVar2 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); (**(code **)(*(int *)(iVar2 + 4) + 0x44))(iVar2); iVar1 = (**(code **)(*(int *)(iVar2 + 4) + 0x44))(iVar2); if (iVar1 == 2) { (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "resultsetstate.html": {
    "href": "resultsetstate.html",
    "title": "resultSetState",
    "keywords": "resultSetState Defines mission state, e.g. success or failure. Code Information Name: resultSetState Scope: Global PAC Instruction (Binary): 25 16 19 00 Assembly Address in Memory : 0x891a720 Parameters (int)mission_status (8 bytes) : See the table below (int)result_state (8 bytes) : 5 is Hideout, 7 is Mission success, 8 is Defeat. 7 and 8 requires mission end flag (2) in mission_status, otherwise it is always back to hideout. (bool)load_next (8 bytes) : Decides if next PAC instruction file should be loaded, but keep this as 0. (undefined4)Var3 (8 bytes) : Keep this as 0. (undefined4)Var4 (8 bytes) : Keep this as 0. (String)next_pac_file: Next PAC file name to load. If the story PAC file is already preloaded, or the next scene is not called, can leave as empty string. Only first and second parameters do their work. Keep others 0 or empty string. For mission_status: ID Status 0 ??? 1 During Mission 2 Mission End 3 Back to hideout 5 Dungeon floor clear, selecting 6 Instantly go to hideout 7 Celebrating and go to hideout (no result screen) 8 Loads next floor 9+ Defeat Remarks For cutscene after the mission, use this method instead. cmd_mov(8:4D, 293.0) 293.0 here is scene ID. (If the scene ID is invalid, the game will be crashed.) The scene range is 292~322, observed in mission_99_00.pac. Example Here is one example in hex: 25 16 19 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 08 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 00 00 00 00 Which is interpreted as: resultSetState((int)2, (int)8, (int)0, (int)0, (int)0, \"\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891a720(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined2 *puVar3; int *piVar4; undefined4 *puVar5; undefined4 *puVar6; undefined *puVar7; int iVar8; undefined *puVar9; int iVar10; undefined2 local_164; undefined local_162; undefined local_161; undefined2 local_160; undefined2 local_15e; undefined2 local_15c; undefined2 local_15a; undefined2 local_158; undefined2 local_156; undefined auStack340 [16]; undefined auStack324 [8]; undefined auStack316 [8]; undefined auStack308 [8]; undefined auStack300 [8]; undefined auStack292 [8]; undefined auStack284 [8]; undefined auStack276 [8]; undefined4 local_10c; undefined4 local_108; undefined4 local_104; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); // 0: Mission fail // 1: Infinite march lmao // 2: Finished all levels // 5: Still in dungeon, asking what will do next // 6: Going to hideout (Doesn't add loot) // 7: mission success? // 8: Loads next floor // 9+: Defeat puVar3 = (undefined2 *)Pac_Get_Param(param_2,1,1,4); // 5: Hideout / 7 : Mission success / 8 : Defeat // 7 and 8 requires other flag to state \"this is mission end\" // otherwise it's always back to hideout piVar4 = (int *)Pac_Get_Param(param_2,2,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar7 = &DAT_00000100; puVar9 = local_100; puVar1 = puVar9; while (puVar1 != (undefined *)0x0) { *puVar9 = 0; puVar9 = puVar9 + 1; puVar7 = puVar7 + -1; puVar1 = puVar7; } Pac_Get_StringParam(param_2,local_100); local_104 = 0; local_108 = 0; if (*piVar4 != 0) { FUN_088154c0(local_100,s_Mission__d__d_pac_08a5fcd4,&local_104,&local_108); } iVar8 = Get_Some_Flag(1); iVar10 = *(int *)(iVar8 + 0x44); iVar8 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); local_164 = 0; local_162 = 0; local_161 = 0; local_160 = 0; local_15e = 0; local_15c = 0; local_15a = 0; Syscall::Kernel::Kernel_Memset(auStack340,0,0x10); Syscall::Kernel::Kernel_Memset(auStack324,0,8); Syscall::Kernel::Kernel_Memset(auStack316,0,8); Syscall::Kernel::Kernel_Memset(auStack308,0,8); Syscall::Kernel::Kernel_Memset(auStack300,0,8); Syscall::Kernel::Kernel_Memset(auStack292,0,8); Syscall::Kernel::Kernel_Memset(auStack284,0,8); Syscall::Kernel::Kernel_Memset(auStack276,0,8); local_10c = *(undefined4 *)(iVar10 + 0x28); // get mission status 1 // get mission status 2 local_164 = (undefined2)*puVar2; local_162 = (undefined)*puVar3; local_161 = (undefined)*(undefined2 *)piVar4; local_160 = (undefined2)*puVar5; local_15e = (undefined2)*puVar6; local_15c = (undefined2)local_104; local_15a = (undefined2)local_108; local_158 = 0xffff; local_156 = 0xffff; (**(code **)(*(int *)(iVar8 + 4) + 0x24))(iVar8,&local_164); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "saveactorinfo.html": {
    "href": "saveactorinfo.html",
    "title": "saveActorInfo",
    "keywords": "saveActorInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: saveActorInfo Scope: Azito PAC Instruction (Binary): 25 1c 1f 00 Assembly Address in Memory : 0x8b4f8a8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f8a8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; undefined4 uVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar6 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar5 = *puVar2; iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = iVar6 * 0x18 + *(int *)(iVar3 + 0x50) + 0x297e0; if ((iVar3 != 0) && (iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x174) + 0xe8),uVar5, 1), iVar4 != 0)) { FUN_Azito__08b4cdf0(iVar3,iVar6,iVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "savefacilityinfo.html": {
    "href": "savefacilityinfo.html",
    "title": "saveFacilityInfo",
    "keywords": "saveFacilityInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: saveFacilityInfo Scope: Azito PAC Instruction (Binary): 25 1c 21 00 Assembly Address in Memory : 0x8b4fa60 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fa60(int param_1,undefined4 param_2) { int iVar1; int iVar2; int iVar3; int iVar4; int iVar5; int iVar6; iVar1 = Save::Get_Save_BaseAddr(1); iVar1 = *(int *)(iVar1 + 0x50); iVar6 = iVar1 + 0x285a8; iVar5 = 0; iVar4 = 0; do { iVar3 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + iVar4 + 0x1e0); if (iVar3 != 0) { if (*(int *)(iVar3 + 0x148) == 0) { iVar2 = *(int *)(param_1 + 0x10); } else { FUN_Azito__08b4cdf0(iVar6 + 0x1418,iVar5); *(undefined *)(iVar6 + 0x141d) = *(undefined *)(iVar3 + 0x141); *(undefined *)(iVar6 + 0x141e) = *(undefined *)(iVar3 + 0x142); iVar2 = *(int *)(param_1 + 0x10); } if (*(int *)(*(int *)(iVar2 + 0x1c4) + 0x2b8) == iVar3) { *(int *)(iVar1 + 0x29af8) = iVar5; } } iVar5 = iVar5 + 1; iVar4 = iVar4 + 0x10; iVar6 = iVar6 + 0x18; } while (iVar5 < 0xd); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "saveflag.html": {
    "href": "saveflag.html",
    "title": "saveFlag",
    "keywords": "saveFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: saveFlag Scope: Global PAC Instruction (Binary): 25 0a 30 00 Assembly Address in Memory : 0x894bf84 Parameters This function is parameterless. Example Here is one example in hex: 25 0a 30 00 Which is interpreted as: saveFlag() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bf84(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; uVar1 = FUN_08877b6c(1); FUN_08877c78(uVar1,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "savems.html": {
    "href": "savems.html",
    "title": "saveMS",
    "keywords": "saveMS Saves current save data. This does not save system data. Use with getResultSaveMs to stop any instruction execution while saving. Code Information Name: saveMS Scope: Azito PAC Instruction (Binary): 25 1c 1d 00 Assembly Address in Memory : 0x8b4f790 Parameters (int)debug_level (8 bytes) : 0 is regular save. 1 and 2 are reserved for debugging. (bool)Var0 (8 bytes) : Can keep 0. Example Here is one example in hex: 25 1c 1d 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: saveMS((int)0, (int)0) This is an example how to save the data properly. 0000A504 251C1D00:saveMS(2:0, 2:0) 0000A518 25000200:cmd_jmp(1:A554) 0000A554 25000F00:cmd_waitFrame(2:1) 0000A560 251C1E00:getResultSaveMS(4:0) 0000A56C 25001D00:cmd_ifAND(4:0, 2:1, 1:A554) 0000A584 25000100:cmd_end()``` Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f790(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; undefined4 uVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar5 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *piVar2; if (*(int *)(param_1 + 0x10) != 0) { uVar4 = *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x204); FUN_Azito__08b50db0(uVar4,uVar5); FUN_Azito__08b51158(uVar4,iVar3 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "savequestcompletecounter.html": {
    "href": "savequestcompletecounter.html",
    "title": "saveQuestCompleteCounter",
    "keywords": "saveQuestCompleteCounter Reads quest complement counter address, but this does nothing. Use getQuestComplementCounter to get quest complemente counter. This is functionally identical to loadQuestCompleteCounter. Code Information Name: saveQuestCompleteCounter Scope: Global PAC Instruction (Binary): 25 0a 39 00 Assembly Address in Memory : 0x894ce28 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894ce28(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Save::Get_Save_BaseAddr(1); return__0x1c(*(undefined4 *)(iVar1 + 0x50)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "screenstartframe.html": {
    "href": "screenstartframe.html",
    "title": "screenStartFrame",
    "keywords": "screenStartFrame Limits screen view as rectangle shape. Code Information Name: screenStartFrame Scope: Global PAC Instruction (Binary): 25 16 a9 00 Assembly Address in Memory : 0x8922e24 Parameters (int)z_priority (8 bytes) : z-index (render priority), higher goes more top. (float)x_position (8 bytes) : X position, as PSP screen pixels. (float)y_position (8 bytes) : Y position, as PSP screen pixels. (float)red (8 bytes) : Red value of the blind area, 0~1. (float)green (8 bytes) : Green value of the blind area, 0~1. (float)blue (8 bytes) : Blue value of the blind area, 0~1. (float)alpha (8 bytes) : Alpha value of the blind area, 0~1. (float)box_size (8 bytes) : Box size, as PSP screen pixels. The bigger, the more sight. (float)box_size_y (8 bytes) : Y size, setting -1 fits to screen ratio. (float)animation_time (8 bytes) : Animation time as seconds, 0 for no animation. The pivot is center and offset starts from top. Note that PSP screen size is 480 x 272 and the size pivot is on the middle, offset starts from top left. 240 x 136 will move the rectangle to the center. Example Here is one example in hex: 25 16 a9 00 / 02 00 00 00 / ac bb 0d 00 / 10 00 00 00 / 00 00 70 43 / 10 00 00 00 / 00 00 08 43 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 c8 42 / 10 00 00 00 / 00 00 80 bf / 10 00 00 00 / 00 00 00 00 Which is interpreted as: screenStartFrame((int)900012, (float)240.0, (float)136.0, (float)0.0, (float)0.0, (float)0.0, (float)1.0, (float)100.0, (float)-1.0, (float)0.0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922e24(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; int iVar4; undefined4 *puVar5; int iVar6; int iVar7; undefined4 uVar8; undefined4 uVar9; undefined4 uVar10; undefined4 uVar11; undefined4 uVar12; undefined4 uVar13; undefined4 uVar14; undefined4 uVar15; undefined4 uVar16; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); iVar7 = *piVar2; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar16 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar14 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar15 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar12 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar13 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar10 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar11 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar8 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar9 = *puVar3; if ((*(int *)(param_1 + 0x10) != 0) && (iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar4 != 0)) { iVar6 = *(int *)(*(int *)(iVar4 + 0x2c) + 0x60); iVar4 = (**(code **)(*(int *)(iVar6 + 0xa8) + 0x10))(iVar6 + 0x8c); if (iVar7 != iVar4) { (**(code **)(*(int *)(iVar6 + 0xa8) + 0x14))(iVar6 + 0x8c,iVar7); } puVar3 = (undefined4 *)&DAT_00000010; puVar5 = &local_20; puVar1 = puVar5; while (puVar1 != (undefined4 *)0x0) { *(undefined *)puVar5 = 0; puVar5 = (undefined4 *)((int)puVar5 + 1); puVar3 = (undefined4 *)((int)puVar3 + -1); puVar1 = puVar3; } local_20 = uVar15; local_1c = uVar12; local_18 = uVar13; local_14 = uVar10; local_10 = uVar11; local_c = uVar8; local_8 = uVar16; local_4 = uVar14; func_0x08b33630(uVar9,iVar6,&local_8,&local_20,&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "screenstartspotlight.html": {
    "href": "screenstartspotlight.html",
    "title": "screenStartSpotLight",
    "keywords": "screenStartSpotLight Limits screen view as round shape, Provides the \"narrow view\". Code Information Name: screenStartSpotLight Scope: Global PAC Instruction (Binary): 25 16 aa 00 Assembly Address in Memory : 0x892303c Parameters (int)z_priority (8 bytes) : z-index (render priority), higher goes more top. (float)x_position (8 bytes) : X position, as PSP screen pixels. (float)y_position (8 bytes) : Y position, as PSP screen pixels. (float)red (8 bytes) : Red value of the blind area, 0~1. (float)green (8 bytes) : Green value of the blind area, 0~1. (float)blue (8 bytes) : Blue value of the blind area, 0~1. (float)alpha (8 bytes) : Alpha value of the blind area, 0~1. (float)circle_size (8 bytes) : Circle radius size, as PSP screen pixels. The bigger, the more sight. This means, 136 will just fit to the screen Y if the circle is in center. (float)animation_time (8 bytes) : Animation time as seconds, 0 for no animation. Note that PSP screen size is 480 x 272 and the size pivot is on the middle, offset starts from top left. 240 x 136 will move the circle to the center. Example Here is one example in hex: 25 16 aa 00 / 02 00 00 00 / ac bb 0d 00 / 10 00 00 00 / 00 00 70 43 / 10 00 00 00 / 00 00 08 43 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f / 10 00 00 00 / 00 00 c8 42 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: screenStartSpotLight((int)900012, (float)240.0, (float)136.0, (float)0.0, (float)0.0, (float)0.0, (float)1.0, (float)100.0, (float)0.0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892303c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; int iVar4; undefined4 *puVar5; int iVar6; int iVar7; undefined4 uVar8; undefined4 uVar9; undefined4 uVar10; undefined4 uVar11; undefined4 uVar12; undefined4 uVar13; undefined4 uVar14; undefined4 uVar15; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_8; undefined4 local_4; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); iVar7 = *piVar2; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar14 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar15 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar12 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar13 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar10 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar11 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar8 = *puVar3; puVar3 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar9 = *puVar3; if ((*(int *)(param_1 + 0x10) != 0) && (iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar4 != 0)) { iVar6 = *(int *)(*(int *)(iVar4 + 0x2c) + 0x5c); iVar4 = (**(code **)(*(int *)(iVar6 + 0xa8) + 0x10))(iVar6 + 0x8c); if (iVar7 != iVar4) { (**(code **)(*(int *)(iVar6 + 0xa8) + 0x14))(iVar6 + 0x8c,iVar7); } puVar3 = (undefined4 *)&DAT_00000010; puVar5 = &local_20; puVar1 = puVar5; while (puVar1 != (undefined4 *)0x0) { *(undefined *)puVar5 = 0; puVar5 = (undefined4 *)((int)puVar5 + 1); puVar3 = (undefined4 *)((int)puVar3 + -1); puVar1 = puVar3; } local_20 = uVar12; local_1c = uVar13; local_18 = uVar10; local_14 = uVar11; local_8 = uVar14; local_4 = uVar15; func_0x08b34058(uVar8,uVar9,iVar6,&local_8,&local_20); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendcommand.html": {
    "href": "sendcommand.html",
    "title": "sendCommand",
    "keywords": "sendCommand Sends command as given command ID. Originally meant for debug mode. This does nothing with drum hit. This alone does not cancel drumming neither fever. This does not activate heromode. Best seen in DoI Piekron heromode reset. Originally from Debug mode, usd in Queen Kharma's \"Bada Bada Bada Bon\" and DoI random command. For auto command with drumming (and also heromode), check setAutoCommand. Code Information Name: sendCommand Scope: Global PAC Instruction (Binary): 25 0c 0c 00 Assembly Address in Memory : 0x89708b0 Parameters (int)Command ID (8 bytes) : Command ID to send. Remarks This does not activate actual summon (witn 9 as parameter). However, this does active character behaviours during summon. Example Here is one example in hex: 25 0c 0c 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: sendCommand((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089708b0(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar2 != 0) { func_0x08b5f678(iVar2,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendmessage.html": {
    "href": "sendmessage.html",
    "title": "sendMessage",
    "keywords": "sendMessage Sends a system message to the chat window. Used for showing current VS status to the chat window. Code Information Name: sendMessage Scope: Global PAC Instruction (Binary): 25 16 11 01 Assembly Address in Memory : 0x892920c Parameters (int)player_id (8 bytes) : Sender player ID to set, expected -1~3. -1 means nobody. Please describe if this does actually something. (int)quip_colour (8 bytes) : System quip colour in system settings, expected -1~3. -1 uses default colour. The colour cannot be adjusted normally in options page. (bool)Var2 (8 bytes) : 1 always sends the message regardless of the target validity or multi status. (bool)Var3 (8 bytes) : Quip rendring related, but unused. (Address)sender_name (8 bytes) : Address of the sender name messag in the PAC file. Keep -1 to hide this. (Address)message_address (8 bytes) : Address of the display message in the PAC file. Example Here is one example in hex: 25 16 11 01 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / ff ff ff ff / 01 00 00 00 / 80 14 07 00 Which is interpreted as: sendMessage((int *)iVar1, (int)2, (int)0, (int)1, (int)-1, (index)464000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892920c(int param_1,undefined4 param_2) { bool bVar1; char cVar2; int *piVar3; int *piVar4; undefined4 uVar5; int iVar6; int iVar7; int iVar8; int iVar9; int iVar10; int iVar11; int iVar12; undefined local_3c; undefined local_3b; undefined2 local_3a; undefined2 local_38; undefined2 local_36; undefined local_34; undefined local_33; undefined4 local_30; undefined auStack44 [40]; undefined4 local_4; piVar3 = (int *)Pac_Get_Param(param_2,0,1,4); iVar8 = *piVar3; piVar3 = (int *)Pac_Get_Param(param_2,1,1,4); iVar10 = *piVar3; piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar9 = *piVar3; piVar3 = (int *)Pac_Get_Param(param_2,3,1,4); iVar12 = *piVar3; piVar3 = (int *)Pac_Get_Param(param_2,4,1,4); piVar4 = (int *)Pac_Get_Param(param_2,5,1,4); uVar5 = Save::Get_Save_BaseAddr(1); iVar6 = Save::Get_BaseAddr__0x78(uVar5,1); iVar11 = *(int *)(iVar6 + 100); iVar6 = Get_Some_Flag(1); iVar6 = *(int *)(iVar6 + 0x44); if (((iVar11 == 0) || (iVar6 == 0)) || (iVar7 = Is_Multi(iVar11), iVar7 == 0)) goto LAB_089294f4; iVar7 = Is_Multi(iVar11); if (iVar7 == 0) { cVar2 = '\\0'; } else { cVar2 = FUN_08986d3c(iVar11); } if (((cVar2 == '\\0') && (iVar9 == 0)) || (iVar6 == -0x528)) goto LAB_089294f4; iVar11 = *(int *)(iVar6 + 0x54c); if (iVar11 == 4) { iVar11 = *(int *)(param_1 + 0x10); } else { if (((iVar11 != 3) && (iVar11 != 2)) && (iVar11 != 1)) goto LAB_089294f4; iVar11 = *(int *)(param_1 + 0x10); } iVar11 = *(int *)(*(int *)(iVar11 + 0x2d8) + 0x18); if (iVar11 == 0) goto LAB_089294f4; local_3c = 0x3c; local_36 = 0xcd1; local_3b = 0; local_3a = 0; local_38 = 0; Init_Space(auStack44); local_34 = 0xff; local_33 = 1; local_30 = 0; FUN_089fe4a4(auStack44); local_4 = 0xffffffff; local_34 = (undefined)iVar8; if (iVar10 == 3) { local_30 = 3; } else if (iVar10 == 2) { local_30 = 2; } else if (iVar10 == 1) { local_30 = 1; } else { local_30 = 0; } if (iVar8 < 0) { iVar6 = *piVar3; LAB_08929470: if (iVar6 < 1) { Copy_MessageAddr(auStack44,0xffffffff); } else { iVar6 = FUN_0883bc1c(param_2); Copy_MessageAddr(auStack44,*(undefined4 *)(iVar6 + *piVar3)); } } else { if (7 < iVar8) { iVar6 = *piVar3; goto LAB_08929470; } bVar1 = 3 < iVar8; if (bVar1) { iVar8 = iVar8 + -4; } iVar6 = FUN_089880e8(iVar6 + 0x850,bVar1,iVar8); if (iVar6 != 0) { Message::Quip::Save_Quip_Message(auStack44,iVar6 + 0xb8); } } iVar6 = FUN_0883bc1c(param_2); local_4 = *(undefined4 *)(iVar6 + *piVar4); local_33 = iVar12 != 0; if (iVar9 == 0) { FUN_089c4f5c(iVar11,&local_3c); } else { FUN_089c4fb0(iVar11,&local_3c); } LAB_089294f4: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendmiss.html": {
    "href": "sendmiss.html",
    "title": "sendMiss",
    "keywords": "sendMiss Sends command miss (command cancel). Code Information Name: sendMiss Scope: Global PAC Instruction (Binary): 25 0c 08 00 Assembly Address in Memory : 0x89706cc Parameters (int)has_fever_break_sound (8 bytes) : 0 does not have fever break sound, 1 plays fever break sound. Example Here is one example in hex: 25 0c 08 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: sendMiss((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089706cc(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar2 != 0) { func_0x08b5f620(iVar2,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendmonsterinfoaction.html": {
    "href": "sendmonsterinfoaction.html",
    "title": "sendMonsterInfoAction",
    "keywords": "sendMonsterInfoAction Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendMonsterInfoAction Scope: Global PAC Instruction (Binary): 25 21 2b 00 Assembly Address in Memory : 0x89b3cb8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 2b 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: sendMonsterInfoAction((int *)iVar20, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3cb8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = FUN_089b12c4(param_1,*puVar1); if (iVar3 != 0) { FUN_0896dc48(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendmonsterinfostate.html": {
    "href": "sendmonsterinfostate.html",
    "title": "sendMonsterInfoState",
    "keywords": "sendMonsterInfoState Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendMonsterInfoState Scope: Global PAC Instruction (Binary): 25 21 2d 00 Assembly Address in Memory : 0x89b3e08 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 2d 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: sendMonsterInfoState((int *)iVar20, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3e08(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = FUN_089b12c4(param_1,*puVar1); if (iVar3 != 0) { FUN_0896dcc0(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendplaymotion.html": {
    "href": "sendplaymotion.html",
    "title": "sendPlayMotion",
    "keywords": "sendPlayMotion Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendPlayMotion Scope: Global PAC Instruction (Binary): 25 16 07 01 Assembly Address in Memory : 0x89285ec Parameters (undefined4)Var0 (8 bytes) (char)Var1 (8 bytes) (undefined)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 16 07 01 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: sendPlayMotion((int *)iVar0, (int)3, (int *)iVar1, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089285ec(int param_1,undefined4 param_2) { char cVar1; undefined4 *puVar2; char *pcVar3; undefined *puVar4; undefined4 *puVar5; int iVar6; int iVar7; undefined4 uVar8; int iVar9; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pcVar3 = (char *)Pac_Get_Param(param_2,1,1,4); puVar4 = (undefined *)Pac_Get_Param(param_2,2,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); *puVar5 = 0; iVar6 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1); if (((iVar6 != 0) && (iVar7 = (**(code **)(*(int *)(iVar6 + 4) + 0x34))(iVar6), iVar7 == 10)) && (iVar6 = *(int *)(iVar6 + 0x194), iVar6 != 0)) { uVar8 = Save::Get_Save_BaseAddr(1); iVar7 = Save::Get_BaseAddr__0x78(uVar8,1); uVar8 = *(undefined4 *)(iVar7 + 100); iVar9 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); iVar7 = Is_Multi(uVar8); if (iVar7 != 0) { iVar7 = Is_Multi(uVar8); if (iVar7 == 0) { cVar1 = '\\0'; } else { cVar1 = FUN_08986d3c(uVar8); } if (cVar1 != '\\0') { FUN_089c4c08(*(undefined4 *)(iVar9 + 0x18),iVar6,5,(int)*pcVar3,0,*puVar4); *puVar5 = 1; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus02commondata.html": {
    "href": "sendversus02commondata.html",
    "title": "sendVersus02CommonData",
    "keywords": "sendVersus02CommonData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus02CommonData Scope: Global PAC Instruction (Binary): 25 16 27 01 Assembly Address in Memory : 0x8927968 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 16 27 01 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 0a 00 00 00 / 04 00 00 00 / 01 00 00 00 Which is interpreted as: sendVersus02CommonData((int)1, (int *)iVar10, (int *)iVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927968(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined local_10; undefined local_f; undefined2 local_e; undefined2 local_c; undefined2 local_a; undefined2 local_8; undefined2 local_6; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_10 = 0x10; local_a = 0x1007; local_f = 0; local_e = 0; local_c = 0; if (iVar4 != 0) { local_8 = (undefined2)*puVar1; local_6 = (undefined2)*puVar2; local_4 = *puVar3; FUN_089cdacc(*(undefined4 *)(iVar4 + 0x48),&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus02enemyctrl.html": {
    "href": "sendversus02enemyctrl.html",
    "title": "sendVersus02EnemyCtrl",
    "keywords": "sendVersus02EnemyCtrl Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus02EnemyCtrl Scope: Global PAC Instruction (Binary): 25 16 cb 00 Assembly Address in Memory : 0x8924804 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 16 cb 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 0c 00 00 00 / 20 00 00 00 / 0a 00 00 00 / 20 00 00 00 / 0b 00 00 00 Which is interpreted as: sendVersus02EnemyCtrl((int)0, (int *)iVar12, (float *)fVar10, (float *)fVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924804(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined local_18; undefined local_17; undefined2 local_16; undefined2 local_14; undefined2 local_12; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_18 = 0x18; local_12 = 0x1005; local_17 = 0; local_16 = 0; local_14 = 0; if (iVar5 != 0) { local_4 = *puVar4; local_8 = *puVar3; local_c = *puVar2; local_10 = *puVar1; FUN_089cda44(*(undefined4 *)(iVar5 + 0x48),&local_18); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus02missileinfo.html": {
    "href": "sendversus02missileinfo.html",
    "title": "sendVersus02MissileInfo",
    "keywords": "sendVersus02MissileInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus02MissileInfo Scope: Global PAC Instruction (Binary): 25 16 c9 00 Assembly Address in Memory : 0x8924544 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) Example Here is one example in hex: 25 16 c9 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / 20 00 00 00 / 01 00 00 00 / 04 00 00 00 / 02 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: sendVersus02MissileInfo((int *)iVar0, (int *)iVar1, (float *)fVar1, (int *)iVar2, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924544(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; undefined local_14; undefined local_13; undefined2 local_12; undefined2 local_10; undefined2 local_e; undefined local_c; undefined local_b; undefined2 local_a; undefined4 local_8; undefined local_4; undefined local_3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); iVar6 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_14 = 0x14; local_e = 0x1006; local_13 = 0; local_12 = 0; local_10 = 0; local_c = 0xff; local_b = 0; local_a = 0; local_8 = 0; local_4 = 0xff; local_3 = 0xff; if (iVar6 != 0) { local_8 = *puVar3; local_c = (undefined)*puVar1; local_b = 1; local_a = (undefined2)*puVar2; local_4 = (undefined)*puVar4; local_3 = (undefined)*puVar5; FUN_089cda78(*(undefined4 *)(iVar6 + 0x48),&local_14); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus03enemyctrl.html": {
    "href": "sendversus03enemyctrl.html",
    "title": "sendVersus03EnemyCtrl",
    "keywords": "sendVersus03EnemyCtrl Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus03EnemyCtrl Scope: Global PAC Instruction (Binary): 25 16 c5 00 Assembly Address in Memory : 0x89241d0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089241d0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined local_18; undefined local_17; undefined2 local_16; undefined2 local_14; undefined2 local_12; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_18 = 0x18; local_12 = 0x106a; local_17 = 0; local_16 = 0; local_14 = 0; if (iVar5 != 0) { local_4 = *puVar4; local_8 = *puVar3; local_c = *puVar2; local_10 = *puVar1; FUN_089ef954(*(undefined4 *)(iVar5 + 0x58),&local_18); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus03lastonegoal.html": {
    "href": "sendversus03lastonegoal.html",
    "title": "sendVersus03LastOneGoal",
    "keywords": "sendVersus03LastOneGoal Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus03LastOneGoal Scope: Global PAC Instruction (Binary): 25 16 c7 00 Assembly Address in Memory : 0x89243f4 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 c7 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: sendVersus03LastOneGoal((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089243f4(int param_1,undefined4 param_2) { int *piVar1; int iVar2; undefined local_c; undefined local_b; undefined2 local_a; undefined2 local_8; undefined2 local_6; undefined local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_c = 10; local_6 = 0x106b; local_b = 0; local_a = 0; local_8 = 0; if (iVar2 != 0) { iVar2 = *(int *)(iVar2 + 0x58); if (*(char *)(*piVar1 + iVar2 + 0x48) == '\\0') { local_4 = *piVar1 != 0; FUN_089ef988(iVar2,&local_c); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus04commondata.html": {
    "href": "sendversus04commondata.html",
    "title": "sendVersus04CommonData",
    "keywords": "sendVersus04CommonData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus04CommonData Scope: Global PAC Instruction (Binary): 25 16 2b 01 Assembly Address in Memory : 0x8927c5c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927c5c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined local_10; undefined local_f; undefined2 local_e; undefined2 local_c; undefined2 local_a; undefined2 local_8; undefined2 local_6; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_10 = 0x10; local_a = 0x10d0; local_f = 0; local_e = 0; local_c = 0; if (iVar4 != 0) { local_8 = (undefined2)*puVar1; local_6 = (undefined2)*puVar2; local_4 = *puVar3; FUN_089f01a0(*(undefined4 *)(iVar4 + 0x68),&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus04knockoutinfo.html": {
    "href": "sendversus04knockoutinfo.html",
    "title": "sendVersus04KnockOutInfo",
    "keywords": "sendVersus04KnockOutInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus04KnockOutInfo Scope: Global PAC Instruction (Binary): 25 16 e9 00 Assembly Address in Memory : 0x8924a28 Parameters This function is parameterless. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924a28(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (iVar1 != 0) { iVar1 = *(int *)(iVar1 + 0x68); if ((undefined4 *)(iVar1 + 0x10) != (undefined4 *)0x0) { *(undefined4 *)(iVar1 + 0x10) = 0; *(undefined *)(iVar1 + 0x14) = 0xff; *(undefined4 *)(iVar1 + 0x18) = 0xffffffff; *(undefined *)(iVar1 + 0x1c) = 0xff; *(undefined4 *)(iVar1 + 0x20) = 0xffffffff; *(undefined *)(iVar1 + 0x24) = 0xff; *(undefined4 *)(iVar1 + 0x28) = 0xffffffff; *(undefined *)(iVar1 + 0x2c) = 0xff; *(undefined4 *)(iVar1 + 0x30) = 0xffffffff; *(undefined *)(iVar1 + 0x34) = 0xff; *(undefined4 *)(iVar1 + 0x38) = 0xffffffff; *(undefined *)(iVar1 + 0x3c) = 0xff; *(undefined4 *)(iVar1 + 0x40) = 0xffffffff; *(undefined *)(iVar1 + 0x44) = 0xff; *(undefined4 *)(iVar1 + 0x48) = 0xffffffff; *(undefined *)(iVar1 + 0x4c) = 0xff; *(undefined4 *)(iVar1 + 0x50) = 0xffffffff; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus04panelaction.html": {
    "href": "sendversus04panelaction.html",
    "title": "sendVersus04PanelAction",
    "keywords": "sendVersus04PanelAction Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus04PanelAction Scope: Global PAC Instruction (Binary): 25 16 f9 00 Assembly Address in Memory : 0x8924b98 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (undefined4)Var5 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924b98(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; int iVar7; undefined local_14; undefined local_13; undefined2 local_12; undefined2 local_10; undefined2 local_e; undefined local_c; undefined local_b; undefined2 local_a; undefined local_8; undefined local_7; undefined2 local_6; undefined2 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); iVar7 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if ((iVar7 != 0) && (iVar7 = *(int *)(iVar7 + 0x68), iVar7 != 0)) { local_14 = 0x12; local_13 = 0; local_12 = 0; local_10 = 0; local_e = 0x10cd; local_b = (undefined)*puVar1; local_a = (undefined2)*puVar2; local_8 = (undefined)*puVar3; local_7 = (undefined)*puVar4; local_6 = (undefined2)*puVar5; local_4 = (undefined2)*puVar6; local_c = 0; FUN_089f0070(iVar7,&local_14); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus04panelswaprandom.html": {
    "href": "sendversus04panelswaprandom.html",
    "title": "sendVersus04PanelSwapRandom",
    "keywords": "sendVersus04PanelSwapRandom Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus04PanelSwapRandom Scope: Global PAC Instruction (Binary): 25 16 fd 00 Assembly Address in Memory : 0x89250b0 Parameters (int)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089250b0(int param_1,undefined4 param_2) { char cVar1; int *piVar2; int iVar3; int iVar4; uint uVar5; uint uVar6; uint uVar7; int iVar8; undefined local_18; undefined local_17; undefined2 local_16; undefined2 local_14; undefined2 local_12; char local_10; undefined local_f; undefined local_e; undefined local_d; undefined local_c; undefined local_b; undefined local_a; undefined local_9; char local_8 [4]; undefined local_4; undefined local_3; undefined local_2; undefined local_1; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); local_18 = 0x10; local_17 = 0; local_16 = 0; local_14 = 0; local_12 = 0x10ce; iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); if (((iVar3 != 0) && (iVar3 = *(int *)(iVar3 + 0x68), iVar3 != 0)) && (*(char *)(iVar3 + 0xa8) == '\\0')) { local_8[0] = -1; local_8[1] = 0xff; local_8[2] = 0xff; local_8[3] = 0xff; local_4 = 0xff; local_3 = 0xff; local_2 = 0xff; local_1 = 0xff; iVar8 = 0; do { iVar4 = zero_if_08aabe38_is_zero(1); uVar5 = Util::Random::Get_Rand_Value(iVar4 + 0x9c8); iVar4 = 0; uVar7 = uVar5 % 9; LAB_0892517c: uVar6 = uVar7 & 7; if ((int)uVar7 < 0) { if (uVar6 != 0) { uVar6 = uVar6 - 8; goto LAB_08925190; } } else { LAB_08925190: uVar6 = uVar6 & 0xff; } if (local_8[uVar6] != -1) { iVar4 = iVar4 + 1; if (7 < iVar4) goto LAB_089251cc; uVar7 = uVar5 % 9 + iVar4; goto LAB_0892517c; } if (iVar8 == *piVar2) { cVar1 = '\\b'; } else { cVar1 = (char)iVar8; } local_8[uVar6] = cVar1; LAB_089251cc: iVar8 = iVar8 + 1; } while (iVar8 < 8); local_f = local_8[1]; local_e = local_8[2]; local_10 = local_8[0]; local_c = local_4; local_b = local_3; local_d = local_8[3]; local_a = local_2; local_9 = local_1; FUN_089f00a4(iVar3,&local_18); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversus04requestwave.html": {
    "href": "sendversus04requestwave.html",
    "title": "sendVersus04RequestWave",
    "keywords": "sendVersus04RequestWave Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersus04RequestWave Scope: Global PAC Instruction (Binary): 25 16 1d 01 Assembly Address in Memory : 0x892a0fc Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a0fc(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined local_c; undefined local_b; undefined2 local_a; undefined2 local_8; undefined2 local_6; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8); local_c = 0x10; local_6 = 0x10cf; local_4 = 0xffffffff; local_b = 0; local_a = 0; local_8 = 0; if (iVar2 != 0) { local_4 = *puVar1; FUN_089f014c(*(undefined4 *)(iVar2 + 0x68),&local_c); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sendversusgoal.html": {
    "href": "sendversusgoal.html",
    "title": "sendVersusGoal",
    "keywords": "sendVersusGoal Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sendVersusGoal Scope: Global PAC Instruction (Binary): 25 16 c2 00 Assembly Address in Memory : 0x8924044 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 c2 00 / 08 00 00 00 / 64 00 00 00 Which is interpreted as: sendVersusGoal(((global)int *)giVar100) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08924044(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_089ef914(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2d8) + 0x58),*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "serchgfpid.html": {
    "href": "serchgfpid.html",
    "title": "serchGfpId",
    "keywords": "serchGfpId Find Item ID by the weaponparam ID and enchant type. Code Information Name: serchGfpId Scope: Global PAC Instruction (Binary): 25 0a 08 00 Assembly Address in Memory : 0x8949c30 Parameters (int *)destination (8 bytes) : Item Id, gets -1 if no match was found. (int)must_be_9 (8 bytes) : Param file ID, but only 9 (itemparam) works. Must be 9 to be functional. (int)must_be_0 (8 bytes) : Should be section index, Keep 0 to make functional. (int)another_must_be_0 (8 bytes) : Keep 0 to make functional. (int)weaponparam_id (8 bytes) : Weaponparam ID of the item. (int)enchant_type (8 bytes) : Enchant type of the item. Example Here is one example in hex: 25 0a 08 00 / 04 00 00 00 / 03 00 00 00 / 02 00 00 00 / 09 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 05 00 00 00 / 04 00 00 00 / 04 00 00 00 Which is interpreted as: serchGfpId((int *)iVar3, (int)9, (int)0, (int)0, (int *)iVar5, (int *)iVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949c30(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 uVar3; int iVar4; int iVar5; int iVar6; int iVar7; int iVar8; int iVar9; int iVar10; int iVar11; int iVar12; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar9 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,2,1,4); iVar8 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,3,1,4); iVar10 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,4,1,4); iVar11 = *piVar2; piVar2 = (int *)Pac_Get_Param(param_2,5,1,4); iVar12 = *piVar2; *piVar1 = -1; uVar3 = Save::Get_Save_BaseAddr(1); iVar4 = Save::Get_BaseAddr__0x78(uVar3,1); iVar4 = Param::Get_Data_Addr(*(undefined4 *)(iVar4 + 0xa4),iVar9); if (*(int *)(iVar4 + 8) != 0) { iVar6 = *(int *)(iVar8 * 8 + *(int *)(iVar4 + 8) + 0x20); iVar7 = 0; if (0 < iVar6) { do { iVar5 = Param::Get_Line_Addr(iVar4,iVar8,iVar7,1); if (iVar5 == 0) { iVar5 = *piVar1; } else { if ((((iVar9 == 9) && (iVar8 == 0)) && (iVar10 == 0)) && ((*(short *)(iVar5 + 6) == iVar11 && (*(char *)(iVar5 + 0xe) == iVar12)))) { *piVar1 = iVar7; } iVar5 = *piVar1; } } while ((iVar5 == -1) && (iVar7 = iVar7 + 1, iVar7 < iVar6)); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setBossMoveRange.html": {
    "href": "setBossMoveRange.html",
    "title": "setBossMoveRange",
    "keywords": "setBossMoveRange There are few functions with the same name: setBossMoveRange (25210a00) (Global) setBossMoveRange (251f2e00) (Mission)"
  },
  "setBossMoveRangeLimit.html": {
    "href": "setBossMoveRangeLimit.html",
    "title": "setBossMoveRangeLimit",
    "keywords": "setBossMoveRangeLimit There are few functions with the same name: setBossMoveRangeLimit (25210c00) (Global) setBossMoveRangeLimit (251f2f00) (Mission)"
  },
  "setGroupId.html": {
    "href": "setGroupId.html",
    "title": "setGroupId",
    "keywords": "setGroupId There are few functions with the same name: setGroupId (25100900) (Global) setGroupId (25170d00) (Global)"
  },
  "setItemTable.html": {
    "href": "setItemTable.html",
    "title": "setItemTable",
    "keywords": "setItemTable There are few functions with the same name: setItemTable (25174900) (Global) setItemTable (251f0700) (Mission)"
  },
  "setMotion.html": {
    "href": "setMotion.html",
    "title": "setMotion",
    "keywords": "setMotion There are few functions with the same name: setMotion (25171100) (Global) setMotion (25211b00) (Global)"
  },
  "setMoveSpeedRatio.html": {
    "href": "setMoveSpeedRatio.html",
    "title": "setMoveSpeedRatio",
    "keywords": "setMoveSpeedRatio There are few functions with the same name: setMoveSpeedRatio (25171200) (Global) setMoveSpeedRatio (25164900) (Global)"
  },
  "setRenderPriority.html": {
    "href": "setRenderPriority.html",
    "title": "setRenderPriority",
    "keywords": "setRenderPriority There are few functions with the same name: setRenderPriority (25171800) (Global) setRenderPriority (25030900) (Global)"
  },
  "setTimmingScript.html": {
    "href": "setTimmingScript.html",
    "title": "setTimmingScript",
    "keywords": "setTimmingScript There are few functions with the same name: setTimmingScript (250a1a00) (Global) setTimmingScript (251c0400) (Azito)"
  },
  "setUnitCtrlActivity.html": {
    "href": "setUnitCtrlActivity.html",
    "title": "setUnitCtrlActivity",
    "keywords": "setUnitCtrlActivity There are few functions with the same name: setUnitCtrlActivity (2516d700) (Global) setUnitCtrlActivity (251f1c00) (Mission)"
  },
  "setUnitCtrlCurrentActType.html": {
    "href": "setUnitCtrlCurrentActType.html",
    "title": "setUnitCtrlCurrentActType",
    "keywords": "setUnitCtrlCurrentActType There are few functions with the same name: setUnitCtrlCurrentActType (2516d800) (Global) setUnitCtrlCurrentActType (251f2700) (Mission)"
  },
  "setaccessoryidfileindex.html": {
    "href": "setaccessoryidfileindex.html",
    "title": "setAccessoryIdFileIndex",
    "keywords": "setAccessoryIdFileIndex Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setAccessoryIdFileIndex Scope: Global PAC Instruction (Binary): 25 0a 14 00 Assembly Address in Memory : 0x894a7dc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 0a 14 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setAccessoryIdFileIndex((int)3, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a7dc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar3 = *puVar1; Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = return__0x1c(*(undefined4 *)(iVar2 + 0x50)); Graphic::Character::Scarf_Color(iVar2 + 0xed80,uVar4,uVar3); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setactioncontroller.html": {
    "href": "setactioncontroller.html",
    "title": "setActionController",
    "keywords": "setActionController Sets an action (e.g. cannon attack) to a gimmick. Used in VS turrets. For actual effect to the turret, check How To: Add A Turret. Code Information Name: setActionController Scope: Global PAC Instruction (Binary): 25 19 02 00 Assembly Address in Memory : 0x8940f00 Parameters (int *)gimmick_handle (8 bytes) : Gimmick handle, other kinds of handle won't work. (int)type (8 bytes) : Control Type, expected 0~4. (float)time (8 bytes) : Delay time (cooltime) between actions, as seconds. (float)Var3 (8 bytes) : Can keep zero. Works only when type is 3 or 4. (float)Var4 (8 bytes) : Can keep zero. Works only when type is 3 or 4. (Undefined)Var5 (8 bytes) : Unused, can keep zero. (Undefined)Var6 (8 bytes) : Unused, can keep zero. (Undefined)Var7 (8 bytes) : Unused, can keep zero. To properly use this, do not use 'In sync' (thus avoid 4). type In sync 0x0 No 0x1 No 0x2 No 0x3 No 0x4 Yes (Does not work well) Example Here is one example in hex: 25 19 02 00 / 04 00 00 00 / 0a 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 a0 40 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setActionController((int *)iVar10, (int)1, (float)5, (float)0, (float)0, (float)0, (float)0, (float)0) This activates turret control: 0005B56C 25170600:setActive(8:8B, 2:1) 0005B580 25171C00:addLinkObject(8:7F, 2:244, 8:8B, 2:8, \"attach\") 0005B5AC 25173600:setModelColor(8:7F, 0.0, 2:67, 2:84, 2:FF, 2:FF) 0005B5E0 25190200:setActionController(8:7F, 2:1, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08940f00(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; int iVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); Pac_Get_Param(param_2,5,1,4); Pac_Get_Param(param_2,6,1,4); Pac_Get_Param(param_2,7,1,4); iVar6 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar6 != 0) && (iVar7 = (**(code **)(*(int *)(iVar6 + 4) + 0x34))(iVar6), iVar7 == 10)) { iVar7 = *piVar2; if (iVar7 == 4) { FUN_0894db68(*puVar3,*puVar4,*puVar5,*(int *)(*(int *)(param_1 + 0x10) + 0x108) + 0x16a4,iVar6 ,1); } else if (iVar7 == 3) { FUN_0894db68(*puVar3,*puVar4,*puVar5,*(int *)(*(int *)(param_1 + 0x10) + 0x108) + 0x16a4,iVar6 ,0); } else if (iVar7 == 2) { FUN_0894db68(*puVar3,0,0,*(int *)(*(int *)(param_1 + 0x10) + 0x108) + 0x16a4,iVar6,0); } else if (iVar7 == 1) { FUN_0894db68(*puVar3,0,0,*(int *)(*(int *)(param_1 + 0x10) + 0x108) + 0x16a4,iVar6,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setactive.html": {
    "href": "setactive.html",
    "title": "setActive",
    "keywords": "setActive Activates an object with given handle. Inactive object is invisible and can't interact. Code Information Name: setActive Scope: Global PAC Instruction (Binary): 25 17 06 00 Assembly Address in Memory : 0x8911070 Parameters (int *)handle_id (8 bytes) : The target Handle. (bool)active (8 bytes) : 1 activates the target, 0 deactivates the target. Example Here is one example in hex: 25 17 06 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setActive((int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911070(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 4) + 0x58))(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setactivityparam.html": {
    "href": "setactivityparam.html",
    "title": "setActivityParam",
    "keywords": "setActivityParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setActivityParam Scope: Global PAC Instruction (Binary): 25 21 33 00 Assembly Address in Memory : 0x89b41bc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 33 00 / 04 00 00 00 / 14 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setActivityParam((int *)iVar20, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b41bc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 0xc) + 0x124))(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setactorinfo.html": {
    "href": "setactorinfo.html",
    "title": "setActorInfo",
    "keywords": "setActorInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setActorInfo Scope: Global PAC Instruction (Binary): 25 17 05 00 Assembly Address in Memory : 0x8910f90 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08910f90(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*piVar2 == 0)) { *(byte *)(iVar3 + 0x8c) = *(byte *)(iVar3 + 0x8c) & 0xfd; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setactorlevel.html": {
    "href": "setactorlevel.html",
    "title": "setActorLevel",
    "keywords": "setActorLevel Sets level of an any object (unit, gimmick etc) by the given handle. Code Information Name: setActorLevel Scope: Global PAC Instruction (Binary): 25 17 47 00 Assembly Address in Memory : 0x8915ce0 Parameters (int *)handle_id (8 bytes) : The target handle to apply the level. (int)level (8 bytes) : The level value to set. Example Here is one example in hex: 25 17 47 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 05 00 00 00 Which is interpreted as: setActorLevel((int *)iVar1, (int *)iVar5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915ce0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (*(int *)(iVar3 + 0xcc) != 0) { *(undefined4 *)(*(int *)(iVar3 + 0xcc) + 8) = *puVar2; (**(code **)(*(int *)(iVar3 + 4) + 0x114))(iVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setaddress.html": {
    "href": "setaddress.html",
    "title": "setAddress",
    "keywords": "setAddress Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setAddress Scope: Global PAC Instruction (Binary): 25 10 0e 00 Assembly Address in Memory : 0x890a474 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 10 0e 00 / 02 00 00 00 / 02 00 00 00 / 04 00 00 00 / 40 00 00 00 Which is interpreted as: setAddress((int)2, (int *)iVar64) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a474(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (piVar3 = *(int **)(*(int *)(param_1 + 0x10) + 0x4dc), piVar3 != (int *)0x0)) { (**(code **)(*piVar3 + 0x24))(piVar3,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setadvanceenable.html": {
    "href": "setadvanceenable.html",
    "title": "setAdvanceEnable",
    "keywords": "setAdvanceEnable Enables or disables marching. If marching is disabled, the squad cannot go forward with Patapata command. Used in e.g. Fifty cyclopses. Code Information Name: setAdvanceEnable Scope: Global PAC Instruction (Binary): 25 16 47 00 Assembly Address in Memory : 0x891e2cc Parameters (bool)can_march (8 bytes) : 0 prevents marching, other values allow marching. Example Here is one example in hex: 25 16 47 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setAdvanceEnable((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e2cc(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0xf8); if (iVar2 == 0) { iVar2 = 0; } } if ((iVar2 != 0) && (iVar2 = FUN_088a8650(iVar2,0), iVar2 != 0)) { FUN_088f9ba8(iVar2 + 0x170,*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setadvancespeedratio.html": {
    "href": "setadvancespeedratio.html",
    "title": "setAdvanceSpeedRatio",
    "keywords": "setAdvanceSpeedRatio Changes the march speed. Available in debug menu. Code Information Name: setAdvanceSpeedRatio Scope: Global PAC Instruction (Binary): 25 16 48 00 Assembly Address in Memory : 0x891e378 Parameters (float)duration (8 bytes) : As seconds, how long the march speed change will be applied. -1 for no time limit. (float)multiplier (8 bytes) : Value to multiply to the base march speed. Set to 1 for default march speed. Example Here is one example in hex: 25 16 48 00 / 10 00 00 00 / 00 00 80 bf / 10 00 00 00 / 00 00 40 40 Which is interpreted as: setAdvanceSpeedRatio((float)-1, (float)3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e378(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if ((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,0), iVar3 != 0)) { FUN_08991d3c(*puVar1,*puVar2,iVar3 + 0x290); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setadventradius.html": {
    "href": "setadventradius.html",
    "title": "setAdventRadius",
    "keywords": "setAdventRadius Decides the distance of the units in same squad, as generator level. The spreading distance is random. See also: setReqActorAdventRadius Code Information Name: setAdventRadius Scope: Mission PAC Instruction (Binary): 25 1f 06 00 Assembly Address in Memory : 0x8b5c2d8 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (float)max_x_spread (8 bytes) : The amount to spread in x direction. About 2nd parameters, the cyclopses appeared around 1:36 when the value is 1800.0 and appeared around 00:42 with default value (0). (The 1800 is big value though, around 500 can be found on usage.) Example Here is one example in hex: 25 1f 06 00 / 08 00 00 00 / 1a 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setAdventRadius(((global)int *)giVar26, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c2d8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else if (*piVar1 == -1) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar3 + 0x2c8)); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x20) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setappearanceposition.html": {
    "href": "setappearanceposition.html",
    "title": "setAppearancePosition",
    "keywords": "setAppearancePosition Please describe what this does. Code Information Name: setAppearancePosition Scope: Global PAC Instruction (Binary): 25 16 20 00 Assembly Address in Memory : 0x891b99c Parameters (int *)handle_id (8 bytes) : Handle of the troop. (float)initial_position (8 bytes) : X Position to place the troop units. Example Here is one example in hex: 25 16 20 00 / 08 00 00 00 / 68 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setAppearancePosition(((global)int *)giVar104, (float)0) This is usage of the setAppearancePosition in AoV VS Mission: 0005AF60 25162000:setAppearancePosition(8:68, -100.0) //blue troop 0005AF74 25162100:setRebornPosition(8:68, -200.0) 0005AF88 25162000:setAppearancePosition(8:74, 2100.0) //red troop 0005AF9C 25162100:setRebornPosition(8:74, 2200.0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891b99c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 != 0) { FUN_088de070(*puVar2,iVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setappearitem.html": {
    "href": "setappearitem.html",
    "title": "setAppearItem",
    "keywords": "setAppearItem Sets item drop from the item table. The item can be anything, e.g. potion, material or equipment. For Ka-ching, see setCharinAppearParam. Code Information Name: setAppearItem Scope: Global PAC Instruction (Binary): 25 08 03 00 Assembly Address in Memory : 0x896e890 Parameters (float)drop_chance (8 bytes) : The item drop chance, check below for detail. (int)item_id (8 bytes) : ID of the item. 0 does not drop anything. (int)min_item_level (8 bytes) : Minimal level of the item (for equipment and chest). (int)max_item_level (8 bytes) : Maximum level of the item (for equipment and chest). (int)sound_type (8 bytes) : Item obtain sound, please describe the detail. Keep -1 to set the sound default. Remarks The loot chance is relative to the item drop chance in the same table. For example, if there are items called A, B, C, with chance of 0.3, 0.1, 0.4 for each The drop chance of A is 0.3/(0.3+0.1+0.4) = 37.5% The drop chance of B is 0.1/(0.3+0.1+0.4) = 12.5% The drop chance of C is 0.4/(0.3+0.1+0.4) = 50% Which is total 100%. Example Here is one example in hex: 25 08 03 00 / 10 00 00 00 / 00 00 80 3f / 02 00 00 00 / 31 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: setAppearItem((float)1, (int)49, (int)0, (int)0, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896e890(int param1,undefined4 param2) { undefined4 *loot_chance; undefined4 *puVar1; undefined4 *min_loot_lvl; undefined4 *max_loot_lvl; undefined4 *puVar2; int iVar3; loot_chance = (undefined4 *)Pac_Get_Param(param2,0,1,4); puVar1 = (undefined4 *)Pac_Get_Param(param2,1,1,4); min_loot_lvl = (undefined4 *)Pac_Get_Param(param2,2,1,4); max_loot_lvl = (undefined4 *)Pac_Get_Param(param2,3,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param2,4,1,4); iVar3 = *(int *)(param1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0x188); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { Loot::Load_Loot_Chance(*loot_chance,iVar3,*puVar1,*min_loot_lvl,*max_loot_lvl,*puVar2); } PAC::PAC_setCmdId(param2,0); return; }"
  },
  "setappearitemkilltime.html": {
    "href": "setappearitemkilltime.html",
    "title": "setAppearItemKillTime",
    "keywords": "setAppearItemKillTime Sets duration of the appeared item as seconds. Does not work with chest or ka-ching. Code Information Name: setAppearItemKillTime Scope: Global PAC Instruction (Binary): 25 08 09 00 Assembly Address in Memory : 0x896eae4 Parameters (float)fade_time (8 bytes) : Time before fading out, as seconds. (float)kill_time (8 bytes) : Time before the item is deleted from the map, as seconds. If kill_time is equal or bigger than fade_time, the item is deleted without fading. Example Here is one example in hex: 25 08 09 00 / 10 00 00 00 / 00 00 d0 41 / 10 00 00 00 / 00 00 20 42 Which is interpreted as: setAppearItemKillTime((float)26, (float)40) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896eae4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0x188); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { FUN_089532f4(*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setappearmissileinfo.html": {
    "href": "setappearmissileinfo.html",
    "title": "setAppearMissileInfo",
    "keywords": "setAppearMissileInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setAppearMissileInfo Scope: Global PAC Instruction (Binary): 25 16 37 01 Assembly Address in Memory : 0x892aad0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 16 37 01 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 96 43 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setAppearMissileInfo((int)0, (int)0, (float)300, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892aad0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar5 != 0)) && (iVar5 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar5 + 0x2c) + 0x54),*puVar1), iVar5 != 0)) { FUN_08a4e814(*puVar3,iVar5,*puVar2,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setasqenable.html": {
    "href": "setasqenable.html",
    "title": "setAsqEnable",
    "keywords": "setAsqEnable Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setAsqEnable Scope: Azito PAC Instruction (Binary): 25 1c 18 00 Assembly Address in Memory : 0x8b4f1a0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f1a0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; undefined4 uVar5; undefined4 uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar6 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar5 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = *piVar2; if (((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar3 != 0)) && (iVar3 = FUN_Azito__08b5a618(*(undefined4 *)(iVar3 + 0x38),uVar6,uVar5,1), iVar3 != 0)) { Save::Get_Save_BaseAddr(1); *(bool *)(iVar3 + 0x94) = iVar4 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setattacksoundresponse.html": {
    "href": "setattacksoundresponse.html",
    "title": "setAttackSoundResponse",
    "keywords": "setAttackSoundResponse Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setAttackSoundResponse Scope: Global PAC Instruction (Binary): 25 16 29 00 Assembly Address in Memory : 0x891c00c Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 29 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setAttackSoundResponse((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891c00c(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); FUN_088a9edc(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xf8),*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setautocommand.html": {
    "href": "setautocommand.html",
    "title": "setAutoCommand",
    "keywords": "setAutoCommand Sends command automatically, possibly for multiple times. Unlike sendCommand, this involves drumming, and activates heromode. This disables drum input, but debug mode still can be opened. Does not work properly with miracle (Don dodon dodon) input. Code Information Name: setAutoCommand Scope: Global PAC Instruction (Binary): 25 0c 0d 00 Assembly Address in Memory : 0x8970914 Parameters (int)command_id (8 bytes) : Command Id to perform. (int)repeat_times (8 bytes) : Amount to perform-1. Set 0 to perform only once. -1 performs for infinite amount. Example Here is one example in hex: 25 0c 0d 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: setAutoCommand((int)0, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970914(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; int iVar5; int iVar6; float fVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar5 != 0) { func_0x08b74618(iVar5 + 8); iVar3 = func_0x08b72c48(iVar5 + 500,*puVar1); if (iVar3 != 0) { fVar7 = 0.0; iVar6 = 0; do { iVar4 = (int)*(char *)(iVar3 + iVar6 + 0x38); if (0 < iVar4) { func_0x08b74690(fVar7,iVar5 + 8,iVar4,0); } iVar6 = iVar6 + 1; fVar7 = fVar7 + 0.5; } while (iVar6 < 8); func_0x08b746d8(iVar5 + 8,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setazitoinfo.html": {
    "href": "setazitoinfo.html",
    "title": "setAzitoInfo",
    "keywords": "setAzitoInfo Sets certain hideout related information. The information depends on info_type parameter. Code Information Name: setAzitoInfo Scope: Azito PAC Instruction (Binary): 25 1c 07 00 Assembly Address in Memory : 0x8b4d7e0 Parameters (int)info_type (8 bytes) : Type to get the info. It is limited to 0x1, 0x2, 0x3, 0x7, 0x8, 0x9, 0xA, 0x12. (uint *)value (8 bytes) : Value to set. Depends on the info_type, this can be either boolean or int. For more information about info_type, check getAzitoInfo. Example Here is one example in hex: 25 1c 07 00 / 02 00 00 00 / 0a 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setAzitoInfo((int)10, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d7e0(int param_1,undefined4 param_2) { int *piVar1; int iVar2; undefined4 uVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar4 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { iVar2 = Save::Get_Save_BaseAddr(1); return__0x1c(*(undefined4 *)(iVar2 + 0x50)); Save::Get_Save_BaseAddr(1); uVar3 = Save::Get_Save_BaseAddr(1); iVar2 = Save::Get_BaseAddr__0x78(uVar3,1); if (iVar4 == 0x12) { *(bool *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x28) = *piVar1 != 0; } else if (iVar4 == 10) { *(bool *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x21) = *piVar1 != 0; } else if (iVar4 == 9) { iVar4 = FUN_Azito__08ad37f0(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x1c4)); if (iVar4 != 0) { *(bool *)(iVar4 + 0x361) = *piVar1 != 0; } } else if (iVar4 == 8) { FUN_0884f334(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x14),*piVar1,3); } else if (iVar4 == 7) { FUN_Azito__08ad35f0(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x1c4),*piVar1); } else if (iVar4 == 3) { *(bool *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x20) = *piVar1 != 0; } else if (iVar4 == 2) { *(int *)(*(int *)(iVar2 + 0x44) + 0x550) = *piVar1; } else if (iVar4 == 1) { *(int *)(*(int *)(iVar2 + 0x44) + 0x534) = *piVar1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbasestimmingscript.html": {
    "href": "setbasestimmingscript.html",
    "title": "setBasesTimmingScript",
    "keywords": "setBasesTimmingScript Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setBasesTimmingScript Scope: Azito PAC Instruction (Binary): 25 1d 02 00 Assembly Address in Memory : 0x8b68678 Parameters (uint)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (8 bytes) Example Here is one example in hex: 25 1d 02 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 64 07 00 00 Which is interpreted as: setBasesTimmingScript((int)0, (int *)iVar0, (index)1892) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b68678(int param_1,undefined4 param_2) { uint *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; undefined4 *puVar6; int iVar7; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar7 = *(int *)(param_1 + 0x10); iVar5 = iVar7; if (iVar7 == 0) { iVar5 = 0; } if (iVar5 != 0) { if (iVar7 == 0) { iVar7 = 0x390; } else { iVar7 = iVar7 + 0x390; } if (*puVar1 < 3) { puVar6 = (undefined4 *)(iVar7 + *puVar1 * 8); } else { puVar6 = (undefined4 *)0x0; } uVar4 = *puVar3; *puVar6 = *puVar2; puVar6[1] = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossactionid.html": {
    "href": "setbossactionid.html",
    "title": "setBossActionId",
    "keywords": "setBossActionId Enables or disables boss attacking in sequence with setBossActionId. If enableBossManualCtrl is off, this performs certain attack sequences. Otherwise it performs only the given attack. Code Information Name: setBossActionId Scope: Global PAC Instruction (Binary): 25 21 04 00 Assembly Address in Memory : 0x89b14c8 Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (bool)action_id (8 bytes) : The Action ID to perform. Example Here is one example in hex: 25 21 04 00 / 02 00 00 00 / 64 00 00 00 / 02 00 00 00 / 07 00 00 00 Which is interpreted as: setBossActionId((int)100, (int)7) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b14c8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x318) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossctrlstaggeritem.html": {
    "href": "setbossctrlstaggeritem.html",
    "title": "setBossCtrlStaggerItem",
    "keywords": "setBossCtrlStaggerItem Defines what item will be dropped when the boss is being staggered. Meant for Patapon 2 boss item drop. Code Information Name: setBossCtrlStaggerItem Scope: Mission PAC Instruction (Binary): 25 1f 29 00 Assembly Address in Memory : 0x8b5e4b8 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)item_table_id (8 bytes) : Item table ID to drop when being staggered. Example Here is one example in hex: 25 1f 29 00 / 04 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 Which is interpreted as: setBossCtrlStaggerItem((int *)iVar1, (int)0, (int)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e4b8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b579b0(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossdisableatkmove.html": {
    "href": "setbossdisableatkmove.html",
    "title": "setBossDisableAtkMove",
    "keywords": "setBossDisableAtkMove Enables or disables boss attacking. Note the boss still can attack and deal damage (stomp) even attack move is disabled. Code Information Name: setBossDisableAtkMove Scope: Global PAC Instruction (Binary): 25 21 09 00 Assembly Address in Memory : 0x89b19a8 Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (bool)disabled_attack (8 bytes) : 1 boss does not attack, 0 boss does attack. Example Here is one example in hex: 25 21 09 00 / 02 00 00 00 / 2c 01 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setBossDisableAtkMove((int)300, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b19a8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(bool *)(iVar3 + 0x330) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossinfo.html": {
    "href": "setbossinfo.html",
    "title": "setBossInfo",
    "keywords": "setBossInfo Sets boss information, don't use this. Called in monster.pac once. Patapon 3 original bosses don't use this. Code Information Name: setBossInfo Scope: Global PAC Instruction (Binary): 25 21 12 00 Assembly Address in Memory : 0x89b1ff0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (int)Var5 (8 bytes) (undefined4)Var6 (8 bytes) (undefined4)Var7 (8 bytes) (undefined4)Var8 (8 bytes) (undefined4)Var9 (8 bytes) (undefined4)Var10 (8 bytes) (undefined4)Var11 (8 bytes) (undefined4)Var12 (8 bytes) (undefined4)Var13 (8 bytes) (int)Var14 (8 bytes) (undefined4)Var15 (8 bytes) (undefined4)Var16 (8 bytes) (undefined4)Var17 (8 bytes) (undefined4)Var18 (8 bytes) (undefined4)Var19 (8 bytes) (undefined4)Var20 (8 bytes) (undefined4)Var21 (8 bytes) (undefined4)Var22 (8 bytes) (undefined4)Var23 (8 bytes) (undefined4)Var24 (8 bytes) (undefined4)Var25 (8 bytes) (undefined4)Var26 (8 bytes) (undefined4)Var27 (8 bytes) (undefined4)Var28 (8 bytes) (undefined4)Var29 (8 bytes) (undefined4)Var30 (8 bytes) (undefined4)Var31 (8 bytes) (undefined4)Var32 (8 bytes) (undefined4)Var33 (8 bytes) Example Here is one example in hex: 25 21 12 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 2a 00 00 00 / 20 00 00 00 / 29 00 00 00 / 20 00 00 00 / 2a 00 00 00 / 20 00 00 00 / 2b 00 00 00 / 04 00 00 00 / 28 00 00 00 / 04 00 00 00 / 29 00 00 00 / 04 00 00 00 / 20 00 00 00 / 04 00 00 00 / 1f 00 00 00 / 04 00 00 00 / 36 00 00 00 / 04 00 00 00 / 37 00 00 00 / 04 00 00 00 / 38 00 00 00 / 04 00 00 00 / 21 00 00 00 / 04 00 00 00 / 27 00 00 00 / 04 00 00 00 / 3a 00 00 00 / 20 00 00 00 / 2f 00 00 00 / 20 00 00 00 / 14 00 00 00 / 20 00 00 00 / 30 00 00 00 / 20 00 00 00 / 31 00 00 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 25 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 03 00 00 00 / 20 00 00 00 / 32 00 00 00 / 20 00 00 00 / 33 00 00 00 / 20 00 00 00 / 34 00 00 00 / 04 00 00 00 / 3b 00 00 00 / 04 00 00 00 / 31 00 00 00 / 02 00 00 00 / 0a 0e 00 00 / 02 00 00 00 / 04 0e 00 00 / 02 00 00 00 / 18 0e 00 00 / 02 00 00 00 / 1b 0e 00 00 Which is interpreted as: setBossInfo((int *)iVar20, (int *)iVar42, (float *)fVar41, (float *)fVar42, (float *)fVar43, (int *)iVar40, (int *)iVar41, (int *)iVar32, (int *)iVar31, (int *)iVar54, (int *)iVar55, (int *)iVar56, (int *)iVar33, (int *)iVar39, (int *)iVar58, (float *)fVar47, (float *)fVar20, (float *)fVar48, (float *)fVar49, (int *)iVar0, (int *)iVar37, (float *)fVar0, (float *)fVar1, (float *)fVar2, (float *)fVar3, (float *)fVar50, (float *)fVar51, (float *)fVar52, (int *)iVar59, (int *)iVar49, (int)3594, (int)3588, (int)3608, (int)3611) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1ff0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int *piVar6; undefined4 *puVar7; undefined4 *puVar8; undefined4 *puVar9; undefined4 *puVar10; undefined4 *puVar11; undefined4 *puVar12; undefined4 *puVar13; undefined4 *puVar14; int *piVar15; undefined4 *puVar16; undefined4 *puVar17; undefined4 *puVar18; undefined4 *puVar19; undefined4 *puVar20; undefined4 *puVar21; undefined4 *puVar22; undefined4 *puVar23; undefined4 *puVar24; undefined4 *puVar25; undefined4 *puVar26; undefined4 *puVar27; undefined4 *puVar28; undefined4 *puVar29; undefined4 *puVar30; undefined4 *puVar31; undefined4 *puVar32; undefined4 *puVar33; undefined4 *puVar34; int iVar35; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); puVar8 = (undefined4 *)Pac_Get_Param(param_2,7,1,4); puVar9 = (undefined4 *)Pac_Get_Param(param_2,8,1,4); puVar10 = (undefined4 *)Pac_Get_Param(param_2,9,1,4); puVar11 = (undefined4 *)Pac_Get_Param(param_2,10,1,4); puVar12 = (undefined4 *)Pac_Get_Param(param_2,0xb,1,4); puVar13 = (undefined4 *)Pac_Get_Param(param_2,0xc,1,4); puVar14 = (undefined4 *)Pac_Get_Param(param_2,0xd,1,4); piVar15 = (int *)Pac_Get_Param(param_2,0xe,1,4); puVar16 = (undefined4 *)Pac_Get_Param(param_2,0xf,1,4); puVar17 = (undefined4 *)Pac_Get_Param(param_2,0x10,1,4); puVar18 = (undefined4 *)Pac_Get_Param(param_2,0x11,1,4); puVar19 = (undefined4 *)Pac_Get_Param(param_2,0x12,1,4); puVar20 = (undefined4 *)Pac_Get_Param(param_2,0x13,1,4); puVar21 = (undefined4 *)Pac_Get_Param(param_2,0x14,1,4); puVar22 = (undefined4 *)Pac_Get_Param(param_2,0x15,1,4); puVar23 = (undefined4 *)Pac_Get_Param(param_2,0x16,1,4); puVar24 = (undefined4 *)Pac_Get_Param(param_2,0x17,1,4); puVar25 = (undefined4 *)Pac_Get_Param(param_2,0x18,1,4); puVar26 = (undefined4 *)Pac_Get_Param(param_2,0x19,1,4); puVar27 = (undefined4 *)Pac_Get_Param(param_2,0x1a,1,4); puVar28 = (undefined4 *)Pac_Get_Param(param_2,0x1b,1,4); puVar29 = (undefined4 *)Pac_Get_Param(param_2,0x1c,1,4); puVar30 = (undefined4 *)Pac_Get_Param(param_2,0x1d,1,4); puVar31 = (undefined4 *)Pac_Get_Param(param_2,0x1e,1,4); puVar32 = (undefined4 *)Pac_Get_Param(param_2,0x1f,1,4); puVar33 = (undefined4 *)Pac_Get_Param(param_2,0x20,1,4); puVar34 = (undefined4 *)Pac_Get_Param(param_2,0x21,1,4); iVar35 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar35 != 0) { Boss::SetBossAction(*puVar3,*puVar4,*puVar5,*puVar16,*puVar17,*puVar18,*puVar19,*puVar22,iVar35, *puVar2,*piVar6 != 0,*puVar7,*puVar8,*puVar9,*puVar10,*puVar11,*puVar12, *puVar13,*puVar14,*piVar15 != 0,*puVar20,*puVar21,*puVar23,*puVar24,*puVar25 ,*puVar26,*puVar27,*puVar28,*puVar29,*puVar30,*puVar31,*puVar32,*puVar33, *puVar34); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossmoverange_251f2e00.html": {
    "href": "setbossmoverange_251f2e00.html",
    "title": "setBossMoveRange (251f2e00)",
    "keywords": "setBossMoveRange (251f2e00) Other functions have the same name. Check the Disambiguation page to find them. Sets boss position to move. For retreating, use setBossRetreatPos. Code Information Name: setBossMoveRange Scope: Mission PAC Instruction (Binary): 25 1f 2e 00 Assembly Address in Memory : 0x8b5e9e8 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)max_range (8 bytes) : Maximum move range relative to the world to move, as PSP pixels in world. (float)min_range (8 bytes) : Minimum move range relative to the world to move, as PSP pixels in world. Note that max goes first. (float)init_range (8 bytes) : Initial range relative to the world to move, as PSP pixels in world, when the boss is in out of the given range. Usually it is same value as min_range- Example Here is one example in hex: 25 1f 2e 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 75 44 / 10 00 00 00 / 00 00 2a 44 / 10 00 00 00 / 00 00 2a 44 Which is interpreted as: setBossMoveRange(((global)int *)giVar26, (int)0, (float)980, (float)680, (float)680) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e9e8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); iVar6 = *(int *)(param_1 + 0x10); if (iVar6 == 0) { iVar6 = 0; } else if (*piVar1 == -1) { iVar6 = 0; } else { if (iVar6 == 0) { iVar6 = 0; } iVar6 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar6 + 0x2c8)); if (iVar6 == 0) { iVar6 = 0; } } if (iVar6 != 0) { FUN_Mission__08b57a18(*puVar3,*puVar4,*puVar5,iVar6,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossmoverange_25210a00.html": {
    "href": "setbossmoverange_25210a00.html",
    "title": "setBossMoveRange (25210a00)",
    "keywords": "setBossMoveRange (25210a00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setBossMoveRange Scope: Global PAC Instruction (Binary): 25 21 0a 00 Assembly Address in Memory : 0x89b29f4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b29f4(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar5 != 0) { FUN_08977730(*puVar2,*puVar3,*puVar4,iVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossmoverangelimit_251f2f00.html": {
    "href": "setbossmoverangelimit_251f2f00.html",
    "title": "setBossMoveRangeLimit (251f2f00)",
    "keywords": "setBossMoveRangeLimit (251f2f00) Other functions have the same name. Check the Disambiguation page to find them. Limits the move range of the boss, so it can't move further while not attacking. Code Information Name: setBossMoveRangeLimit Scope: Mission PAC Instruction (Binary): 25 1f 2f 00 Assembly Address in Memory : 0x8b5eb28 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)max_range (8 bytes) : Maximum move range relative to the unit, as PSP pixels in world. Example Here is one example in hex: 25 1f 2f 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 2a 44 Which is interpreted as: setBossMoveRangeLimit(((global)int *)giVar26, (int)0, (float)680) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5eb28(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57aa0(*puVar3,iVar4,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossmoverangelimit_25210c00.html": {
    "href": "setbossmoverangelimit_25210c00.html",
    "title": "setBossMoveRangeLimit (25210c00)",
    "keywords": "setBossMoveRangeLimit (25210c00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setBossMoveRangeLimit Scope: Global PAC Instruction (Binary): 25 21 0c 00 Assembly Address in Memory : 0x89b2ba8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 0c 00 / 04 00 00 00 / 14 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setBossMoveRangeLimit((int *)iVar20, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2ba8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { FUN_08977740(*puVar2,iVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossnodamage.html": {
    "href": "setbossnodamage.html",
    "title": "setBossNoDamage",
    "keywords": "setBossNoDamage Marks the boss as invincible or not. The damage amount is still displayed, but does not take actual damage. Code Information Name: setBossNoDamage Scope: Global PAC Instruction (Binary): 25 21 0f 00 Assembly Address in Memory : 0x89b1a7c Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (bool)is_invincible (8 bytes) : 0 boss takes damage, 1 makes boss invincible. Example Here is one example in hex: 25 21 0f 00 / 02 00 00 00 / 64 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setBossNoDamage((int)100, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1a7c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 0xc) + 0x28))(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossretreatpos.html": {
    "href": "setbossretreatpos.html",
    "title": "setBossRetreatPos",
    "keywords": "setBossRetreatPos Sets the retreating position of the boss. Used in Patapon 2, cannot guarantee to work in Patapon 3. Code Information Name: setBossRetreatPos Scope: Global PAC Instruction (Binary): 25 21 0e 00 Assembly Address in Memory : 0x89b18d8 Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (float)position (8 bytes) : Position to retreat. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b18d8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x32c) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossstate.html": {
    "href": "setbossstate.html",
    "title": "setBossState",
    "keywords": "setBossState Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setBossState Scope: Global PAC Instruction (Binary): 25 21 06 00 Assembly Address in Memory : 0x89b1668 Parameters (int)unique_id (8 bytes) : ID from setReqActorUniqueId. Usually it is 100 (0x64) in 1v1 DLC bosses. (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1668(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x31c) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbossstatephase.html": {
    "href": "setbossstatephase.html",
    "title": "setBossStatePhase",
    "keywords": "setBossStatePhase Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setBossStatePhase Scope: Global PAC Instruction (Binary): 25 21 07 00 Assembly Address in Memory : 0x89b1738 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1738(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 800) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbosstargetpos.html": {
    "href": "setbosstargetpos.html",
    "title": "setBossTargetPos",
    "keywords": "setBossTargetPos Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setBossTargetPos Scope: Global PAC Instruction (Binary): 25 21 08 00 Assembly Address in Memory : 0x89b1808 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 21 08 00 / 02 00 00 00 / 64 00 00 00 / 10 00 00 00 / 00 00 fa 44 Which is interpreted as: setBossTargetPos((int)100, (float)2000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b1808(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x328) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbrakescore.html": {
    "href": "setbrakescore.html",
    "title": "setBrakeScore",
    "keywords": "setBrakeScore Sets VS scoring logic when a squad or gimmick is being killed. Code Information Name: setBrakeScore Scope: Global PAC Instruction (Binary): 25 17 08 00 Assembly Address in Memory : 0x89111b8 Parameters (int *)handle (8 bytes) : The target to be killed to get the score. Can be squad or gimmick. (int)point (8 bytes) : Points to give to the side who killed the squad/gimmick. (int)break_type (8 bytes) : Expected 0~6. Does nothing with fort occupation. break_type Action with killing enemy 0 Gives score to blue team troop 1 Gives score to red team troop 2 Nothing 3 Nothing 4 (Normal) Gives score to the opposite side when being killed 5 When Missile is ready (missile VS only) 6 unused, Score based on troop side flag Remarks For settling the fort occupation score, set break_type 2 or 3, and then settle the score with PAC instructions. This is checked every time during mission. Set break_type to 2 or 3 in setBrakeScore. Get gimmick status with getGimmickPowerGaugePoint. Check with cmd_ifLBE, if the occupation gauge is full. Obtain the score with getBrakeScore. Settle the score with multiSetScore. Deactivate the \"unoccupied\" gimmick object with gimmickGetUserIdI, gimmickSetUserIdI and setActive. Get the occupied gimmick handle with gimmick_getHandle and activate it with setActive. 0005DC7C 25000300:cmd_call(1:37454) ... 00037468 25170700:getActive(8:7F, 4:0) 0003747C 25001700:cmd_ifEQ(4:0, 0.0, 1:32F84) //cmd_end() 00037494 25172900:setMaxHitPoint(8:7F, 2:186A0) /* Checks red team gauge */ 000374A8 25161300:getGimmickPowerGaugePoint(8:7F, 2:1, 20:0, 4:2) 000374CC 25001A00:cmd_ifLBE(20:0, 1.0, 1:3768C) 0003768C 25000700:cmd_mov(8:7F, 8:84) /* settles score */ 000376A0 25170900:getBrakeScore(8:7F, 4:0, 4:1) 000376BC 25161000:multiSetScore(2:1, 2:2, 4:0, 4:2) /* Mark gimmick as \"red team occupied\" (2:1) */ 000376E0 25190800:gimmickGetUserIdI(8:7F, 2:3, 4:3) 000376FC 25190900:gimmickSetUserIdI(8:7F, 2:2, 2:1) /* Hide \"unoccupied\" gimmick structure */ 00037718 25170600:setActive(8:7F, 2:0) 0003772C 25190800:gimmickGetUserIdI(8:7F, 2:0, 4:0) 00037748 25190800:gimmickGetUserIdI(8:7F, 2:1, 4:1) /* Show \"occupied\" gimmick structure */ 00037764 25190100:gimmick_getHandle(4:1, 8:7F) 00037778 25170600:setActive(8:7F, 2:1) ... 000377F0 25000100:cmd_end() /* Checks blue team gauge */ 000374E4 25161300:getGimmickPowerGaugePoint(8:7F, 2:0, 20:0, 4:2) 00037508 25001A00:cmd_ifLBE(20:0, 1.0, 1:37524) 00037524 25000700:cmd_mov(8:7F, 8:84) 00037538 25170900:getBrakeScore(8:7F, 4:0, 4:1) 00037554 25161000:multiSetScore(2:0, 2:2, 4:0, 4:2) /* almost same as red side, excpet the user side is (2:0) */ ... 00037688 25000100:cmd_end() 00037520 25000100:cmd_end() Example Here is one example in hex: 25 17 08 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 04 00 00 00 Which is interpreted as: setBrakeScore((int *)iVar54, (int)3, (int)4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089111b8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; uint uVar6; uint *puVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { *(short *)(iVar4 + 0x86) = (short)*puVar2; *(short *)(iVar4 + 0x88) = (short)*puVar3; iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 3) { //squad puVar7 = *(uint **)(iVar4 + 0x5c); if ((puVar7[2] ^ *(uint *)(iVar4 + 0x60) | *puVar7 ^ *(uint *)(iVar4 + 0x58) | puVar7[1] ^ *(uint *)(iVar4 + 0x5c)) != 0) { uVar6 = puVar7[2]; while( true ) { if ((uVar6 != 0) && (iVar5 = (**(code **)(*(int *)(uVar6 + 4) + 0x34))(uVar6), iVar5 == 9) ) { *(short *)(uVar6 + 0x86) = (short)*puVar2; *(short *)(uVar6 + 0x88) = (short)*puVar3; } uVar6 = _DAT_00000004; if (puVar7 != (uint *)0x0) { puVar7 = (uint *)puVar7[1]; uVar6 = puVar7[1]; } if ((puVar7[2] ^ *(uint *)(iVar4 + 0x60) | *puVar7 ^ *(uint *)(iVar4 + 0x58) | uVar6 ^ *(uint *)(iVar4 + 0x5c)) == 0) break; uVar6 = puVar7[2]; } } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setbreakscoretroop.html": {
    "href": "setbreakscoretroop.html",
    "title": "setBreakScoreTroop",
    "keywords": "setBreakScoreTroop Sets VS scoring logic when any member in the troop is being killed. Code Information Name: setBreakScoreTroop Scope: Global PAC Instruction (Binary): 25 17 67 00 Assembly Address in Memory : 0x89183b0 Parameters (int *)handle (8 bytes) : The target to be killed to get the score. Can be squad or gimmick. (int)point (8 bytes) : Points to give reward, 0 will use default value. (int)break_type (8 bytes) : Expected 0~6. More information in setBrakeScore. Does nothing with fort occupation. (int)apply_to_hero (8 bytes) : Expected -1~1. -1 to apply to everyone, 0 to apply to only non-heroes, 1 to apply to only heroes. Example Here is one example in hex: 25 17 67 00 / 08 00 00 00 / 68 00 00 00 / 02 00 00 00 / 05 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setBreakScoreTroop(((global)int *)giVar104, (int)5, (int)1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089183b0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; int iVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar5 == 0) { iVar5 = 0; } if ((iVar5 != 0) && (iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5), iVar6 == 2)) { FUN_088e3aec(iVar5,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcameraposition.html": {
    "href": "setcameraposition.html",
    "title": "setCameraPosition",
    "keywords": "setCameraPosition Simply moves the position of the Camera in the world. For more options, see cameraMove. Code Information Name: setCameraPosition Scope: Global PAC Instruction (Binary): 25 16 58 00 Assembly Address in Memory : 0x891f97c Parameters (float)pos_x (8 bytes) : X position in the world to move the camera, as PSP pixels. (float)pos_y (8 bytes) : Y position in the world to move the camera, as PSP pixels. (int)Var2 (8 bytes) : unused. Example Here is one example in hex: 25 16 58 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setCameraPosition((float *)fVar0, (float *)fVar1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891f97c(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); (**(code **)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0xd8) + 4) + 0x24))(); FUN_0890f8a0(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xd8),0,1); FUN_0890eaf4(*puVar1,0,*(int *)(*(int *)(param_1 + 0x10) + 0xd8) + 0x30,0,0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcamerasight.html": {
    "href": "setcamerasight.html",
    "title": "setCameraSight",
    "keywords": "setCameraSight Meant for debug mode. Doesn't work correctly. Code Information Name: setCameraSight Scope: Global PAC Instruction (Binary): 25 16 83 00 Assembly Address in Memory : 0x8921478 Parameters (int)Var0 (8 bytes) (Undefined)Var1 (8 bytes) Example Here is one example in hex: 25 16 83 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setCameraSight((int)1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921478(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_0890fa64(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xd8),*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcancaptureitem.html": {
    "href": "setcancaptureitem.html",
    "title": "setCanCaptureItem",
    "keywords": "setCanCaptureItem Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setCanCaptureItem Scope: Global PAC Instruction (Binary): 25 17 69 00 Assembly Address in Memory : 0x89185d8 Parameters (int *)handle (8 bytes) : Handle to set if can capture item or not. (bool)Var1 (8 bytes) (bool)Var2 (8 bytes) Example Here is one example in hex: 25 17 69 00 / 08 00 00 00 / 74 00 00 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setCanCaptureItem(((global)int *)giVar116, (int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089185d8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { (**(code **)(*(int *)(iVar4 + 4) + 0x11c))(iVar4,*piVar2 != 0,*piVar3 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcapture.html": {
    "href": "setcapture.html",
    "title": "setCapture",
    "keywords": "setCapture Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setCapture Scope: Global PAC Instruction (Binary): 25 21 18 00 Assembly Address in Memory : 0x89b2d38 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 21 18 00 / 04 00 00 00 / 14 00 00 00 / 08 00 00 00 / 6e 01 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setCapture((int *)iVar20, ((global)int *)giVar366, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2d38(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; uint uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if ((iVar4 != 0) && (iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1), iVar5 != 0)) { FUN_0887ddd0(iVar5,1); Gimmick::Gimmick_Set_Position(iVar5,*(undefined4 *)(iVar4 + 0x7c),*puVar3,0); uVar6 = *(uint *)(iVar5 + 0x120) & 0xffffffbe; *(uint *)(iVar5 + 0x120) = *(uint *)(iVar5 + 0x120) & 0xfffffffe; *(uint *)(iVar5 + 0x120) = uVar6; *(uint *)(iVar5 + 0x120) = uVar6 | 0x20; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setchangeauidtimming.html": {
    "href": "setchangeauidtimming.html",
    "title": "setChangeAUIDTimming",
    "keywords": "setChangeAUIDTimming Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setChangeAUIDTimming Scope: Global PAC Instruction (Binary): 25 19 18 00 Assembly Address in Memory : 0x89426a8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 19 18 00 / 04 00 00 00 / 40 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: setChangeAUIDTimming((int *)iVar64, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089426a8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { FUN_088d5cec(*puVar2,iVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcharinappearparam.html": {
    "href": "setcharinappearparam.html",
    "title": "setCharinAppearParam",
    "keywords": "setCharinAppearParam Defines Ka-ching drop information. Ka-ching is Charing in Japanese version. Code Information Name: setCharinAppearParam Scope: Global PAC Instruction (Binary): 25 08 08 00 Assembly Address in Memory : 0x896e9a8 Parameters (int)min_kaching_particle (8 bytes) : Min visual coin amount of Ka-ching. (int)max_kaching_particle (8 bytes) : Max visual coin amount of Ka-ching. (int)min_kaching_amount (8 bytes) : Minimum Ka-ching amount per particle (coin). (int)max_kaching_amount (8 bytes) : Maximum Ka-ching amount per particle (coin). (float)fade_time (8 bytes) : Time before fading out, as seconds. (float)kill_time (8 bytes) : Time before the item is deleted from the map, as seconds. If Ka-ching amount is set to too big value, the Ka-ching doesn't drop at all. Example Here is one example in hex: 25 08 08 00 / 02 00 00 00 / 04 00 00 00 / 02 00 00 00 / 0a 00 00 00 / 08 00 00 00 / 60 00 00 00 / 08 00 00 00 / 32 00 00 00 / 10 00 00 00 / 00 00 80 41 / 10 00 00 00 / 00 00 f0 41 Which is interpreted as: setCharinAppearParam((int)4, (int)10, ((global)int *)giVar96, ((global)int *)giVar50, (float)16, (float)30) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896e9a8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; int iVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); iVar7 = *(int *)(param_1 + 0x10); if (iVar7 == 0) { iVar7 = 0; } else { if (iVar7 == 0) { iVar7 = 0; } iVar7 = *(int *)(iVar7 + 0x188); if (iVar7 == 0) { iVar7 = 0; } } if (iVar7 != 0) { FUN_08953250(*puVar5,*puVar6,iVar7,*puVar1,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setchatballoonoffset.html": {
    "href": "setchatballoonoffset.html",
    "title": "setChatBalloonOffset",
    "keywords": "setChatBalloonOffset Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setChatBalloonOffset Scope: Azito PAC Instruction (Binary): 25 1c 2e 00 Assembly Address in Memory : 0x8b50118 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 1c 2e 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 20 41 / 10 00 00 00 / 00 00 50 41 Which is interpreted as: setChatBalloonOffset((int)0, (float)10, (float)13) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b50118(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; undefined4 local_10; undefined4 local_c; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar4 = Save::Get_Save_BaseAddr(1); iVar5 = Save::Get_BaseAddr__0x78(uVar4,1); local_10 = *puVar2; local_c = *puVar3; FUN_089cfaec(*(undefined4 *)(*(int *)(iVar5 + 100) + 0x18c),*puVar1,&local_10); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setchoice.html": {
    "href": "setchoice.html",
    "title": "setChoice",
    "keywords": "setChoice Adds choice for a debug menu. After adding all choices, doSelect must be called. Code Information Name: setChoice Scope: Global PAC Instruction (Binary): 25 03 01 00 Assembly Address in Memory : 0x892c72c Parameters (String)text : Text to show in the menu. (Address)address (4 bytes) : Address to jump when the item is being selected (pressed). Remarks This is for debug menu. The position is fixed, features are limited, and cannot be localised at all. For localisation and more customisation, use showDialogEx instead. Example Here is one example in hex: 25 03 01 00 / 4f 50 45 4e / 20 41 4c 4c / 20 54 49 50 / 53 00 00 00 / 74 a1 03 00 Which is interpreted as: setChoice(\"OPEN ALL TIPS\", 0x3a174) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892c72c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; int iVar3; undefined auStack320 [60]; undefined4 local_104; undefined auStack256 [256]; Pac_Get_StringParam(param_2,auStack256); puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); local_104 = *puVar1; iVar3 = *(int *)(param_1 + 0x10); uVar2 = FUN_0892c90c(auStack320,iVar3,auStack256,&DAT_08a60080,&local_104,&DAT_08aabddc); FUN_0892c7c0(iVar3 + 0x304,uVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setclassdata.html": {
    "href": "setclassdata.html",
    "title": "setClassData",
    "keywords": "setClassData Sets unlock status, experience or class skill experience for a class. Code Information Name: setClassData Scope: Global PAC Instruction (Binary): 25 0a 10 00 Assembly Address in Memory : 0x894a28c Parameters (int)unit_type (8 bytes) : 0 is Hero, 1 is Ton, 2 is Chin, 3 is Kan. (int)class_id (8 bytes) : Class ID. (int)data_type (8 bytes) : Expected 0~2. (bool/int/float)class_data (8 bytes) : Depends on data_type. data_type type of class_data class_data info 0 lock/unlock 0 locks the character, 1 opens the character 1 int level 2 float class skill exp CS exp percentage per each, 3~5 is max depends on class. Example Here is one example in hex: 25 0a 10 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: setClassData((int)0, (int)2, (int)1, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a28c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 *puVar4; int iVar5; int iVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar6 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); iVar7 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,2,1,4); iVar5 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x1c(*(undefined4 *)(iVar3 + 0x50)); iVar3 = iVar6 * 0x1620 + iVar3 + 0x9500; puVar4 = (undefined4 *)0x0; if (iVar3 != 0) { puVar4 = (undefined4 *)(iVar3 + iVar7 * 0x84 + 0x14); } if (puVar4 != (undefined4 *)0x0) { if (iVar5 == 2) { puVar4[0x14] = *puVar2; puVar4[0x15] = *puVar2; puVar4[0x16] = *puVar2; puVar4[0x17] = *puVar2; puVar4[0x18] = *puVar2; puVar4[0x19] = *puVar2; puVar4[0x1a] = *puVar2; puVar4[0x1b] = *puVar2; if (iVar7 != 0x19) { FUN_089600a8(puVar4); } } else if (iVar5 == 1) { FUN_0894b264(param_1,iVar3,puVar4,iVar7,*puVar2); } else if (iVar5 == 0) { *puVar4 = *puVar2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setclassmaskid.html": {
    "href": "setclassmaskid.html",
    "title": "setClassMaskId",
    "keywords": "setClassMaskId Sets mask ID of a certain class. (Seems like this doesn't work. Please describe about this more.) Code Information Name: setClassMaskId Scope: Global PAC Instruction (Binary): 25 16 25 00 Assembly Address in Memory : 0x891bd68 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)mask_id (8 bytes) : Mask ID to set, please add what this does mean. Example Here is one example in hex: 25 16 25 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setClassMaskId((int *)iVar54, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891bd68(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { *(undefined4 *)(iVar3 + 0xa00) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcloudylevel.html": {
    "href": "setcloudylevel.html",
    "title": "setCloudyLevel",
    "keywords": "setCloudyLevel Sets the cloud amount scale, in range of 0~1. Code Information Name: setCloudyLevel Scope: Global PAC Instruction (Binary): 25 16 74 00 Assembly Address in Memory : 0x8920b84 Parameters (float)cloud_level (8 bytes) : Cloud amount scale to set. 0 is no cloud, 1 has most clouds. Example Here is one example in hex: 25 16 74 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setCloudyLevel((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920b84(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_088fdda0(*puVar1,iVar2 + 0x1d0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcollisionnothittroopp.html": {
    "href": "setcollisionnothittroopp.html",
    "title": "setCollisionNotHitTroopP",
    "keywords": "setCollisionNotHitTroopP Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setCollisionNotHitTroopP Scope: Global PAC Instruction (Binary): 25 21 17 00 Assembly Address in Memory : 0x89b2cc8 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b2cc8(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar2 != 0) { FUN_0897bedc(*(undefined4 *)(iVar2 + 0xd0)); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcollisionsize.html": {
    "href": "setcollisionsize.html",
    "title": "setCollisionSize",
    "keywords": "setCollisionSize Sets value of the collision hitbox. Code Information Name: setCollisionSize Scope: Global PAC Instruction (Binary): 25 17 42 00 Assembly Address in Memory : 0x89157f4 Parameters (int *)handle_id (8 bytes) : The target handle. (bool)bVar1 (8 bytes) : Usually this value is 0, please describe what this does. (float)width (8 bytes) : Width of the collision box. (float)height (8 bytes) : Height of the collision box. Example Here is one example in hex: 25 17 42 00 / 04 00 00 00 / 32 00 00 00 / 02 00 00 00 / 00 00 00 00 / 40 00 00 00 / 34 00 00 00 / 40 00 00 00 / 35 00 00 00 Which is interpreted as: setCollisionSize((int *)iVar50, (int)0, ((global)float *)gfVar52, ((global)float *)gfVar53) This is the Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089157f4(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (*piVar1 != -1) { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar5 == 0) { iVar5 = 0; } if ((iVar5 != 0) && (*(int *)(iVar5 + 0xd0) != 0)) { iVar5 = Set_Collision(*(int *)(iVar5 + 0xd0) + 0xa0,*puVar2); local_4 = *puVar4; local_8 = *puVar3; if (iVar5 != 0) { local_10 = *(undefined4 *)(iVar5 + 0x80); local_c = *(undefined4 *)(iVar5 + 0x84); FUN_0886f4dc(iVar5,&local_10,&local_8); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcommandmonitor.html": {
    "href": "setcommandmonitor.html",
    "title": "setCommandMonitor",
    "keywords": "setCommandMonitor Unimplemented. Code Information Name: setCommandMonitor Scope: Global PAC Instruction (Binary): 25 10 05 00 Assembly Address in Memory : 0x8909f04 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08909f04(undefined4 param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setconnectionicondraw.html": {
    "href": "setconnectionicondraw.html",
    "title": "setConnectionIconDraw",
    "keywords": "setConnectionIconDraw Enables or disables the connecting icon (e.g. while joining other's hideout) Code Information Name: setConnectionIconDraw Scope: Azito PAC Instruction (Binary): 25 1c 2f 00 Assembly Address in Memory : 0x8b501e8 Parameters (bool)enabled (8 bytes) : 1 enables the connection icon, 0 deletes the icon. Example Here is one example in hex: 25 1c 2f 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setConnectionIconDraw((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b501e8(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); FUN_Azito__08acbeb8(*(undefined4 *)(*(int *)(param_1 + 0x10) + 500),*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setcpuclockmode.html": {
    "href": "setcpuclockmode.html",
    "title": "setCpuClockMode",
    "keywords": "setCpuClockMode Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setCpuClockMode Scope: Global PAC Instruction (Binary): 25 09 0e 00 Assembly Address in Memory : 0x8949138 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 09 0e 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: setCpuClockMode((int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08949138(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = *puVar1; iVar2 = zero_if_08aabe38_is_zero(1); FUN_088730e8(iVar2 + 0x1d50,uVar3); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdamageparam.html": {
    "href": "setdamageparam.html",
    "title": "setDamageParam",
    "keywords": "setDamageParam Matches stat of an object to the another one. Used for connecting parent stat to the child. Code Information Name: setDamageParam Scope: Global PAC Instruction (Binary): 25 17 44 00 Assembly Address in Memory : 0x8915a24 Parameters (int *)dest_handle_id (8 bytes) : The handle of the destination stat. (int *)source_handle_id (8 bytes) : The handle of the source stat. Example Here is one example in hex: 25 17 44 00 / 08 00 00 00 / ff 01 00 00 / 08 00 00 00 / 5b 00 00 00 Which is interpreted as: setDamageParam(((global)int *)giVar511, ((global)int *)giVar91) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915a24(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (*piVar2 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar2,1); if (iVar3 == 0) { iVar3 = 0; } if ((iVar3 != 0) && (*piVar1 != -1)) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { (**(code **)(*(int *)(iVar4 + 4) + 0x9c))(iVar4,iVar3); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdead.html": {
    "href": "setdead.html",
    "title": "setDead",
    "keywords": "setDead Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDead Scope: Global PAC Instruction (Binary): 25 21 22 00 Assembly Address in Memory : 0x89b362c Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b362c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { (**(code **)(*(int *)(*(int *)(iVar2 + 0x7c) + 4) + 0x88))(0,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdeathcall.html": {
    "href": "setdeathcall.html",
    "title": "setDeathCall",
    "keywords": "setDeathCall Calls specific instructions when any unit in the generator is dead. This can be used for checkpoint to load entities (e.g. Bonedeth sturctures in the middle of the mission). Code Information Name: setDeathCall Scope: Mission PAC Instruction (Binary): 25 1f 08 00 Assembly Address in Memory : 0x8b5c548 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (MemoryAddress)pac_address_in_memory (8 bytes) : Obtained from getPack. The memory address where the whole PAC instructions start. (Address)address (8 bytes) : Address, offset from PAC file, to call when an enemy is dead. If does nothing, put an address where is cmd_end. Remarks The dead object handles are already deleted when this is called. Use setUnitCtrlTimmingScript_Int if the object information is needed. Example Here is one example in hex: 25 1f 08 00 / 08 00 00 00 / 1a 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 80 38 00 00 Which is interpreted as: setDeathCall(((global)int *)giVar26, (int *)iVar0, (index)14464) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c548(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8), *piVar1); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { uVar5 = *puVar3; *(undefined4 *)(iVar4 + 0x680) = *puVar2; *(undefined4 *)(iVar4 + 0x684) = uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdecay.html": {
    "href": "setdecay.html",
    "title": "setDecay",
    "keywords": "setDecay Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDecay Scope: Global PAC Instruction (Binary): 25 17 17 00 Assembly Address in Memory : 0x89123f8 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 17 17 00 / 04 00 00 00 / 15 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 8f c2 75 3f Which is interpreted as: setDecay((int *)iVar21, (int)0, (float)0.96) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089123f8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (param_1 == 0) { iVar4 = 0; } else { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 == 0) { iVar4 = 0; } else { iVar4 = *(int *)(iVar4 + 200); if (iVar4 == 0) { iVar4 = 0; } } } if (iVar4 == 0) goto LAB_089124f0; if (*piVar2 == 1) { *(undefined4 *)(iVar4 + 0x174) = *puVar3; LAB_089124dc: uVar5 = *(undefined4 *)(iVar4 + 0x170); } else { if (*piVar2 == 0) { *(undefined4 *)(iVar4 + 0x170) = *puVar3; goto LAB_089124dc; } uVar5 = *(undefined4 *)(iVar4 + 0x170); } *(undefined4 *)(iVar4 + 0x168) = uVar5; *(undefined4 *)(iVar4 + 0x16c) = *(undefined4 *)(iVar4 + 0x174); LAB_089124f0: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdefaultstagesize.html": {
    "href": "setdefaultstagesize.html",
    "title": "setDefaultStageSize",
    "keywords": "setDefaultStageSize Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDefaultStageSize Scope: Global PAC Instruction (Binary): 25 16 06 01 Assembly Address in Memory : 0x8928590 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 06 01 / 10 00 00 00 / 00 b0 14 45 Which is interpreted as: setDefaultStageSize((float)2379) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928590(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x3c) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdelete.html": {
    "href": "setdelete.html",
    "title": "setDelete",
    "keywords": "setDelete Deletes an object by a given handle. Not known if this does work. Code Information Name: setDelete Scope: Global PAC Instruction (Binary): 25 21 2a 00 Assembly Address in Memory : 0x89b3c4c Parameters (int *)handle_id (8 bytes) : Handle ID of the object to delete. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3c4c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar2 != 0) { FUN_0897b738(iVar2,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdialoginformationex.html": {
    "href": "setdialoginformationex.html",
    "title": "setDialogInformationEx",
    "keywords": "setDialogInformationEx Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDialogInformationEx Scope: Global PAC Instruction (Binary): 25 03 0f 00 Assembly Address in Memory : 0x892df88 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (uint)Var4 (4 bytes) (int...)Vars5 (>= 4 bytes) ... means any amounts of parameter. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892df88(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 *puVar3; int *piVar4; int *piVar5; int *piVar6; int *piVar7; uint *puVar8; int *piVar9; undefined4 uVar10; int iVar11; int iVar12; float *pfVar13; undefined4 *puVar14; int iVar15; uint uVar16; uint uVar17; int iVar18; float local_30; float local_2c; float local_28; float local_24; undefined4 local_20 [8]; Get_Execution_Pause_Phase(param_2); Save::Get_Save_BaseAddr(1); uVar2 = FUN_08a1ee40(*(undefined4 *)(param_1 + 0x1c)); puVar3 = (undefined4 *)&DAT_00000020; puVar14 = local_20; puVar1 = puVar14; while (puVar1 != (undefined4 *)0x0) { *(undefined *)puVar14 = 0; puVar14 = (undefined4 *)((int)puVar14 + 1); puVar3 = (undefined4 *)((int)puVar3 + -1); puVar1 = puVar3; } piVar4 = (int *)Pac_Get_Param(param_2,0,1,4); piVar5 = (int *)Pac_Get_Param(param_2,1,1,4); piVar6 = (int *)Pac_Get_Param(param_2,2,1,4); piVar7 = (int *)Pac_Get_Param(param_2,3,1,4); puVar8 = (uint *)Pac_Get_Param(param_2,4,0,4); uVar17 = DAT_08a70d08; if ((int)*puVar8 < (int)DAT_08a70d08) { uVar17 = *puVar8; } iVar15 = 0; if (0 < (int)uVar17) { puVar14 = local_20; do { piVar9 = (int *)Pac_Get_Param(param_2,5,0,4); iVar18 = *piVar9; if (iVar18 < 0) { uVar10 = 0; } else { iVar11 = FUN_0883bc1c(param_2); iVar12 = Save::Get_Save_BaseAddr(1); uVar10 = Message::Get_MsgAddr_With_FullID(iVar12 + 0x98,*(undefined4 *)(iVar11 + iVar18)); } *puVar14 = uVar10; iVar15 = iVar15 + 1; puVar14 = puVar14 + 1; } while (iVar15 < (int)uVar17); } FUN_08a1df88(uVar2,&DAT_08a60088); uVar16 = 0; if (uVar17 != 0) { puVar14 = local_20; do { FUN_08a1e190(uVar2,*puVar14); uVar16 = uVar16 + 1; puVar14 = puVar14 + 1; } while (uVar16 < uVar17); } FUN_08a1e1c8(uVar2); local_28 = (float)*piVar6; local_24 = (float)*piVar7; FUN_08a1e91c(uVar2,&local_28); pfVar13 = (float *)FUN_08a1e878(uVar2); local_2c = (float)*piVar5 - pfVar13[1] * 0.5; local_30 = (float)*piVar4 - *pfVar13 * 0.5; FUN_08a1e7d8(uVar2,&local_30); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdirection.html": {
    "href": "setdirection.html",
    "title": "setDirection",
    "keywords": "setDirection Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDirection Scope: Global PAC Instruction (Binary): 25 17 5e 00 Assembly Address in Memory : 0x8917b80 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 5e 00 / 04 00 00 00 / 40 00 00 00 / 20 00 00 00 / 02 00 00 00 Which is interpreted as: setDirection((int *)iVar64, (float *)fVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917b80(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x94) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisableabnormal.html": {
    "href": "setdisableabnormal.html",
    "title": "setDisableAbnormal",
    "keywords": "setDisableAbnormal Enables or disables specific status effect. This is unused. Code Information Name: setDisableAbnormal Scope: Global PAC Instruction (Binary): 25 21 25 00 Assembly Address in Memory : 0x89b379c Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)status_effect_id (8 bytes) : ID of the status effect to enable/disable. (int)disable (8 bytes) : Please describe which one disables status effect. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b379c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar4 != 0) { switch(*puVar2) { case 0: Set_StatusEffect_ImmuneFlag(iVar4,1,*piVar3 != 0); break; case 1: Set_StatusEffect_ImmuneFlag(iVar4,2,*piVar3 != 0); break; case 2: Set_StatusEffect_ImmuneFlag(iVar4,6,*piVar3 != 0); break; case 3: Set_StatusEffect_ImmuneFlag(iVar4,4,*piVar3 != 0); break; case 4: Set_StatusEffect_ImmuneFlag(iVar4,3,*piVar3 != 0); break; case 5: Set_StatusEffect_ImmuneFlag(iVar4,5,*piVar3 != 0); break; case 6: Set_StatusEffect_ImmuneFlag(iVar4,0,*piVar3 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablebacklightoff.html": {
    "href": "setdisablebacklightoff.html",
    "title": "setDisableBacklightOff",
    "keywords": "setDisableBacklightOff Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableBacklightOff Scope: Global PAC Instruction (Binary): 25 09 0d 00 Assembly Address in Memory : 0x89490d4 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 09 0d 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setDisableBacklightOff((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089490d4(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); uVar2 = FUN_088714d8(1); FUN_088715d4(uVar2,*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablebeatguide.html": {
    "href": "setdisablebeatguide.html",
    "title": "setDisableBeatGuide",
    "keywords": "setDisableBeatGuide Enables or disables the flashing beat border. DoI disables the guide with this. This is separated from with system setting. Code Information Name: setDisableBeatGuide Scope: Global PAC Instruction (Binary): 25 0c 0a 00 Assembly Address in Memory : 0x8970798 Parameters (bool)set_delete_flag (8 bytes) If set_delete_flag is 0, it does existing_value ~& beat_guide_flag, otherwise it performs existing_value | beat_guide_flag(or), note the disable flag is 1. (bool)beat_guide_flag (8 bytes) : If this and 1st parameter are 1, the beat guide is disabled. If 1st parameter is 0 and this is 0, it will preserve the current state. If 1st parameter is 0 and this is 1, it will forcefully enable rhythm border. If both set_delete_flag beat_guide_flag are set to 1, the beat guide is disabled. Example Here is one example in hex: 25 0c 0a 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableBeatGuide((int)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970798(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { if (*piVar1 == 0) { func_0x08b5f6a8(iVar3,*puVar2); } else { func_0x08b5f680(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablecommandguide.html": {
    "href": "setdisablecommandguide.html",
    "title": "setDisableCommandGuide",
    "keywords": "setDisableCommandGuide Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableCommandGuide Scope: Global PAC Instruction (Binary): 25 0c 20 00 Assembly Address in Memory : 0x89712fc Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 0c 20 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 02 00 00 00 Which is interpreted as: setDisableCommandGuide((int)1, (int)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089712fc(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { if (*piVar1 == 0) { func_0x08b5f788(iVar3,*puVar2); } else { func_0x08b5f760(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablefevergauge.html": {
    "href": "setdisablefevergauge.html",
    "title": "setDisableFeverGauge",
    "keywords": "setDisableFeverGauge Shows or hides the fever worm. Code Information Name: setDisableFeverGauge Scope: Global PAC Instruction (Binary): 25 0c 29 00 Assembly Address in Memory : 0x89717a8 Parameters (bool)disable_fever_gauge (8 bytes) : 0 enables fever gauge, otherwise fever gauge is disabled. Remarks This function stores 0 or 1 to 0x08b969c0, which can be changed also with direct Assembly code. Execution order If this is called too early, this won't work. Set this at least e.g. callback of setMissionTimmingScript. But for good UX design practice, avoid using this. Example Here is one example in hex: 25 0c 29 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableFeverGauge((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089717a8(undefined4 param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); DAT_08b969c0 = *piVar1 == 0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisableherovoice.html": {
    "href": "setdisableherovoice.html",
    "title": "setDisableHeroVoice",
    "keywords": "setDisableHeroVoice Sets if drum shout is on or off. Works only when drum shout is enabled in system setting. Code Information Name: setDisableHeroVoice Scope: Global PAC Instruction (Binary): 25 0c 23 00 Assembly Address in Memory : 0x897148c Parameters (int)drum_id (8 bytes) : Drum ID to enable/disable the drum shout. Set 0 to target all. (bool)disabled (8 bytes) : 1 to disable, 0 to enable. Example Here is one example in hex: 25 0c 23 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableHeroVoice((int)3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0897148c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { func_0x08b7f210(iVar3 + 0x1e8,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablehpgaugeview.html": {
    "href": "setdisablehpgaugeview.html",
    "title": "setDisableHpgaugeView",
    "keywords": "setDisableHpgaugeView Disables stamina view on the top left during PVE Mission. Can be used when e.g. story/guide before actually starting the mission (Archfiend of Restraint 1st floor). Code Information Name: setDisableHpgaugeView Scope: Global PAC Instruction (Binary): 25 16 99 00 Assembly Address in Memory : 0x89223e0 Parameters (bool)set_delete_flag (8 bytes) If set_delete_flag is 0, it does existing_value ~& hp_gauge_flag, otherwise it performs existing_value | hp_gauge_flag(or), note the disable flag is 1. (bool)hp_gauge_flag (8 bytes) : If this and 1st parameter are 1, the beat guide is disabled. If 1st parameter is 0 and this is 0, it will preserve the current state. If 1st parameter is 0 and this is 1, it will forcefully enable HP gauge. If both set_delete_flag hp_gauge_flag are set to 1, the HP gauge is disabled. Example Here is one example in hex: 25 16 99 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableHpgaugeView((int)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089223e0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x44), iVar3 != 0)) { if (*piVar1 == 0) { func_0x08b32628(iVar3,*puVar2); } else { func_0x08b32618(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisableinvalidnotrespassing.html": {
    "href": "setdisableinvalidnotrespassing.html",
    "title": "setDisableInvalidNoTrespassing",
    "keywords": "setDisableInvalidNoTrespassing Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableInvalidNoTrespassing Scope: Global PAC Instruction (Binary): 25 16 dd 00 Assembly Address in Memory : 0x8923774 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923774(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 != 0) { iVar3 = *piVar2; if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0xf8); if (iVar4 == 0) { iVar4 = 0; } } iVar4 = FUN_088a8650(iVar4,*puVar1); *(bool *)(iVar4 + 0x370) = iVar3 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablekey.html": {
    "href": "setdisablekey.html",
    "title": "setDisableKey",
    "keywords": "setDisableKey Enables or disables drum key inputs. Other keys (camera turn, mission cancel menu etc) are functional. Used in Queen Kharma Bada Bada Bada Bon, tutorials in e.g. Defence practice. Code Information Name: setDisableKey Scope: Global PAC Instruction (Binary): 25 0c 07 00 Assembly Address in Memory : 0x897062c Parameters (bool)disable_keyinput (8 bytes) : Enables key input if this is 0, otherwise the key input is disabled. (undefined4)Var1 (8 bytes) : ??? Example Here is one example in hex: 25 0c 07 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableKey((int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0897062c(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { if (*piVar1 == 0) { func_0x08b5f5e0(iVar3,*puVar2); } else { func_0x08b5f5d0(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablepercussionflag.html": {
    "href": "setdisablepercussionflag.html",
    "title": "setDisablePercussionFlag",
    "keywords": "setDisablePercussionFlag Enables or disables specific drum or all drums. Code Information Name: setDisablePercussionFlag Scope: Global PAC Instruction (Binary): 25 0c 18 00 Assembly Address in Memory : 0x8970ee8 Parameters (int)drum_id (8 bytes) : Drum ID to activate/deactivate the input. Set 0 to target all. (bool)disabled (8 bytes) : 1 to disable, 0 to enable. Example Here is one example in hex: 25 0c 18 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisablePercussionFlag((int)3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970ee8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); func_0x08b5f878(*puVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablepercussionview.html": {
    "href": "setdisablepercussionview.html",
    "title": "setDisablePercussionView",
    "keywords": "setDisablePercussionView Enables or disables visualising the drum hit icon. Works only when drum view is enabled in system setting. Code Information Name: setDisablePercussionView Scope: Global PAC Instruction (Binary): 25 0c 1b 00 Assembly Address in Memory : 0x8971030 Parameters (int)drum_id (8 bytes) : Drum ID to enable/disable the visual. Set 0 to target all. (bool)disabled (8 bytes) : 1 to disable, 0 to enable. Example Here is one example in hex: 25 0c 1b 00 / 02 00 00 00 / 03 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisablePercussionView((int)3, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08971030(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar3 != 0) { func_0x08b5f6e8(iVar3,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisableselectaction.html": {
    "href": "setdisableselectaction.html",
    "title": "setDisableSelectAction",
    "keywords": "setDisableSelectAction Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableSelectAction Scope: Global PAC Instruction (Binary): 25 21 3a 00 Assembly Address in Memory : 0x89b4628 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 21 3a 00 / 02 00 00 00 / 64 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableSelectAction((int)100, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b4628(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(bool *)(iVar3 + 0x59d) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablesimplehpgaugeview.html": {
    "href": "setdisablesimplehpgaugeview.html",
    "title": "setDisableSimpleHpgaugeView",
    "keywords": "setDisableSimpleHpgaugeView Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableSimpleHpgaugeView Scope: Global PAC Instruction (Binary): 25 16 98 00 Assembly Address in Memory : 0x8922348 Parameters (int)Var0 (8 bytes) (Undefined)Var1 (8 bytes) Example Here is one example in hex: 25 16 98 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableSimpleHpgaugeView((int)1, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922348(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x48), iVar2 != 0)) { FUN_08a499bc(iVar2,*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablesquadhpgaugeview.html": {
    "href": "setdisablesquadhpgaugeview.html",
    "title": "setDisableSquadHpgaugeView",
    "keywords": "setDisableSquadHpgaugeView Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableSquadHpgaugeView Scope: Global PAC Instruction (Binary): 25 16 97 00 Assembly Address in Memory : 0x8922490 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 97 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 35 00 00 00 Which is interpreted as: setDisableSquadHpgaugeView((int)0, (int *)iVar53) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922490(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar2,1), iVar3 != 0) ) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { *(bool *)(iVar3 + 0x950) = *piVar1 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisablethroughattack.html": {
    "href": "setdisablethroughattack.html",
    "title": "setDisableThroughAttack",
    "keywords": "setDisableThroughAttack Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDisableThroughAttack Scope: Global PAC Instruction (Binary): 25 19 1b 00 Assembly Address in Memory : 0x89429e8 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 19 1b 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableThroughAttack((int *)iVar0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089429e8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *(byte *)(iVar3 + 0x1d5) = *(byte *)(iVar3 + 0x1d5) & 0xef | (*piVar2 != 0) << 4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdisableversusstringrender.html": {
    "href": "setdisableversusstringrender.html",
    "title": "setDisableVersusStringRender",
    "keywords": "setDisableVersusStringRender Decides if VS string (string on the ground during VS) is visible or not. Code Information Name: setDisableVersusStringRender Scope: Global PAC Instruction (Binary): 25 16 3e 01 Assembly Address in Memory : 0x892b0e4 Parameters (bool)disable_vs_string (8 bytes) : 0 enables VS string, otherwise the string is is disabled. Example Here is one example in hex: 25 16 3e 01 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setDisableVersusStringRender((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892b0e4(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x6c), iVar2 != 0)) { if (*piVar1 == 0) { (**(code **)(*(int *)(iVar2 + 0x10) + 0x28))(); } else { (**(code **)(*(int *)(iVar2 + 0x10) + 0x2c))(); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setdrawmode.html": {
    "href": "setdrawmode.html",
    "title": "setDrawMode",
    "keywords": "setDrawMode Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setDrawMode Scope: Global PAC Instruction (Binary): 25 19 10 00 Assembly Address in Memory : 0x8941efc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 19 10 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 Which is interpreted as: setDrawMode((int *)iVar0, (int)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941efc(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x1d8) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "seteffecttargetmask.html": {
    "href": "seteffecttargetmask.html",
    "title": "setEffectTargetMask",
    "keywords": "setEffectTargetMask Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setEffectTargetMask Scope: Global PAC Instruction (Binary): 25 16 d1 00 Assembly Address in Memory : 0x8925a90 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (int)Var4 (8 bytes) (int)Var5 (8 bytes) (int)Var6 (8 bytes) Example Here is one example in hex: 25 16 d1 00 / 08 00 00 00 / ff 01 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEffectTargetMask(((global)int *)giVar511, (int)1, (int)1, (int)1, (int)1, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925a90(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; int *piVar4; int *piVar5; int *piVar6; int *piVar7; int iVar8; int iVar9; uint uVar10; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); piVar7 = (int *)Pac_Get_Param(param_2,6,1,4); iVar8 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); iVar9 = (**(code **)(*(int *)(iVar8 + 4) + 0x34))(iVar8); if (iVar9 == 0xb) { if (iVar8 != 0) { uVar10 = (uint)(*piVar2 != 0); if (*piVar3 == 0) { iVar9 = *piVar4; } else { uVar10 = uVar10 | 4; iVar9 = *piVar4; } if (iVar9 == 0) { iVar9 = *piVar5; } else { uVar10 = uVar10 | 0x10; iVar9 = *piVar5; } if (iVar9 == 0) { iVar9 = *piVar6; } else { uVar10 = uVar10 | 0x40; iVar9 = *piVar6; } if (iVar9 == 0) { iVar9 = *piVar7; } else { uVar10 = uVar10 | 0x100; iVar9 = *piVar7; } if (iVar9 != 0) { uVar10 = uVar10 | 0x200; } FUN_088d5290(iVar8,uVar10); } PAC::PAC_setCmdId(param_2,0); } else { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "seteffecttimmingscript.html": {
    "href": "seteffecttimmingscript.html",
    "title": "setEffectTimmingScript",
    "keywords": "setEffectTimmingScript When the effect is activated, calls the specific address. Does same thing as effectSetTimmingScript, except the parameter order is a bit different. Used by effect.pac. Code Information Name: setEffectTimmingScript Scope: Global PAC Instruction (Binary): 25 16 09 00 Assembly Address in Memory : 0x8919744 Parameters (int)effectID (8 bytes) : Effect ID from effectparam. (int)Var1 (8 bytes) : Expected 0~4. (MemoryAddress)pac_address (8 bytes) : Memory address that contains start of the PAC, obtained from getPack. (address)Address (8 bytes) : Does not call anything if the value is -1 (ff ff ff ff). Example Here is one example in hex: 25 16 09 00 / 02 00 00 00 / 2a 02 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: setEffectTimmingScript((int)554, (int)0, (int *)iVar0, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919744(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x128); if (iVar5 != 0) { FUN_088ad8a8(iVar5,*puVar1,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenableabnormalwhole.html": {
    "href": "setenableabnormalwhole.html",
    "title": "setEnableAbnormalWhole",
    "keywords": "setEnableAbnormalWhole Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setEnableAbnormalWhole Scope: Global PAC Instruction (Binary): 25 21 24 00 Assembly Address in Memory : 0x89b370c Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 21 24 00 / 04 00 00 00 / 14 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnableAbnormalWhole((int *)iVar20, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b370c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { *(bool *)(iVar3 + 0x89) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablechatwindow.html": {
    "href": "setenablechatwindow.html",
    "title": "setEnableChatWindow",
    "keywords": "setEnableChatWindow Enables or disables chat message selection window. Works only in multi. Code Information Name: setEnableChatWindow Scope: Global PAC Instruction (Binary): 25 16 9c 00 Assembly Address in Memory : 0x891ad6c Parameters (bool)enabled (8 bytes) : 0 disables chat message selection window. Example Here is one example in hex: 25 16 9c 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnableChatWindow((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ad6c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); if (*(int *)(iVar3 + 100) != 0) { FUN_089f9560(*(undefined4 *)(*(int *)(*(int *)(iVar3 + 100) + 0x1cc) + 0x34),*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablelogwindow.html": {
    "href": "setenablelogwindow.html",
    "title": "setEnableLogWindow",
    "keywords": "setEnableLogWindow Enables or disables chat message log window. Works only in multi. Code Information Name: setEnableLogWindow Scope: Global PAC Instruction (Binary): 25 16 9b 00 Assembly Address in Memory : 0x891acec Parameters (bool)enabled (8 bytes) : 0 disables chat log window. Remarks This does nothing with player-level chat log display setting. Even if this is turned on, if displaying chat log is disabled in the player setting, the log won't be displayed. Example Here is one example in hex: 25 16 9b 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnableLogWindow((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891acec(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); if (*(int *)(iVar3 + 100) != 0) { FUN_089fda88(*(undefined4 *)(*(int *)(*(int *)(iVar3 + 100) + 0x1cc) + 0x24),*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablenetwork.html": {
    "href": "setenablenetwork.html",
    "title": "setEnableNetwork",
    "keywords": "setEnableNetwork Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setEnableNetwork Scope: Global PAC Instruction (Binary): 25 19 19 00 Assembly Address in Memory : 0x894276c Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 19 19 00 / 08 00 00 00 / 40 01 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnableNetwork(((global)int *)giVar320, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894276c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if ((iVar3 != 0) && (*(int *)(iVar3 + 0x194) != 0)) { *(byte *)(iVar3 + 0x1d5) = *(byte *)(iVar3 + 0x1d5) & 0xfe | *piVar2 == 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablepad.html": {
    "href": "setenablepad.html",
    "title": "setEnablePad",
    "keywords": "setEnablePad Enables/Disables input interaction in hideout. The input is disabled e.g. in scene change, hideout open/close animation, data saving dialog. Code Information Name: setEnablePad Scope: Azito PAC Instruction (Binary): 25 1c 05 00 Assembly Address in Memory : 0x8b4d478 Parameters (bool)enable_input (8 bytes) : 1 enables input, 0 disables input. Example Here is one example in hex: 25 1c 05 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnablePad((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d478(int param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *piVar1; iVar2 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x14); if (iVar2 != 0) { *(bool *)(iVar2 + 0x60) = iVar3 != 0; *(bool *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x21) = iVar3 != 0; if (iVar3 == 0) { FUN_08852af4(iVar2 + 100); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablequickmotionmode.html": {
    "href": "setenablequickmotionmode.html",
    "title": "setEnableQuickMotionMode",
    "keywords": "setEnableQuickMotionMode Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setEnableQuickMotionMode Scope: Global PAC Instruction (Binary): 25 21 28 00 Assembly Address in Memory : 0x89b3b04 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3b04(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { FUN_0897e3f8(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablereload.html": {
    "href": "setenablereload.html",
    "title": "setEnableReload",
    "keywords": "setEnableReload Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setEnableReload Scope: Azito PAC Instruction (Binary): 25 1c 34 00 Assembly Address in Memory : 0x8b4d500 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 1c 34 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnableReload((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d500(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); FUN_Azito__08b49ab8(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x1e4),*piVar1 != 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenablerhythmhit.html": {
    "href": "setenablerhythmhit.html",
    "title": "setEnableRhythmHit",
    "keywords": "setEnableRhythmHit Check if command cancel is enabled or disabled. Code Information Name: setEnableRhythmHit Scope: Global PAC Instruction (Binary): 25 0c 25 00 Assembly Address in Memory : 0x89715a0 Parameters (bool)disable_commandcancel (8 bytes) : 0 sets command cancel. otherwise command cancel is disabled. Example Here is one example in hex: 25 0c 25 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setEnableRhythmHit((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089715a0(undefined4 param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); DAT_08b98eb0 = *piVar1 != 0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenableseatlight.html": {
    "href": "setenableseatlight.html",
    "title": "setEnableSeatLight",
    "keywords": "setEnableSeatLight Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setEnableSeatLight Scope: Azito PAC Instruction (Binary): 25 1c 11 00 Assembly Address in Memory : 0x8b4e1a0 Parameters (uint)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4e1a0(int param_1,undefined4 param_2) { uint *puVar1; int *piVar2; uint uVar3; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); uVar3 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (uVar3 < 4)) { *(bool *)(uVar3 + *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0xcdc4) + 0x29c0) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setenemysummontype.html": {
    "href": "setenemysummontype.html",
    "title": "setEnemySummonType",
    "keywords": "setEnemySummonType Registers summon type for enemy side. Code Information Name: setEnemySummonType Scope: Global PAC Instruction (Binary): 25 0c 27 00 Assembly Address in Memory : 0x897163c Parameters (int)summon_id (8 bytes) : The ID of the summon to give to the enemy. Example Here is one example in hex: 25 0c 27 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setEnemySummonType((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0897163c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; uint *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar5 = *piVar1; if ((iVar5 < 0) || (8 < iVar5)) { _DAT_08b826e4 = 0xffffffff; } else { uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); puVar4 = (uint *)(*(int *)(iVar3 + 0x44) + 0x7df4); if (puVar4 != (uint *)0x0) { iVar5 = Equipment::Set_Eqid_10000x(iVar5 + 0xc,9999); *puVar4 = *puVar4 & 1 | iVar5 << 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfacilityactive.html": {
    "href": "setfacilityactive.html",
    "title": "setFacilityActive",
    "keywords": "setFacilityActive Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFacilityActive Scope: Azito PAC Instruction (Binary): 25 1c 0a 00 Assembly Address in Memory : 0x8b4daf0 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4daf0(int param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); iVar2 = *piVar1; if ((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(iVar3 * 0x10 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x1e0), iVar3 != 0)) { (**(code **)(*(int *)(iVar3 + 4) + 0x58))(iVar3,iVar2 != 0); (**(code **)(*(int *)(*(int *)(iVar3 + 0x148) + 4) + 0x58))(*(int *)(iVar3 + 0x148),iVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfacilityenableselect.html": {
    "href": "setfacilityenableselect.html",
    "title": "setFacilityEnableSelect",
    "keywords": "setFacilityEnableSelect Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFacilityEnableSelect Scope: Azito PAC Instruction (Binary): 25 1c 0b 00 Assembly Address in Memory : 0x8b4dbb0 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4dbb0(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(iVar2 * 0x10 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x1e0), iVar2 != 0)) { *(bool *)(iVar2 + 0x141) = *piVar1 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfacilityinfo.html": {
    "href": "setfacilityinfo.html",
    "title": "setFacilityInfo",
    "keywords": "setFacilityInfo Sets certain information of a selectable hideout gimmick(facility). Code Information Name: setFacilityInfo Scope: Azito PAC Instruction (Binary): 25 1c 0d 00 Assembly Address in Memory : 0x8b4dd78 Parameters (int)facility_type (8 bytes) : Facility ID. (int)info_type (8 bytes) : Range of 2~4 (note that 0 and 1 are not allowed). (bool)value (8 bytes) : Value to set as given info type. info_type meaning 2 1 enables selection, let this 1 and editing 4 is preferred 3 1 enables interaction (action on X) 4 1 can be selected Example Here is one example in hex: 25 1c 0d 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 04 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setFacilityInfo((int)0, (int)4, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4dd78(int param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); iVar2 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,2,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(iVar3 * 0x10 + *(int *)(*(int *)(param_1 + 0x10) + 0x1c4) + 0x1e0), iVar3 != 0)) { iVar4 = *(int *)(iVar3 + 0x148); if (iVar2 == 4) { *(bool *)(iVar3 + 0x142) = *piVar1 != 0; } else if (iVar2 == 3) { *(bool *)(iVar3 + 0x141) = *piVar1 != 0; } else if ((iVar2 == 2) && ((**(code **)(*(int *)(iVar3 + 4) + 0x58))(iVar3,*piVar1 != 0), iVar4 != 0)) { (**(code **)(*(int *)(iVar4 + 4) + 0x58))(iVar4,*piVar1 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfevergaugepriority.html": {
    "href": "setfevergaugepriority.html",
    "title": "setFeverGaugePriority",
    "keywords": "setFeverGaugePriority Sets how top the fever gauge should be (render priority). Code Information Name: setFeverGaugePriority Scope: Global PAC Instruction (Binary): 25 0c 2a 00 Assembly Address in Memory : 0x89717fc Parameters (int)priority (8 bytes) : Fever gauge priority (how top it is). Example Here is one example in hex: 25 0c 2a 00 / 02 00 00 00 / 10 27 00 00 Which is interpreted as: setFeverGaugePriority((int)10000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089717fc(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if ((iVar2 != 0) && (iVar2 = *(int *)(iVar2 + 0x3f28), iVar2 != 0)) { (**(code **)(*(int *)(iVar2 + 0x1c) + 0x14))(iVar2,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfixmoveenable.html": {
    "href": "setfixmoveenable.html",
    "title": "setFixMoveEnable",
    "keywords": "setFixMoveEnable Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFixMoveEnable Scope: Global PAC Instruction (Binary): 25 17 10 00 Assembly Address in Memory : 0x8911c60 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 17 10 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setFixMoveEnable((int *)iVar0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911c60(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(bool *)(iVar3 + 0xb5) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setflagunitbaseposition.html": {
    "href": "setflagunitbaseposition.html",
    "title": "setFlagUnitBasePosition",
    "keywords": "setFlagUnitBasePosition Forces base position of the Hatapon. Code Information Name: setFlagUnitBasePosition Scope: Global PAC Instruction (Binary): 25 16 43 00 Assembly Address in Memory : 0x891ded8 Parameters (float)pos_x (8 bytes) : X position to move Hatapon. (float)pos_y (8 bytes) : Y position to move Hatapon. Example Here is one example in hex: 25 16 43 00 / 10 00 00 00 / 00 00 96 c3 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setFlagUnitBasePosition((float)-300, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ded8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; undefined *puVar5; int iVar6; undefined4 uVar7; undefined4 uVar8; undefined4 uVar9; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if (((iVar3 != 0) && (iVar3 = FUN_088a8650(iVar3,0), iVar3 != 0)) && (iVar4 = Get_HataponAddr(iVar3), iVar4 != 0)) { iVar6 = *(int *)(iVar4 + 200); if (iVar6 == 0) { iVar4 = *(int *)(iVar4 + 0xa14); } else { uVar9 = *puVar2; uVar8 = *(undefined4 *)(iVar6 + 200); uVar7 = *puVar1; *(undefined4 *)(iVar6 + 0xc0) = uVar7; *(undefined4 *)(iVar6 + 0xc4) = uVar9; *(undefined4 *)(iVar6 + 200) = uVar8; *(undefined4 *)(iVar6 + 0xcc) = *(undefined4 *)(iVar6 + 0xcc); FUN_0887f1e4(*(undefined4 *)(iVar6 + 0x1e0)); puVar5 = *(undefined **)(iVar6 + 0x1ec); if (puVar5 != (undefined *)0x0) { local_c = uVar7; local_8 = uVar9; local_4 = uVar8; FUN_08983b94(puVar5,&local_c); *puVar5 = 0; } iVar4 = *(int *)(iVar4 + 0xa14); } iVar3 = iVar3 + 0x170 + *(int *)(iVar4 + 0x184) * 0x10; *(undefined4 *)(iVar3 + 0x20) = *puVar1; *(undefined4 *)(iVar3 + 0x24) = *(undefined4 *)(iVar3 + 0x24); *(undefined4 *)(iVar3 + 0x28) = *(undefined4 *)(iVar3 + 0x28); *(undefined4 *)(iVar3 + 0x2c) = *(undefined4 *)(iVar3 + 0x2c); FUN_08955e28(iVar4 + 0x260,iVar3 + 0x20); FUN_08955c90(iVar4 + 0x260,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfloating.html": {
    "href": "setfloating.html",
    "title": "setFloating",
    "keywords": "setFloating Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFloating Scope: Global PAC Instruction (Binary): 25 17 16 00 Assembly Address in Memory : 0x8912304 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912304(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (param_1 == 0) { iVar4 = 0; } else { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 == 0) { iVar4 = 0; } else { iVar4 = *(int *)(iVar4 + 200); if (iVar4 == 0) { iVar4 = 0; } } } if (iVar4 != 0) { FUN_08892530(*puVar2,*puVar3,iVar4 + 0x158); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfogalphaparam.html": {
    "href": "setfogalphaparam.html",
    "title": "setFogAlphaParam",
    "keywords": "setFogAlphaParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFogAlphaParam Scope: Global PAC Instruction (Binary): 25 16 79 00 Assembly Address in Memory : 0x8920e90 Parameters (undefined4)Var0 (8 bytes) (float)Var1 (8 bytes) Example Here is one example in hex: 25 16 79 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setFogAlphaParam((int)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920e90(int param_1,undefined4 param_2) { undefined4 *puVar1; float *pfVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pfVar2 = (float *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0x118); if (iVar3 == 0) { iVar3 = 0; } } switch(*puVar1) { case 0: (&DAT_00007e3c)[iVar3] = (int)*pfVar2 != 0; break; case 1: *(float *)(&DAT_00007e30 + iVar3) = *pfVar2; break; case 2: *(float *)(&DAT_00007e34 + iVar3) = *pfVar2; break; case 3: *(float *)(&DAT_00007e38 + iVar3) = *pfVar2; break; case 4: DAT_08a6eae0 = *pfVar2; break; case 5: DAT_08a6eae4 = *pfVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfogleve.html": {
    "href": "setfogleve.html",
    "title": "setFogLeve",
    "keywords": "setFogLeve Sets how foggy the weather is in the world. Does not work with rain. Code Information Name: setFogLeve Scope: Global PAC Instruction (Binary): 25 16 76 00 Assembly Address in Memory : 0x8920c9c Parameters (float)fog_level (8 bytes) : Fog level to set. 0 is no fog, 1 is maximum fog. Example Here is one example in hex: 25 16 76 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setFogLeve((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920c9c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_088fdd64(*puVar1,iVar2 + 0x250); FUN_088fdd64(*puVar1,iVar2 + 0x210); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfogview.html": {
    "href": "setfogview.html",
    "title": "setFogView",
    "keywords": "setFogView Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFogView Scope: Global PAC Instruction (Binary): 25 17 35 00 Assembly Address in Memory : 0x89144c4 Parameters (int)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089144c4(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { *(bool *)(*(int *)(iVar3 + 200) + 0x14c) = *piVar2 != 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setfrontlinedetectforce.html": {
    "href": "setfrontlinedetectforce.html",
    "title": "setFrontLineDetectForce",
    "keywords": "setFrontLineDetectForce Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setFrontLineDetectForce Scope: Global PAC Instruction (Binary): 25 16 de 00 Assembly Address in Memory : 0x8923824 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 16 de 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setFrontLineDetectForce((int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923824(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 != 0) { if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } iVar3 = FUN_088a8650(iVar3,*puVar1); *(bool *)(iVar3 + 0x28e) = *piVar2 != 0; *(bool *)(iVar3 + 0x28f) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgamemode.html": {
    "href": "setgamemode.html",
    "title": "setGameMode",
    "keywords": "setGameMode Defines mission type. Code Information Name: setGameMode Scope: Global PAC Instruction (Binary): 25 0a 1d 00 Assembly Address in Memory : 0x894b204 Parameters (int)mission_type (8 bytes) : Mission type to set, details on getGameMode. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b204(undefined4 param_1,undefined4 param_2) { int iVar1; undefined4 *puVar2; iVar1 = Get_Some_Flag(1); iVar1 = *(int *)(iVar1 + 0x44); puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); *(undefined4 *)(iVar1 + 0x530) = *puVar2; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgateinfo.html": {
    "href": "setgateinfo.html",
    "title": "setGateInfo",
    "keywords": "setGateInfo Binds an gate opening action object to another object. This can be dungeon or field structure. This can control e.g. door open and limiting camera turn. Code Information Name: setGateInfo Scope: Global PAC Instruction (Binary): 25 16 bd 00 Assembly Address in Memory : 0x8923bc8 Parameters (bool)bind_type (8 bytes) : 0 has many types of binds, 1 will be connected to only param_index 2 (int)bind_identifier (8 bytes) : bind_identifier from setupAddDungeonWall, if it's non-dungeon, set it manually. (int)param_index (8 bytes) : Index of the parameter, see below for the detail. (int/index)param (8 bytes) : The value depends on the param_index, see below. If bind_type is 0, setup only 2 of param_index (in this case, the param is address). About param_index If param_index is 0, param is identifier of the object, obtained from setupAddDungeonWall For non-dungeon object, it's gimmick_identifier from registConstGimmick. If param_index is 1, param decides action type. 0 does nothing, 1 blocks camera sight door moving direction with lever: 4 is from up to down, 8 is from down to up. 0 does not move. If param_index is 2, param is address (offset from PAC file) to call (when being opened or destroyed). The address can be address of cmd_end. If param_index is 3, param can be 0, 1, 2. 1 opens door from very start. if param_index is 4, param is \"reqActor ID\" 3rd parameter of the lever gimmick. The reqActor can be created later. if param_index is 5, param is another \"reqActor ID\" 3rd parameter of the lever gimmick. The reqActor can be created later. If there is no 2nd lever, keep -1. Multi dungeon has this because the door is activated with two levers. if param_index is 6, param decides whether the door closed after activating the lever. 0 does not close after once opened, 1 closes after few turns. Please describe other param data following with param_index. Example Here is one example in hex: 25 16 bd 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 46 00 00 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 48 00 00 00 Which is interpreted as: setGateInfo((int)0, ((global)int *)giVar70, (int)0, ((global)int *)giVar72) This is how the setGateInfo is used in a field. 00004AEC 25000700:cmd_mov(8:46, 0.0) 00004B00 25000700:cmd_mov(8:48, -1.0) 00004B14 2516BD00:setGateInfo(2:0, 8:46, 2:0, 8:48) 00004B38 2516BD00:setGateInfo(2:0, 8:46, 2:1, 2:0) 00004B5C 2516BD00:setGateInfo(2:0, 8:46, 2:2, 1:368) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08923bc8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; undefined4 *puVar4; int iVar5; undefined4 uVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar6 = *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118); if (*piVar1 == 0) { iVar5 = FUN_088b25fc(uVar6,*puVar2); if (iVar5 == 0) { iVar5 = FUN_088b24c4(uVar6,*puVar2); } } else { iVar5 = FUN_088b2648(uVar6,*puVar2); } if (iVar5 != 0) { *(undefined4 *)(iVar5 + *piVar3 * 4) = *puVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgimmickflag.html": {
    "href": "setgimmickflag.html",
    "title": "setGimmickFlag",
    "keywords": "setGimmickFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setGimmickFlag Scope: Mission PAC Instruction (Binary): 25 1f 25 00 Assembly Address in Memory : 0x8b5d6e8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) (int)Var4 (8 bytes) Example Here is one example in hex: 25 1f 25 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setGimmickFlag(((global)int *)giVar26, (int)0, (int)1, (int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d6e8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; int *piVar4; int *piVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); iVar6 = *(int *)(param_1 + 0x10); if (iVar6 == 0) { iVar6 = 0; } else if (*piVar1 == -1) { iVar6 = 0; } else { if (iVar6 == 0) { iVar6 = 0; } iVar6 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar6 + 0x2c8)); if (iVar6 == 0) { iVar6 = 0; } } if (iVar6 != 0) { FUN_Mission__08b570e0(iVar6,*puVar2,*piVar3 != 0,*piVar4 != 0,*piVar5 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgimmicktimmingscript.html": {
    "href": "setgimmicktimmingscript.html",
    "title": "setGimmickTimmingScript",
    "keywords": "setGimmickTimmingScript When the gimmick is created, calls the specific address. Code Information Name: setGimmickTimmingScript Scope: Global PAC Instruction (Binary): 25 16 0a 00 Assembly Address in Memory : 0x8919814 Parameters (int)gimmickID (8 bytes) : Gimmick ID from gimmickparam. (int)Var1 (8 bytes) : Expected 0~4. (MemoryAddress)pac_address (8 bytes) : Memory address that contains start of the PAC, obtained from getPack. (address)Address (8 bytes) : Does not call anything if the value is -1 (ff ff ff ff). Example Here is one example in hex: 25 16 0a 00 / 02 00 00 00 / 42 02 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / b0 05 00 00 Which is interpreted as: setGimmickTimmingScript((int)578, (int)0, (int *)iVar0, (index)1456) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08919814(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x108); if (iVar5 != 0) { FUN_088b4644(iVar5,*puVar1,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgroundoffset.html": {
    "href": "setgroundoffset.html",
    "title": "setGroundOffset",
    "keywords": "setGroundOffset Moves the Y position of the ground. Used in Missile battle for displaying bridge under the units. Code Information Name: setGroundOffset Scope: Global PAC Instruction (Binary): 25 16 ae 00 Assembly Address in Memory : 0x89233f4 Parameters (float)ground_offset (8 bytes): offset of the ground from the bottom. Higher value moves ground to up. Default is 0. Example Here is one example in hex: 25 16 ae 00 / 10 00 00 00 / 00 00 00 c2 Which is interpreted as: setGroundOffset((float)-32) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089233f4(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_0890fa74(*puVar1,*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xd8)); *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x40) = *puVar1; *(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x128) + 0x24) = *puVar1; iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x138); if (iVar2 != 0) { *(undefined4 *)(iVar2 + 0x24) = *puVar1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgroupid_25100900.html": {
    "href": "setgroupid_25100900.html",
    "title": "setGroupId (25100900)",
    "keywords": "setGroupId (25100900) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setGroupId Scope: Global PAC Instruction (Binary): 25 10 09 00 Assembly Address in Memory : 0x890a280 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a280(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { *(undefined4 *)(*(int *)(param_1 + 0x10) + 0x4fc) = *puVar1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setgroupid_25170d00.html": {
    "href": "setgroupid_25170d00.html",
    "title": "setGroupId (25170d00)",
    "keywords": "setGroupId (25170d00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setGroupId Scope: Global PAC Instruction (Binary): 25 17 0d 00 Assembly Address in Memory : 0x89119b0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 0d 00 / 08 00 00 00 / 5b 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: setGroupId(((global)int *)giVar91, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089119b0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { *(short *)(iVar3 + 0x84) = (short)*puVar2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setheroappearposition.html": {
    "href": "setheroappearposition.html",
    "title": "setHeroAppearPosition",
    "keywords": "setHeroAppearPosition Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setHeroAppearPosition Scope: Global PAC Instruction (Binary): 25 16 09 01 Assembly Address in Memory : 0x89287ec Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 09 01 / 04 00 00 00 / 0d 00 00 00 / 20 00 00 00 / 0c 00 00 00 Which is interpreted as: setHeroAppearPosition((int *)iVar13, (float *)fVar12) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089287ec(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; int iVar5; int iVar6; undefined4 uVar7; undefined4 uVar8; undefined4 uVar9; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { iVar4 = *(int *)(iVar3 + 0x704); if ((iVar4 != 0) && (iVar4 + 0x170 != 0)) { iVar5 = *(int *)(iVar3 + 0x184) * 0x10 + iVar4 + 0x170; *(undefined4 *)(iVar5 + 0x20) = *puVar2; *(undefined4 *)(iVar5 + 0x24) = 0; *(undefined4 *)(iVar5 + 0x28) = 0; *(undefined4 *)(iVar5 + 0x2c) = 0; if (iVar3 != -0x1f0) { uVar8 = *(undefined4 *)(iVar5 + 0x24); uVar9 = *(undefined4 *)(iVar5 + 0x28); uVar7 = *(undefined4 *)(iVar5 + 0x2c); *(undefined4 *)(iVar3 + 0x2f0) = *(undefined4 *)(iVar5 + 0x20); *(undefined4 *)(iVar3 + 0x2f4) = uVar8; *(undefined4 *)(iVar3 + 0x2f8) = uVar9; *(undefined4 *)(iVar3 + 0x2fc) = uVar7; syscall::vadd_q(&local_10,iVar3 + 0x2f0,iVar3 + 0x300); *(undefined4 *)(iVar3 + 0x2e0) = local_10; *(undefined4 *)(iVar3 + 0x2e4) = local_c; *(undefined4 *)(iVar3 + 0x2e8) = local_8; *(undefined4 *)(iVar3 + 0x2ec) = local_4; FUN_0890c838((undefined4 *)(iVar3 + 0x2e0),0); iVar5 = Is_HeroUnit(iVar3); if ((iVar5 != 0) && (iVar5 != -0x170)) { iVar6 = iVar5 + 0x810; FUN_08955da8(iVar6,iVar4 + 0x2b0); FUN_08955e28(iVar6,iVar3 + 0x2e0); FUN_08955db8(iVar6,iVar3 + 0x2e0); iVar3 = *(int *)(iVar5 + 200); if (iVar3 != 0) { puVar1 = (undefined4 *)offset__10(iVar6); *(undefined4 *)(iVar3 + 0xc0) = *puVar1; *(undefined4 *)(iVar3 + 0xc4) = puVar1[1]; *(undefined4 *)(iVar3 + 200) = puVar1[2]; *(undefined4 *)(iVar3 + 0xcc) = puVar1[3]; puVar1 = (undefined4 *)offset__10(iVar6); *(undefined4 *)(iVar3 + 0x30) = *puVar1; *(undefined4 *)(iVar3 + 0x34) = puVar1[1]; *(undefined4 *)(iVar3 + 0x38) = puVar1[2]; *(undefined4 *)(iVar3 + 0x3c) = puVar1[3]; } } } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sethiteffectscript.html": {
    "href": "sethiteffectscript.html",
    "title": "setHitEffectScript",
    "keywords": "setHitEffectScript Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setHitEffectScript Scope: Global PAC Instruction (Binary): 25 16 0c 00 Assembly Address in Memory : 0x89199b4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (8 bytes) Example Here is one example in hex: 25 16 0c 00 / 02 00 00 00 / 07 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 24 25 00 00 Which is interpreted as: setHitEffectScript((int)7, (int *)iVar0, (index)9508) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089199b4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(*(int *)(param_1 + 0x10) + 0x128); if (iVar4 != 0) { FUN_0894e618(iVar4 + 0x1220,*puVar1,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sethitpoint.html": {
    "href": "sethitpoint.html",
    "title": "setHitPoint",
    "keywords": "setHitPoint Sets current stamina of an object. Code Information Name: setHitPoint Scope: Global PAC Instruction (Binary): 25 17 2a 00 Assembly Address in Memory : 0x89136c0 Parameters (int *)handle (8 bytes) : Handle of the object to set the current stamina. (int)stamina (8 bytes) : Amount of stamina to set. Example Here is one example in hex: 25 17 2a 00 / 08 00 00 00 / 5b 00 00 00 / 04 00 00 00 / 03 00 00 00 Which is interpreted as: setHitPoint(((global)int *)giVar91, (int *)iVar3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089136c0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 0xcc); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { FUN_088984bc(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setiamcheater.html": {
    "href": "setiamcheater.html",
    "title": "setIamCheater",
    "keywords": "setIamCheater Makes character name red in multi, if the character is diagnosed as cheater. Warning There are many false positives! DO NOT suspect people based on this. Practically, those are few reasons why this is called: Equpiment level is higher than class level (Best observed in DoI) Random Disconnection Even baby save can call this randomly. Code Information Name: setIamCheater Scope: Azito PAC Instruction (Binary): 25 1c 36 00 Assembly Address in Memory : 0x8b508b0 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 36 00 Which is interpreted as: setIamCheater() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b508b0(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { Set_Redname_Flag(*(int *)(param_1 + 0x10),1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setimitationsoundposition.html": {
    "href": "setimitationsoundposition.html",
    "title": "setImitationSoundPosition",
    "keywords": "setImitationSoundPosition Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setImitationSoundPosition Scope: Global PAC Instruction (Binary): 25 0c 22 00 Assembly Address in Memory : 0x89713e0 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 0c 22 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setImitationSoundPosition((int)1, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089713e0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; undefined4 uVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); iVar5 = *(int *)(iVar3 + 0x158); if ((iVar5 != 0) && (iVar3 != 0)) { uVar4 = 0; if (-1 < *piVar2) { uVar4 = Find_Target_By_HandleID(*(undefined4 *)(iVar3 + 0xe8),*piVar2,1); } func_0x08b5f7b0(iVar5,*puVar1,uVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setisnothitdungeon.html": {
    "href": "setisnothitdungeon.html",
    "title": "setIsNotHitDungeon",
    "keywords": "setIsNotHitDungeon Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setIsNotHitDungeon Scope: Global PAC Instruction (Binary): 25 19 1c 00 Assembly Address in Memory : 0x8942ac0 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 19 1c 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setIsNotHitDungeon((int *)iVar0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942ac0(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *(byte *)(iVar3 + 0x324) = *(byte *)(iVar3 + 0x324) & 0x7f | (*piVar2 != 0) << 7; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setitemtable_25174900.html": {
    "href": "setitemtable_25174900.html",
    "title": "setItemTable (25174900)",
    "keywords": "setItemTable (25174900) Other functions have the same name. Check the Disambiguation page to find them. Sets item drop from the specific generator. Code Information Name: setItemTable Scope: Global PAC Instruction (Binary): 25 17 49 00 Assembly Address in Memory : 0x8915e5c Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)item_table_id (8 bytes) : ID of the Item table, defined from beginAppearItem Example Here is one example in hex: 25 17 49 00 / 08 00 00 00 / 84 00 00 00 / 02 00 00 00 / 84 03 00 00 Which is interpreted as: setItemTable(((global)int *)giVar132, (int)900) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915e5c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((*piVar1 != -1) && (iVar3 = FUN_08910c4c(param_1), iVar3 != 0)) { FUN_0896e3d0(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setitemtable_251f0700.html": {
    "href": "setitemtable_251f0700.html",
    "title": "setItemTable (251f0700)",
    "keywords": "setItemTable (251f0700) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setItemTable Scope: Mission PAC Instruction (Binary): 25 1f 07 00 Assembly Address in Memory : 0x8b5c3a8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c3a8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else if (*piVar1 == -1) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar3 + 0x2c8)); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x28) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setknownitem.html": {
    "href": "setknownitem.html",
    "title": "setKnownItem",
    "keywords": "setKnownItem Mark an item as obtained item ever before. This does nothing with ultimate anticheat flag, does not give the item either. Code Information Name: setKnownItem Scope: Global PAC Instruction (Binary): 25 0a 46 00 Assembly Address in Memory : 0x894a07c Parameters (int)item_id (8 bytes) : ID of the item to mark as known item. (int)as_obtained (8 bytes) : 1 marks the item as obtained, 0 marks as unobtained. Example Here is one example in hex: 25 0a 46 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setKnownItem((int *)iVar0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a07c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_089457a0(*(undefined4 *)(*(int *)(*(int *)(param_1 + 0x10) + 0x374) + 0x34),*puVar1, *piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlaboinfo.html": {
    "href": "setlaboinfo.html",
    "title": "setLaboInfo",
    "keywords": "setLaboInfo Sets certain types of information. See also: getLaboInfo. Code Information Name: setLaboInfo Scope: Global PAC Instruction (Binary): 25 0a 06 00 Assembly Address in Memory : 0x89499b0 Parameters (int)labo_type (8 bytes) : The \"labo type\" to set the value. (int)value (8 bytes) : The value to set to given labo type, expected boolean. Works only with labo_type 7~9. Id Value 0 Value 1 0x7 Not connected or connecting Fully connected in multi 0x8 unused unused 0x9 Uberhero Dark hero Example Here is one example in hex: 25 0a 06 00 / 02 00 00 00 / 07 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setLaboInfo((int)7, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089499b0(int param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar4 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { Save::Get_Save_BaseAddr(1); uVar2 = Save::Get_Save_BaseAddr(1); iVar3 = Save::Get_BaseAddr__0x78(uVar2,1); if (iVar4 == 9) { iVar4 = Save::Get_Save_BaseAddr(1); iVar4 = return__0x285a8(*(undefined4 *)(iVar4 + 0x50)); *(int *)(iVar4 + 0x11b4) = *piVar1; } else if (iVar4 == 8) { *(bool *)(*(int *)(iVar3 + 0x44) + 0x3e) = *piVar1 != 0; } else if (iVar4 == 7) { FUN_0898d54c(*(int *)(iVar3 + 0x44),*piVar1 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlevel.html": {
    "href": "setlevel.html",
    "title": "setLevel",
    "keywords": "setLevel Sets every object's level in a specific generator. See also: About Levels. Code Information Name: setLevel Scope: Mission PAC Instruction (Binary): 25 1f 04 00 Assembly Address in Memory : 0x8b5c138 Parameters (int *)generator_handle (8 bytes) : Handle of the generator to set level, obtained from create or getHandle. (int)level (8 bytes) : Individual level to assign to the unit(s). More information in here. Remarks If the level is not set, it will use the level from setQuestLevel. Example Here is one example in hex: 25 1f 04 00 / 08 00 00 00 / 1a 00 00 00 / 08 00 00 00 / 32 00 00 00 Which is interpreted as: setLevel(((global)int *)giVar26, ((global)int *)giVar50) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c138(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else if (*piVar1 == -1) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar3 + 0x2c8)); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { // loads and saves lvl *(undefined4 *)(iVar3 + 0x10) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlink.html": {
    "href": "setlink.html",
    "title": "setLink",
    "keywords": "setLink Connects a model to a node. Code Information Name: setLink Scope: Global PAC Instruction (Binary): 25 17 1a 00 Assembly Address in Memory : 0x8912664 Parameters (int *)parent_handle (8 bytes) : The parent handle to contain the child handle. (int *)child_handle (8 bytes) : Handle of the model, e.g. effect, from addEffect. (String)node_name : The node name from the GXX file. Example Here is one example in hex: 25 17 1a 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 / 68 65 6c 6d / 00 00 00 00 Which is interpreted as: setLink((int *)iVar1, (int *)iVar0, \"helm\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912664(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined *puVar4; int iVar5; int iVar6; undefined *puVar7; undefined local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = &DAT_00000100; puVar7 = local_100; puVar1 = puVar7; while (puVar1 != (undefined *)0x0) { *puVar7 = 0; puVar7 = puVar7 + 1; puVar4 = puVar4 + -1; puVar1 = puVar4; } Pac_Get_StringParam(param_2,local_100); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar2,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 != 0) { iVar6 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar3,1); if (iVar6 == 0) { iVar6 = 0; } if (iVar6 != 0) { FUN_0887dd5c(iVar6,iVar5,local_100,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlinkbyid.html": {
    "href": "setlinkbyid.html",
    "title": "setLinkById",
    "keywords": "setLinkById Connects a model to a node by ID. Code Information Name: setLinkById Scope: Global PAC Instruction (Binary): 25 17 65 00 Assembly Address in Memory : 0x8912760 Parameters (int *)parent_handle (8 bytes) : The parent handle to contain the child handle. (int *)child_handle (8 bytes) : Handle of the model, e.g. effect, from addEffect. (int)node_id : The node ID from the GXX file. Example Here is one example in hex: 25 17 65 00 / 04 00 00 00 / 15 00 00 00 / 08 00 00 00 / 7b 01 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setLinkById((int *)iVar21, ((global)int *)giVar379, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912760(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar2,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 != 0) { Gimmick::Gimmick_Set_Position(iVar5,iVar4,*puVar3,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlinkinfo.html": {
    "href": "setlinkinfo.html",
    "title": "setLinkInfo",
    "keywords": "setLinkInfo Sets a link information to the attached element. Used in e.g. Ravenous riding back of the dragon. Code Information Name: setLinkInfo Scope: Global PAC Instruction (Binary): 25 17 4a 00 Assembly Address in Memory : 0x8915f00 Parameters (int *)handle_id (8 bytes) : The target handle of the attached object. (int)set_flag (8 bytes) : 0 disables the flag, 1 enables the flag. (uint)flag (8 bytes) : Specific flag to enable/disable, expected 1~31. ID if 0 if 1 0x1 ??? ??? (can be position related?) 0x2 ??? ??? 0x3 No link animation to parent Link animation to parent 0x5 No flip to parent direction Flip to parent direction 0x7 Render related render related Practically, only 0, 1, 2, 5 are observed. For reference, Ravenous riding the dragon before applying this was 0xC7. Example Here is one example in hex: 25 17 4a 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setLinkInfo((int *)iVar0, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915f00(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; uint *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } /* flag 1 related to 887f130, flag 5 related to flip */ if (iVar4 != 0) { if (*piVar2 == 0) { *(uint *)(iVar4 + 0x120) = *(uint *)(iVar4 + 0x120) & ~(1 << (*puVar3 & 0x1f)); } else { *(uint *)(iVar4 + 0x120) = *(uint *)(iVar4 + 0x120) | 1 << (*puVar3 & 0x1f); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlinkparam.html": {
    "href": "setlinkparam.html",
    "title": "setLinkParam",
    "keywords": "setLinkParam Sets detail of the effect link information. Called after setLink. Code Information Name: setLinkParam Scope: Global PAC Instruction (Binary): 25 17 1b 00 Assembly Address in Memory : 0x8912854 Parameters (int *)handle_id (8 bytes) : The target handle of the attached object. (bool)Var1 (8 bytes) : Please describe what this does. (bool)Var2 (8 bytes) : Please describe what this does. (bool)backward_offset (8 bytes) : 1 from backward pivot, 0 from forward pivot. (float)offset_x (8 bytes) : X offset of the effect. (float)offset_y (8 bytes) : Y offset of the effect. (float)offset_z (8 bytes) : Z offset of the effect. Example Here is one example in hex: 25 17 1b 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 48 42 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setLinkParam((int *)iVar0, (int)1, (int)0, (int)0, (float)0, (float)50, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912854(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; int *piVar4; undefined4 *puVar5; undefined4 *puVar6; undefined4 *puVar7; int iVar8; undefined4 uVar9; undefined4 uVar10; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); puVar7 = (undefined4 *)Pac_Get_Param(param_2,6,1,4); iVar8 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar8 == 0) { iVar8 = 0; } if ((iVar8 != 0) && (iVar8 = *(int *)(iVar8 + 200), iVar8 != 0)) { *(bool *)(iVar8 + 0x1dc) = *piVar2 != 0; if (*piVar3 == 0) { *(undefined4 *)(iVar8 + 0x1d8) = 2; } else { *(undefined4 *)(iVar8 + 0x1d8) = 0; } if (*piVar4 == 0) { uVar10 = *puVar7; uVar9 = *puVar6; *(undefined4 *)(iVar8 + 0x1c0) = *puVar5; *(undefined4 *)(iVar8 + 0x1c4) = uVar9; *(undefined4 *)(iVar8 + 0x1c8) = uVar10; } else { *(undefined *)(iVar8 + 0x1de) = 1; uVar10 = *puVar7; uVar9 = *puVar6; *(undefined4 *)(iVar8 + 0x1cc) = *puVar5; *(undefined4 *)(iVar8 + 0x1d0) = uVar9; *(undefined4 *)(iVar8 + 0x1d4) = uVar10; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setlocalvalue.html": {
    "href": "setlocalvalue.html",
    "title": "setLocalValue",
    "keywords": "setLocalValue Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setLocalValue Scope: Global PAC Instruction (Binary): 25 10 0f 00 Assembly Address in Memory : 0x890a50c Parameters (int*)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Int/Float)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0890a50c(undefined4 param_1,undefined4 param_2) { undefined uVar1; int **ppiVar2; float *pfVar3; uint uVar4; uint uVar5; undefined4 uVar6; float fVar7; int *piVar8; ppiVar2 = (int **)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); uVar4 = Pac_Get_ParamType(param_2,1); uVar5 = Pac_Get_ParamType(param_2,2); uVar1 = FUN_0883c49c(param_2,1); piVar8 = *ppiVar2; if (piVar8 != (int *)0x0) { if ((uVar4 & 0x20) != 0) { if ((uVar5 & 0x70) == 0) { fVar7 = (float)(int)*pfVar3; } else { fVar7 = *pfVar3; } uVar6 = (**(code **)(*piVar8 + 0xc))(piVar8); FUN_08837558(fVar7,uVar6,uVar1); } if ((uVar4 & 4) != 0) { if ((uVar5 & 0x70) == 0) { fVar7 = *pfVar3; } else { fVar7 = (float)(int)*pfVar3; } uVar6 = (**(code **)(*piVar8 + 0xc))(piVar8); FUN_08837540(uVar6,uVar1,fVar7); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmagic.html": {
    "href": "setmagic.html",
    "title": "setMagic",
    "keywords": "setMagic Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMagic Scope: Global PAC Instruction (Binary): 25 16 4b 00 Assembly Address in Memory : 0x891e5c8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e5c8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) { FUN_088c65b0(iVar4,*puVar2); FUN_088c65c0(iVar4,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmarchwaytypereverce.html": {
    "href": "setmarchwaytypereverce.html",
    "title": "setMarchWayTypeReverce",
    "keywords": "setMarchWayTypeReverce Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMarchWayTypeReverce Scope: Global PAC Instruction (Binary): 25 16 64 00 Assembly Address in Memory : 0x89203fc Parameters (int)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089203fc(undefined4 param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *piVar1; iVar3 = Save::Get_Save_BaseAddr(1); *(uint *)(*(int *)(iVar3 + 0x58) + 0x30) = (uint)(iVar2 == 0); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmaxhitpoint.html": {
    "href": "setmaxhitpoint.html",
    "title": "setMaxHitPoint",
    "keywords": "setMaxHitPoint Sets maximum stamina of an object. Code Information Name: setMaxHitPoint Scope: Global PAC Instruction (Binary): 25 17 29 00 Assembly Address in Memory : 0x89135f4 Parameters (int *)handle (8 bytes) : Handle of the object to set the max stamina. (int)stamina (8 bytes) : Amount of stamina to set. Example Here is one example in hex: 25 17 29 00 / 08 00 00 00 / 7f 00 00 00 / 02 00 00 00 / a0 86 01 00 Which is interpreted as: setMaxHitPoint(((global)int *)giVar127, (int)100000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089135f4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 0xcc); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { FUN_088985f4(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmaxmissionareaid.html": {
    "href": "setmaxmissionareaid.html",
    "title": "setMaxMissionAreaId",
    "keywords": "setMaxMissionAreaId Sets floor amount of the dungeon. This is called very first of the PAC instructions. For non-dungeon missions, it is always 1. Code Information Name: setMaxMissionAreaId Scope: Global PAC Instruction (Binary): 25 12 03 00 Assembly Address in Memory : 0x8a1d124 Parameters (int)floor_amount (8 bytes) : Floor amount to set. Example Here is one example in hex: 25 12 03 00 / 02 00 00 00 / 05 00 00 00 Which is interpreted as: setMaxMissionAreaId((int)5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d124(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x544) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmessagecolor.html": {
    "href": "setmessagecolor.html",
    "title": "setMessageColor",
    "keywords": "setMessageColor Sets the colour of the sysytemMessage. Code Information Name: setMessageColor Scope: Global PAC Instruction (Binary): 25 03 07 00 Assembly Address in Memory : 0x892c654 Parameters (int)red (8 bytes) : Red, in range of 0~255. (int)green (8 bytes) : Green, in range of 0~255. (int)blue (8 bytes) : Blue, in range of 0~255. (int)alpha (8 bytes) : (Supposed to be) alpha in range of 0~255, but does not work. Example Here is one example in hex: 25 03 07 00 / 02 00 00 00 / dc 00 00 00 / 02 00 00 00 / dc 00 00 00 / 02 00 00 00 / fa 00 00 00 / 02 00 00 00 / ff 00 00 00 Which is interpreted as: setMessageColor((int)220, (int)220, (int)250, (int)255) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892c654(int param_1,undefined4 param_2) { undefined *puVar1; undefined *puVar2; undefined *puVar3; undefined *puVar4; puVar1 = (undefined *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined *)Pac_Get_Param(param_2,3,1,4); *(uint *)(param_1 + 0x23c) = CONCAT13(*puVar4,CONCAT12(*puVar3,CONCAT11(*puVar2,*puVar1))); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmissionareaid.html": {
    "href": "setmissionareaid.html",
    "title": "setMissionAreaId",
    "keywords": "setMissionAreaId Sets current floor of the dungeon. Dungeon index starts from 0, floor 1 results zero. Code Information Name: setMissionAreaId Scope: Global PAC Instruction (Binary): 25 12 07 00 Assembly Address in Memory : 0x8a1d2bc Parameters (int)dungeon_floor (8 bytes) : Dungeon floor id to set, starts from zero. \"Floor number\" is this number +1. Example Here is one example in hex: 25 12 07 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setMissionAreaId((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d2bc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x540) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmissiontimmingscript.html": {
    "href": "setmissiontimmingscript.html",
    "title": "setMissionTimmingScript",
    "keywords": "setMissionTimmingScript Callback when the mission is loaded in certain phase. Called after getPack. More information in How To: Define a Mission. Code Information Name: setMissionTimmingScript Scope: Global PAC Instruction (Binary): 25 12 02 00 Assembly Address in Memory : 0x8a1d030 Parameters (int)phase (8 bytes) : Loading phase, usually 0~2. Must be smaller than 4. Phase 0: Load resources. Phase 1: Create and define entities. Define Items (such as beginAppearItem), Create Entities (create...) Phase 2: Late setup, setup more information of the entities, also loads stages. Setup some UI flags, setupUnit, applyUnit, appearance/reborn position etc. (MemoryAddress)pac_address (8 bytes) : Memory address that contains start of the PAC, obtained from getPack. (Address)address (8 bytes): Address to call when the mission is loaded. Example Here is one example in hex: 25 12 02 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / f8 00 00 00 Which is interpreted as: setMissionTimmingScript((int)0, (int *)iVar0, (index)248) Here is typical setMissionTimmingScript usage. 0000008C 25100600:getPack(4:0) 00000098 25120200:setMissionTimmingScript(2:0, 4:0, 1:F0) 000000B4 25120200:setMissionTimmingScript(2:1, 4:0, 1:674) 000000D0 25120200:setMissionTimmingScript(2:2, 4:0, 1:8C4) 000000EC 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08a1d030(int param_1,undefined4 param_2) { uint *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; undefined4 *puVar6; int iVar7; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar7 = *(int *)(param_1 + 0x10); iVar5 = iVar7; if (iVar7 == 0) { iVar5 = 0; } if (iVar5 != 0) { if (iVar7 == 0) { iVar7 = 0x380; } else { iVar7 = iVar7 + 0x380; } if (*puVar1 < 4) { puVar6 = (undefined4 *)(iVar7 + *puVar1 * 8); } else { puVar6 = (undefined4 *)0x0; } uVar4 = *puVar3; *puVar6 = *puVar2; puVar6[1] = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmode.html": {
    "href": "setmode.html",
    "title": "setMode",
    "keywords": "setMode Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMode Scope: Mission PAC Instruction (Binary): 25 1f 03 00 Assembly Address in Memory : 0x8b5bea0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5bea0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56710(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmodeex.html": {
    "href": "setmodeex.html",
    "title": "setModeEx",
    "keywords": "setModeEx Connects the generator to e.g. death call to the other generator and/or reqActor (possibly \"parent\" structure of the unit etc). Code Information Name: setModeEx Scope: Mission PAC Instruction (Binary): 25 1f 1b 00 Assembly Address in Memory : 0x8b5bf98 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)mode_type (8 bytes) : Spawn point type. See below. (int)generator_identifier (8 bytes) : If doubt, set it to -1. Generator identifier to connect, from e.g.from create. (int)unique_identifier (8 bytes) : Identifier from various place, e.g. setReqActorUniqueId, addGimmick, getGateInfo or registConstGimmick. mode_type type 0 None 1 Constgimmick Destroying stops spawning 2 ??? 3 Constgimmick can be destroyed after all spawned enemies are killed (e.g. Fifty Cyclopses) 4 Spawned from index 0 of same generator entity Example Here is one example in hex: 25 1f 1b 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / ff ff ff ff Which is interpreted as: setModeEx(((global)int *)giVar26, (int)0, (int)-1, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5bf98(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; int *piVar4; int iVar5; undefined4 uVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = *(int *)(iVar5 + 0x2c8); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { if (*piVar3 < 0) { iVar5 = Get_BaseAddr_From_Generator(iVar5,*puVar1); if (*piVar4 < 0) { FUN_Mission__08b56760(iVar5,*puVar2,0,0); } else { FUN_Mission__08b56760(iVar5,*puVar2,0,*piVar4); if (*piVar3 == -1) { *(undefined *)(iVar5 + 0x26) = 1; } } } else { uVar6 = Get_Generator_HandleID(iVar5, *piVar3); uVar6 = Get_BaseAddr_From_Generator(iVar5,uVar6); uVar7 = Get_BaseAddr_From_Generator(iVar5,*puVar1); uVar6 = Get_ReqActor_Addr(uVar6,(int)*(char *)piVar4); FUN_Mission__08b56760(uVar7,*puVar2,uVar6,0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmodelcolor.html": {
    "href": "setmodelcolor.html",
    "title": "setModelColor",
    "keywords": "setModelColor Sets colour of (multiplies colour to) the model. Code Information Name: setModelColor Scope: Global PAC Instruction (Binary): 25 17 36 00 Assembly Address in Memory : 0x891457c Parameters (int *)handle_id (8 bytes) : Handle of the object. (float)Var1 (8 bytes) : Subtle colour adjustment for some objects, can keep 0 in most cases. (int)red (8 bytes) : Red Value of the colour to set, in range of 0~255. (int)green (8 bytes) : Green Value of the colour to set, in range of 0~255. (int)blue (8 bytes) : Blue Value of the colour to set, in range of 0~255. (int)alpha (8 bytes) : Alpha Value of the colour to set, in range of 0~255. Example Here is one example in hex: 25 17 36 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 41 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setModelColor((int *)iVar0, (float)16, (int)1, (int)1, (int)1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891457c(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; uint *puVar3; int *piVar4; int *piVar5; int *piVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); if (*piVar1 != -1) { iVar7 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar7 == 0) { iVar7 = 0; } if (iVar7 != 0) { (**(code **)(*(int *)(iVar7 + 4) + 0xa0)) (*puVar2,iVar7,*piVar6 << 0x18 | *piVar5 << 0x10 | *puVar3 | *piVar4 << 8); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmodelinfo.html": {
    "href": "setmodelinfo.html",
    "title": "setModelInfo",
    "keywords": "setModelInfo Sets position and movement information of the given handle. Before performing this, wait until the model is fully loaded. Code Information Name: setModelInfo Scope: Global PAC Instruction (Binary): 25 17 0b 00 Assembly Address in Memory : 0x8911588 Parameters (int *)handle_id (8 bytes) : Handle to set the model info. (float)position_x (8 bytes) : X Position of the model, as PSP pixels in the world. (float)position_y (8 bytes) : Y position of the model, as PSP pixels in the world. 0 is the center. (float)dest_x (8 bytes) : To where it will move, as X position. (float)dest_y (8 bytes) : To where it will move, as Y position. (float)random_start_offset (8 bytes) : Random offset from the position to be started. Works only when velocity value exists. Note that PSP screen size is 480 x 272. Sets velocity to 0 if the object shouldn't be moved. Remarks The velocity can be set also in effectparam. Example Here is one example in hex: 25 17 0b 00 / 04 00 00 00 / 00 00 00 00 / 20 00 00 00 / 02 00 00 00 / 20 00 00 00 / 03 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setModelInfo((int *)iVar0, (float *)fVar2, (float *)fVar3, (float)0, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911588(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; float *pfVar6; uint uVar7; undefined *puVar8; int iVar9; float fVar10; undefined4 uVar11; undefined4 uVar12; undefined4 uVar13; float fVar14; undefined4 uVar15; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; undefined4 local_18; undefined4 local_14; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); pfVar6 = (float *)Pac_Get_Param(param_2,5,1,4); if (param_1 == 0) { iVar9 = 0; } else { iVar9 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar9 == 0) { iVar9 = 0; } if (iVar9 == 0) { iVar9 = 0; } else { iVar9 = *(int *)(iVar9 + 200); if (iVar9 == 0) { iVar9 = 0; } } } if (iVar9 != 0) { uVar13 = *(undefined4 *)(iVar9 + 200); uVar12 = *(undefined4 *)(iVar9 + 0xcc); local_30 = *(undefined4 *)(iVar9 + 0xe0); local_2c = *(undefined4 *)(iVar9 + 0xe4); local_28 = *(undefined4 *)(iVar9 + 0xe8); local_24 = *(undefined4 *)(iVar9 + 0xec); if (*pfVar6 == 0.0) { local_30 = *puVar4; local_2c = *puVar5; } else { uVar7 = Util::Random::Timer_Get_Random(); fVar14 = *pfVar6 * ((float)(uVar7 & 0xffff) * 1.525879e-05 * 2.0 - 1.0); if (fVar14 < 0.0) { fVar14 = fVar14 + 360.0; } fVar10 = (float)FUN_0880e604(*puVar4,*puVar5); fVar10 = fVar10 + fVar14 * 0.01745329; local_30 = syscall::sinf(fVar10); local_2c = FUN_0880da1c(fVar10); local_14 = *puVar5; local_18 = *puVar4; uVar11 = FUN_088357b4(&local_18); syscall::vscl_q(uVar11,&local_30,&local_30); } uVar15 = *puVar2; uVar11 = *puVar3; *(undefined4 *)(iVar9 + 0xc0) = uVar15; *(undefined4 *)(iVar9 + 0xc4) = uVar11; *(undefined4 *)(iVar9 + 200) = uVar13; *(undefined4 *)(iVar9 + 0xcc) = uVar12; FUN_0888e270(iVar9,&local_30,0); FUN_0887f1e4(*(undefined4 *)(iVar9 + 0x1e0)); puVar8 = *(undefined **)(iVar9 + 0x1ec); if (puVar8 != (undefined *)0x0) { local_c = uVar15; local_8 = uVar11; local_4 = uVar13; FUN_08983b94(puVar8,&local_c); *puVar8 = 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmodellowerheight.html": {
    "href": "setmodellowerheight.html",
    "title": "setModelLowerHeight",
    "keywords": "setModelLowerHeight Moves unit, squad or troop model's Y position. Code Information Name: setModelLowerHeight Scope: Global PAC Instruction (Binary): 25 17 66 00 Assembly Address in Memory : 0x89181d4 Parameters (int *)handle (8 bytes) : Handle of the model. (bool)move_children (8 bytes) : 1 moves the model with children. 0 moves only self. (float)pos_y (8 bytes) : Y position of the model to set, as PSP pixels. Example Here is one example in hex: 25 17 66 00 / 08 00 00 00 / 68 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 c2 Which is interpreted as: setModelLowerHeight(((global)int *)giVar104, (int)1, (float)-32) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089181d4(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; int iVar6; int iVar7; int iVar8; undefined4 uVar9; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 9) { if (*(int *)(iVar4 + 200) == 0) { iVar5 = *piVar2; } else { *(bool *)(*(int *)(iVar4 + 200) + 0x165) = *piVar2 == 0; iVar5 = *piVar2; } if (iVar5 == 0) { uVar9 = 0; } else { uVar9 = *puVar3; } *(undefined4 *)(iVar4 + 0x164) = uVar9; } else { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 3) { iVar5 = FUN_088c5340(iVar4); iVar8 = 0; if (0 < iVar5) { do { iVar6 = FUN_088c5348(iVar4,iVar8); if (iVar6 != 0) { if (*(int *)(iVar6 + 200) == 0) { iVar7 = *piVar2; } else { *(bool *)(*(int *)(iVar6 + 200) + 0x165) = *piVar2 == 0; iVar7 = *piVar2; } if (iVar7 == 0) { uVar9 = 0; } else { uVar9 = *puVar3; } *(undefined4 *)(iVar6 + 0x164) = uVar9; } iVar8 = iVar8 + 1; } while (iVar8 < iVar5); } } else { iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); if (iVar5 == 2) { if (*piVar2 == 0) { FUN_088e3444(iVar4); } else { FUN_088e3268(*puVar3,iVar4); } } } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmodelrotate.html": {
    "href": "setmodelrotate.html",
    "title": "setModelRotate",
    "keywords": "setModelRotate Rotates a model by its handle. Code Information Name: setModelRotate Scope: Global PAC Instruction (Binary): 25 19 15 00 Assembly Address in Memory : 0x8942314 Parameters (int *)handle (8 bytes) : Handle of the target. (int)Var1 (8 bytes) : Please describe what this does, keep 1 to enable rotation. (float)angle (8 bytes) : Angle to rotate. Example Here is one example in hex: 25 19 15 00 / 04 00 00 00 / 11 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 b4 42 Which is interpreted as: setModelRotate((int *)iVar17, (int)1, (float)90) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942314(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { *(byte *)(iVar4 + 0x324) = *(byte *)(iVar4 + 0x324) & 0xef | (*piVar2 != 0) << 4; *(undefined4 *)(iVar4 + 800) = *puVar3; FUN_088d4c60(0x3f800000,0x3f800000,*puVar3,iVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmonstercollisiontype.html": {
    "href": "setmonstercollisiontype.html",
    "title": "setMonsterCollisionType",
    "keywords": "setMonsterCollisionType Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMonsterCollisionType Scope: Mission PAC Instruction (Binary): 25 1f 33 00 Assembly Address in Memory : 0x8b5eee0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5eee0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57b98(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmotion_25171100.html": {
    "href": "setmotion_25171100.html",
    "title": "setMotion (25171100)",
    "keywords": "setMotion (25171100) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMotion Scope: Global PAC Instruction (Binary): 25 17 11 00 Assembly Address in Memory : 0x8911d30 Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (int)Var2 (8 bytes) (float)Var3 (8 bytes) Example Here is one example in hex: 25 17 11 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 40 40 Which is interpreted as: setMotion((int *)iVar0, (int)2, (int)0, (float)3) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911d30(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; int *piVar3; float *pfVar4; uint uVar5; undefined4 uVar6; int iVar7; uint uVar8; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); if (param_1 == 0) { iVar7 = 0; } else { iVar7 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar7 == 0) { iVar7 = 0; } if (iVar7 == 0) { iVar7 = 0; } else { iVar7 = *(int *)(iVar7 + 200); if (iVar7 == 0) { iVar7 = 0; } } } if ((iVar7 != 0) && (uVar8 = *puVar2, uVar5 = (**(code **)(**(int **)(iVar7 + 0x60) + 0x20))(), uVar8 < uVar5)) { *(undefined *)(iVar7 + 0xb9) = 0; uVar6 = FUN_08875ca8(); *(undefined4 *)(iVar7 + 0x100) = uVar6; (**(code **)(*(int *)(iVar7 + 0x7c) + 0x14))(iVar7,*puVar2,*piVar3 != 0); if (0.0 < *pfVar4) { *(float *)(iVar7 + 0x68) = *pfVar4; if (*(float *)(iVar7 + 0x70) < *(float *)(iVar7 + 0x68)) { *(float *)(iVar7 + 0x68) = *(float *)(iVar7 + 0x70); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmotion_25211b00.html": {
    "href": "setmotion_25211b00.html",
    "title": "setMotion (25211b00)",
    "keywords": "setMotion (25211b00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMotion Scope: Global PAC Instruction (Binary): 25 21 1b 00 Assembly Address in Memory : 0x89b31c4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) (float)Var3 (8 bytes) Example Here is one example in hex: 25 21 1b 00 / 04 00 00 00 / 15 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setMotion((int *)iVar21, (int)1, (int)1, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b31c4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; float *pfVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar5 != 0) && ((**(code **)(*(int *)(*(int *)(iVar5 + 200) + 0x7c) + 0x14)) (*(int *)(iVar5 + 200),*puVar2,*piVar3 != 0), *pfVar4 != 0.0)) { iVar5 = *(int *)(iVar5 + 200); *(float *)(iVar5 + 0x68) = *pfVar4; if (*(float *)(iVar5 + 0x70) < *(float *)(iVar5 + 0x68)) { *(float *)(iVar5 + 0x68) = *(float *)(iVar5 + 0x70); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmotiondirect.html": {
    "href": "setmotiondirect.html",
    "title": "setMotionDirect",
    "keywords": "setMotionDirect Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMotionDirect Scope: Global PAC Instruction (Binary): 25 16 05 01 Assembly Address in Memory : 0x89283d4 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) (int)Var2 (8 bytes) (int)Var3 (8 bytes) Example Here is one example in hex: 25 16 05 01 / 08 00 00 00 / 68 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setMotionDirect(((global)int *)giVar104, (int)1, (int)1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089283d4(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int *piVar3; int *piVar4; int iVar5; int iVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); iVar6 = *piVar2; uVar7 = 0xffffffff; if (iVar6 == 3) { uVar7 = 0x3a; } else if (iVar6 == 2) { uVar7 = 1; } else if (iVar6 == 1) { uVar7 = 6; } else if (iVar6 == 0) { uVar7 = 7; } if (iVar5 != 0) { iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); if (iVar6 == 9) { FUN_088c2744(iVar5,uVar7,*piVar3 != 0,*piVar4 != 0); } else { iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); if (iVar6 == 3) { FUN_088c6f78(iVar5,uVar7,*piVar3 != 0,*piVar4 != 0); } else { iVar6 = (**(code **)(*(int *)(iVar5 + 4) + 0x34))(iVar5); if (iVar6 == 2) { FUN_088e39c4(iVar5,uVar7,*piVar3 != 0,*piVar4 != 0); } } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmotioneventtimmingscript.html": {
    "href": "setmotioneventtimmingscript.html",
    "title": "setMotionEventTimmingScript",
    "keywords": "setMotionEventTimmingScript Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMotionEventTimmingScript Scope: Global PAC Instruction (Binary): 25 16 0b 00 Assembly Address in Memory : 0x89198e4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (Address)address (8 bytes) Example Here is one example in hex: 25 16 0b 00 / 02 00 00 00 / 91 01 00 00 / 02 00 00 00 / 02 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 34 00 00 00 Which is interpreted as: setMotionEventTimmingScript((int)401, (int)2, (int *)iVar0, (index)52) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089198e4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(*(int *)(param_1 + 0x10) + 0x138); if (iVar5 != 0) { FUN_08891634(iVar5,*puVar1,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmotionframeratio.html": {
    "href": "setmotionframeratio.html",
    "title": "setMotionFrameRatio",
    "keywords": "setMotionFrameRatio Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMotionFrameRatio Scope: Global PAC Instruction (Binary): 25 17 1e 00 Assembly Address in Memory : 0x8912ba8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912ba8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar2; if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0xa8) = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmovespeedratio_25164900.html": {
    "href": "setmovespeedratio_25164900.html",
    "title": "setMoveSpeedRatio (25164900)",
    "keywords": "setMoveSpeedRatio (25164900) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMoveSpeedRatio Scope: Global PAC Instruction (Binary): 25 16 49 00 Assembly Address in Memory : 0x891e444 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 49 00 / 08 00 00 00 / a6 00 00 00 / 20 00 00 00 / 0b 00 00 00 Which is interpreted as: setMoveSpeedRatio(((global)int *)giVar166, (float *)fVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e444(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) && (iVar3 != -0x1f0)) { FUN_088f7254(*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmovespeedratio_25171200.html": {
    "href": "setmovespeedratio_25171200.html",
    "title": "setMoveSpeedRatio (25171200)",
    "keywords": "setMoveSpeedRatio (25171200) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMoveSpeedRatio Scope: Global PAC Instruction (Binary): 25 17 12 00 Assembly Address in Memory : 0x8911eb8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 17 12 00 / 04 00 00 00 / 15 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: setMoveSpeedRatio((int *)iVar21, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911eb8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (param_1 == 0) { iVar3 = 0; } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = *(int *)(iVar3 + 200); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x17c) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmsgwndapproachonscreen.html": {
    "href": "setmsgwndapproachonscreen.html",
    "title": "setMsgWndApproachOnScreen",
    "keywords": "setMsgWndApproachOnScreen Sets \"message approach on screen\" value of the message handle. Seems there is no difference to set this or not, tell if there is any difference. Code Information Name: setMsgWndApproachOnScreen Scope: Global PAC Instruction (Binary): 25 17 30 00 Assembly Address in Memory : 0x8914080 Parameters (int *)speech_bubble_id (8 bytes) : Speech Bubble window ID, obtained from callMessageWindow 2nd parameter. (bool)is_approach (8 bytes) : This enables or disables \"approach on screen\". Example Here is one example in hex: 25 17 30 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setMsgWndApproachOnScreen((int *)iVar0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914080(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 4) + 0xf8))(iVar3,*piVar2 != 0); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmsgwndcolor.html": {
    "href": "setmsgwndcolor.html",
    "title": "setMsgWndColor",
    "keywords": "setMsgWndColor Sets background colour of the bubble speech. See also How To: Set Speech Bubble Code Information Name: setMsgWndColor Scope: Global PAC Instruction (Binary): 25 17 32 00 Assembly Address in Memory : 0x89141fc Parameters (int *)speech_bubble_id (8 bytes) : Speech Bubble window ID, obtained from callMessageWindow 2nd parameter. (int)red (8 bytes) : Red, in range of 0~255. (int)green (8 bytes) : Green, in range of 0~255. (int)blue (8 bytes) : Blue, in range of 0~255. Example Here is one example in hex: 25 17 32 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff 00 00 00 / 02 00 00 00 / af 00 00 00 / 02 00 00 00 / be 00 00 00 Which is interpreted as: setMsgWndColor((int *)iVar0, (int)255, (int)175, (int)190) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089141fc(int param_1,undefined4 param_2) { int *piVar1; undefined *puVar2; undefined *puVar3; undefined *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined *)Pac_Get_Param(param_2,3,1,4); if (*piVar1 != -1) { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 != 0) { (**(code **)(*(int *)(iVar5 + 4) + 0x104))(iVar5,*puVar2,*puVar3,*puVar4); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmsgwndmsgtype.html": {
    "href": "setmsgwndmsgtype.html",
    "title": "setMsgWndMsgType",
    "keywords": "setMsgWndMsgType Seems like this doesn't do much anything. Called when e.g. Deth dying. Please decribe if you found what this does. Code Information Name: setMsgWndMsgType Scope: Global PAC Instruction (Binary): 25 17 33 00 Assembly Address in Memory : 0x8914300 Parameters (int *)speech_bubble_id (8 bytes) : Speech Bubble window ID, obtained from callMessageWindow 2nd parameter. (undefined4)Var1 (8 bytes) : Usually it is 1. Example Here is one example in hex: 25 17 33 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setMsgWndMsgType((int *)iVar0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914300(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 4) + 0x128))(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmsgwndpriority.html": {
    "href": "setmsgwndpriority.html",
    "title": "setMsgWndPriority",
    "keywords": "setMsgWndPriority Decides how top the speech bubble should be (render priority). See also How To: Set Speech Bubble Code Information Name: setMsgWndPriority Scope: Global PAC Instruction (Binary): 25 17 31 00 Assembly Address in Memory : 0x8914140 Parameters (int *)speech_bubble_id (8 bytes) : Speech Bubble window ID, obtained from callMessageWindow 2nd parameter. (int)priority (8 bytes) : Speech bubble priority (how top it is). Set 0xF423F (999999) to ensure the message is on the top. Higher priority value covers the lower value priority on the screen. Note the high priority value is required for covering UI. For example, to cover VS UI at least 0xC38E8 (801000) priority is required. Example Here is one example in hex: 25 17 31 00 / 08 00 00 00 / 5b 00 00 00 / 02 00 00 00 / 3f 42 0f 00 Which is interpreted as: setMsgWndPriority(((global)int *)giVar91, (int)999999) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914140(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 4) + 0x100))(iVar3,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmsgwndrender.html": {
    "href": "setmsgwndrender.html",
    "title": "setMsgWndRender",
    "keywords": "setMsgWndRender Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setMsgWndRender Scope: Global PAC Instruction (Binary): 25 16 a3 00 Assembly Address in Memory : 0x89229c4 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 a3 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setMsgWndRender((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089229c4(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x178); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_0893d52c(iVar2,*piVar1 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmssionbgmid.html": {
    "href": "setmssionbgmid.html",
    "title": "setMssionBgmId",
    "keywords": "setMssionBgmId Forces theme for the mission. This is used in Dungeon to change music between floors. Expected in setMissionTimmingScript phase 0. Code Information Name: setMssionBgmId Scope: Global PAC Instruction (Binary): 25 0a 1b 00 Assembly Address in Memory : 0x894b104 Parameters (int)bgm_id (8 bytes) : The theme ID. (int)overwrite_selectable_theme (8 bytes) : 1 overwrites the selectable theme, 0 gives priority to the selectable theme. Remarks With DxD random theme, this instruction will take priority. Example Here is one example in hex: 25 0a 1b 00 / 02 00 00 00 / 13 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setMssionBgmId((int)19, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b104(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar5 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar4 = *piVar2; Save::Get_Save_BaseAddr(1); iVar3 = Get_Some_Flag(1); iVar3 = *(int *)(iVar3 + 0x44); if (iVar4 == 0) { // using custom theme? if (*(char *)(iVar3 + 0x54a) == '\\0') { *(short *)(iVar3 + 0x548) = (short)uVar5; } } else { *(short *)(iVar3 + 0x548) = (short)uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setmultimapviewstate.html": {
    "href": "setmultimapviewstate.html",
    "title": "setMultimapViewState",
    "keywords": "setMultimapViewState Only for VS mission, displays or hides the top UI on the VS map. Code Information Name: setMultimapViewState Scope: Global PAC Instruction (Binary): 25 16 d9 00 Assembly Address in Memory : 0x8926294 Parameters (bool)show_vs_map (8 bytes) : Shows the top UI on the VS map. (bool)bVar1 (8 bytes) Example Here is one example in hex: 25 16 d9 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setMultimapViewState((int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926294(int param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c); iVar4 = *(int *)(iVar3 + 0x54); iVar3 = *(int *)(iVar3 + 0x58); if (iVar4 != 0) { if (*piVar1 == 0) { *(uint *)(iVar4 + 0xbc) = *(uint *)(iVar4 + 0xbc) | *puVar2; } else { *(uint *)(iVar4 + 0xbc) = *(uint *)(iVar4 + 0xbc) & ~(uint)(*piVar1 != 0); } } if (iVar3 != 0) { if (*piVar1 == 0) { *(uint *)(iVar3 + 0x400) = *(uint *)(iVar3 + 0x400) | *puVar2; } else { *(uint *)(iVar3 + 0x400) = *(uint *)(iVar3 + 0x400) & ~*puVar2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setnetworklogoutputtype.html": {
    "href": "setnetworklogoutputtype.html",
    "title": "setNetworkLogOutputType",
    "keywords": "setNetworkLogOutputType Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setNetworkLogOutputType Scope: Global PAC Instruction (Binary): 25 16 0a 01 Assembly Address in Memory : 0x89289e8 Parameters (undefined4)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089289e8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Debug::Get_Log_Setting(1); FUN_0896df38(*(undefined4 *)(iVar2 + 0x4c),*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setnodedisp.html": {
    "href": "setnodedisp.html",
    "title": "setNodeDisp",
    "keywords": "setNodeDisp Shows or hides the node in the object. Code Information Name: setNodeDisp Scope: Global PAC Instruction (Binary): 25 17 23 00 Assembly Address in Memory : 0x8913078 Parameters (int *)handle_id (8 bytes) : The target handle. (int *)node_index (8 bytes) : Node index, obtained from getNodeIndex. (bool)display_node (8 bytes) : 1 shows the object in the node, 0 hides the node objects. Example Here is one example in hex: 25 17 23 00 / 08 00 00 00 / 5b 00 00 00 / 08 00 00 00 / ff 01 00 00 / 08 00 00 00 / 5d 00 00 00 Which is interpreted as: setNodeDisp(((global)int *)giVar91, ((global)int *)giVar511, ((global)int *)giVar93) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08913078(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int *piVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); if (param_1 == 0) { iVar4 = 0; } else { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 == 0) { iVar4 = 0; } else { iVar4 = *(int *)(iVar4 + 200); if (iVar4 == 0) { iVar4 = 0; } } } if (iVar4 != 0) { (**(code **)(**(int **)(iVar4 + 0x60) + 0x68))(*(int **)(iVar4 + 0x60),*puVar2,*piVar3 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setnotrespassing.html": {
    "href": "setnotrespassing.html",
    "title": "setNoTrespassing",
    "keywords": "setNoTrespassing Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setNoTrespassing Scope: Global PAC Instruction (Binary): 25 16 dc 00 Assembly Address in Memory : 0x89236b4 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089236b4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 != 0) { if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } iVar3 = FUN_088a8650(iVar3,*puVar1); FUN_08954fb8(*puVar2,iVar3 + 0x2b0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setparent.html": {
    "href": "setparent.html",
    "title": "setParent",
    "keywords": "setParent Sets parent handle of a handle. Code Information Name: setParent Scope: Global PAC Instruction (Binary): 25 17 6e 00 Assembly Address in Memory : 0x8917264 Parameters (int *)handle_id (8 bytes) : The target handle. (int)Var1 (8 bytes) : Set 1 if it is not sure. (int *)parent_handle (8 bytes) : The parent handle to set. Example Here is one example in hex: 25 17 6e 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 0f 00 00 00 Which is interpreted as: setParent((int *)iVar0, (int)1, (int *)iVar15) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08917264(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar3,1); if (iVar5 == 0) { iVar5 = 0; } if (((iVar4 != 0) && (iVar5 != 0)) && (*piVar2 != 0)) { if (*piVar2 == 1) { *(int *)(iVar4 + 0x7c) = iVar5; } else { *(int *)(iVar4 + 0x80) = iVar5; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setphasewait.html": {
    "href": "setphasewait.html",
    "title": "setPhaseWait",
    "keywords": "setPhaseWait Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setPhaseWait Scope: Global PAC Instruction (Binary): 25 19 1d 00 Assembly Address in Memory : 0x89413e0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 19 1d 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: setPhaseWait((int *)iVar0, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089413e0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 != 0) { iVar3 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); if (iVar3 == 0xb) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } FUN_089c91b8(*puVar2,iVar3 + 0x288); } else if (iVar3 == 10) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } FUN_089c91b8(*puVar2,iVar3 + 0x160); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setplayerdata.html": {
    "href": "setplayerdata.html",
    "title": "setPlayerData",
    "keywords": "setPlayerData Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setPlayerData Scope: Global PAC Instruction (Binary): 25 0a 13 00 Assembly Address in Memory : 0x894a6cc Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (Undefined)Var5 (8 bytes) Example Here is one example in hex: 25 0a 13 00 / 02 00 00 00 / 04 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setPlayerData((int)4, (int)2, (int)-1, (int)2, (int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a6cc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; undefined4 uVar6; undefined4 uVar7; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar6 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar5 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); uVar3 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); uVar7 = *puVar1; uVar2 = Pac_Get_Param(param_2,5,1,4); FUN_0894ad3c(param_1,1,uVar6,uVar5,uVar4,uVar3,uVar7,uVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setplayerid.html": {
    "href": "setplayerid.html",
    "title": "setPlayerId",
    "keywords": "setPlayerId Sets ID of the player. Code Information Name: setPlayerId Scope: Global PAC Instruction (Binary): 25 16 30 00 Assembly Address in Memory : 0x891cb04 Parameters (int *)squad_handle (8 bytes) : Squad handle, obtained from e.g. getPlayerSquadHandle, getMultiPlayerSquadHandle or addSquad. (int)player_id (8 bytes) : Player ID to set. Example Here is one example in hex: 25 16 30 00 / 04 00 00 00 / 35 00 00 00 / 04 00 00 00 / 33 00 00 00 Which is interpreted as: setPlayerId((int *)iVar53, (int *)iVar51) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891cb04(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { FUN_088c45f0(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setplayersquadtype.html": {
    "href": "setplayersquadtype.html",
    "title": "setPlayerSquadType",
    "keywords": "setPlayerSquadType Sets type of the player squad. Describe what the type is. Code Information Name: setPlayerSquadType Scope: Global PAC Instruction (Binary): 25 16 44 00 Assembly Address in Memory : 0x891e080 Parameters (int *)player_squadhandle (8 bytes) : The player squad handle. 4:35 is usually used for player squad handle. (int)squad_type (8 bytes) : Expected 0~2. Example Here is one example in hex: 25 16 44 00 / 08 00 00 00 / 6c 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setPlayerSquadType(((global)int *)giVar108, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891e080(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { iVar4 = *piVar2; if (iVar4 == 2) { FUN_088c5ea0(iVar3); } else if (iVar4 == 1) { FUN_088c5ea0(iVar3,2); } else if (iVar4 == 0) { FUN_088c5ea0(iVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setpoint.html": {
    "href": "setpoint.html",
    "title": "setPoint",
    "keywords": "setPoint Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setPoint Scope: Global PAC Instruction (Binary): 25 20 03 00 Assembly Address in Memory : 0x89b0e64 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 20 03 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 48 43 Which is interpreted as: setPoint((int)0, (float)200) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b0e64(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x14) != 0) { FUN_0898e01c(*puVar2,*(int *)(param_1 + 0x14),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setposition.html": {
    "href": "setposition.html",
    "title": "setPosition",
    "keywords": "setPosition Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Might not be useful, this is not object positioning. Code Information Name: setPosition Scope: Global PAC Instruction (Binary): 25 03 10 00 Assembly Address in Memory : 0x892e1e0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 03 10 00 / 10 00 00 00 / 00 00 70 43 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: setPosition((float)240, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892e1e0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 uVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x2c); if (iVar3 != 0) { uVar4 = *puVar2; *(undefined4 *)(iVar3 + 0x170) = *puVar1; *(undefined4 *)(iVar3 + 0x174) = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setposx.html": {
    "href": "setposx.html",
    "title": "setPosX",
    "keywords": "setPosX Sets X position of the given generator. Code Information Name: setPosX Scope: Mission PAC Instruction (Binary): 25 1f 05 00 Assembly Address in Memory : 0x8b5c208 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (float)position (8 bytes) : X Position of the unit, as PSP pixels in the world. Note that PSP screen size is 480 x 272. Example Here is one example in hex: 25 1f 05 00 / 08 00 00 00 / 1a 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setPosX(((global)int *)giVar26, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c208(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else if (*piVar1 == -1) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar3 + 0x2c8)); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x18) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setpushparam.html": {
    "href": "setpushparam.html",
    "title": "setPushParam",
    "keywords": "setPushParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setPushParam Scope: Global PAC Instruction (Binary): 25 17 45 00 Assembly Address in Memory : 0x8915b0c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 17 45 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 0e 01 00 00 Which is interpreted as: setPushParam((int *)iVar0, (int)2, (int)270) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915b0c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar5 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar3 = *puVar1; if (param_1 == 0) { iVar2 = 0; } else { iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),uVar5,1); if (iVar2 == 0) { iVar2 = 0; } if (iVar2 == 0) { iVar2 = 0; } else { iVar2 = *(int *)(iVar2 + 0xd0); if (iVar2 == 0) { iVar2 = 0; } } } if (iVar2 != 0) { FUN_088dd02c(iVar2,uVar4,uVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setquestlevel.html": {
    "href": "setquestlevel.html",
    "title": "setQuestLevel",
    "keywords": "setQuestLevel Defines the default level value the whole mission. Use setQuestLevelRevise for quest scope level. Code Information Name: setQuestLevel Scope: Global PAC Instruction (Binary): 25 16 a4 00 Assembly Address in Memory : 0x8922a50 Parameters (int)quest_level (8 bytes) : Quest level to set. Example Here is one example in hex: 25 16 a4 00 / 08 00 00 00 / 32 00 00 00 Which is interpreted as: setQuestLevel(((global)int *)giVar50) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922a50(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x554) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setquestlevelrevise.html": {
    "href": "setquestlevelrevise.html",
    "title": "setQuestLevelRevise",
    "keywords": "setQuestLevelRevise Defines the level of the whole mission. This affects every enemy stat. See also: About Levels. Code Information Name: setQuestLevelRevise Scope: Global PAC Instruction (Binary): 25 16 a6 00 Assembly Address in Memory : 0x8922b10 Parameters (int)quest_level (8 bytes) : Quest level to set. If this is zero, level from setQuestLevel will be used instead. Example Here is one example in hex: 25 16 a6 00 / 08 00 00 00 / 33 00 00 00 Which is interpreted as: setQuestLevelRevise(((global)int *)giVar51) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922b10(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x558) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setquestpayexp.html": {
    "href": "setquestpayexp.html",
    "title": "setQuestPayExp",
    "keywords": "setQuestPayExp Assigns exp points given by finishing the mission. This applies when finishing the mission only, and doesn't do anything with rewards by killing enemies. Code Information Name: setQuestPayExp Scope: Global PAC Instruction (Binary): 25 16 d6 00 Assembly Address in Memory : 0x8926068 Parameters (int)exp_amount (8 bytes) : Experience amount to give after finishing the mission. (bool)enabled (8 bytes) : If this is 0, this reward is disabled, thus it's not given at all. Example Here is one example in hex: 25 16 d6 00 / 08 00 00 00 / 34 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setQuestPayExp(((global)int *)giVar52, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926068(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar5 = *puVar1; piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = *piVar2; iVar4 = Get_Some_Flag(1); if (iVar3 == 0) { iVar3 = *(int *)(iVar4 + 0x44) + 0x7D0; } else { iVar3 = *(int *)(iVar4 + 0x44) + 0x788; } FUN_08a15688(iVar3,uVar5); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setquestpayitem.html": {
    "href": "setquestpayitem.html",
    "title": "setQuestPayItem",
    "keywords": "setQuestPayItem Assigns an item given by finishing the mission. The \"Reward: XXX\" in mission description is related to this. This applies when finishing the mission only, and doesn't do anything with enemy item drops. Code Information Name: setQuestPayItem Scope: Global PAC Instruction (Binary): 25 16 d5 00 Assembly Address in Memory : 0x8925f6c Parameters (int)item_type (8 bytes) : Type of the item as item ID, can be e.g. chest ID. (int)item_level (8 bytes) : Level of the item. 0 gives same level of reward as quest level. (bool)enabled (8 bytes) : If this is 0, this reward is disabled, thus it's not given at all. (bool)allow_duplication (8 bytes) : Allows giving the item if same item type exists. If this is 0 and if the same item is defined through setQuestPayItem, this wipes out the prior pay item and overwrites to the current value. Activated only with enabled flag. Remarks setQuestPayItem reward can be changed later. setQuestPayItem can be defined multiple times, but be careful and do not assign duplicated item type. Example Here is one example in hex: 25 16 d5 00 / 08 00 00 00 / 50 00 00 00 / 08 00 00 00 / 51 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setQuestPayItem(((global)int *)giVar80, ((global)int *)giVar81, (int)1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925f6c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; int iVar5; undefined4 uVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar7 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar6 = *puVar2; piVar1 = (int *)Pac_Get_Param(param_2,2,1,4); iVar3 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,3,1,4); iVar4 = *piVar1; if (0 < iVar7) { iVar5 = Get_Some_Flag(1); if (iVar3 == 0) { iVar3 = *(int *)(iVar5 + 0x44) + 0x7D0; } else { iVar3 = *(int *)(iVar5 + 0x44) + 0x788; } if (iVar4 == 0) { FUN_08a155c0(iVar3,iVar7,uVar6); } else { FUN_08a15550(iVar3,iVar7,uVar6); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setrainlevel.html": {
    "href": "setrainlevel.html",
    "title": "setRainLevel",
    "keywords": "setRainLevel Sets the raining amount. This works both in hideout and during mission. Code Information Name: setRainLevel Scope: Global PAC Instruction (Binary): 25 16 72 00 Assembly Address in Memory : 0x8920a6c Parameters (float)amount (8 bytes) : The amount how much the rain falls, the value is between 0~1. 0 means no rain. Example Here is one example in hex: 25 16 72 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setRainLevel((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920a6c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { Set_Rain(*puVar1,iVar2 + 0x1d0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setrebornposition.html": {
    "href": "setrebornposition.html",
    "title": "setRebornPosition",
    "keywords": "setRebornPosition Decides unit reborn position in the troop. Code Information Name: setRebornPosition Scope: Global PAC Instruction (Binary): 25 16 21 00 Assembly Address in Memory : 0x891ba34 Parameters (int *)handle_id (8 bytes) : Handle of the troop. (float)reborn_position (8 bytes) : X Position to be reborn. 0 grants reborning in normal place. Example Here is one example in hex: 25 16 21 00 / 08 00 00 00 / 68 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setRebornPosition(((global)int *)giVar104, (float)0) This is reborn position in AoV VS Mission: 0005AF60 25162000:setAppearancePosition(8:68, -100.0) //blue troop 0005AF74 25162100:setRebornPosition(8:68, -200.0) 0005AF88 25162000:setAppearancePosition(8:74, 2100.0) //red troop 0005AF9C 25162100:setRebornPosition(8:74, 2200.0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ba34(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 != 0) { FUN_088de088(*puVar2,iVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setrendernoflip.html": {
    "href": "setrendernoflip.html",
    "title": "setRenderNoFlip",
    "keywords": "setRenderNoFlip Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setRenderNoFlip Scope: Global PAC Instruction (Binary): 25 19 21 00 Assembly Address in Memory : 0x8942da8 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 19 21 00 / 08 00 00 00 / 7f 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setRenderNoFlip(((global)int *)giVar127, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08942da8(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } else if (iVar3 == 0) { iVar3 = 0; } else { (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3); } if (iVar3 != 0) { *(byte *)(iVar3 + 0x1d5) = *(byte *)(iVar3 + 0x1d5) & 0x7f | (*piVar2 != 0) << 7; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setrenderpriority_25030900.html": {
    "href": "setrenderpriority_25030900.html",
    "title": "setRenderPriority (25030900)",
    "keywords": "setRenderPriority (25030900) Other functions have the same name. Check the Disambiguation page to find them. Sets render priority of something. Please explain. Code Information Name: setRenderPriority Scope: Global PAC Instruction (Binary): 25 03 09 00 Assembly Address in Memory : 0x892d4c8 Parameters (int)priority (8 bytes) : Render priority to set. Example This shows ending sysytemmessage render priority: 25 03 09 00 / 02 00 00 00 / ad bb 0d 00 Which is interpreted as: setRenderPriority((int)900013) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892d4c8(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x2c) != 0) { *(undefined4 *)(param_1 + 0x244) = *puVar1; (**(code **)(*(int *)(*(int *)(param_1 + 0x2c) + 0x32c) + 0x14)) (*(int *)(param_1 + 0x2c) + 0x310,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setrenderpriority_25171800.html": {
    "href": "setrenderpriority_25171800.html",
    "title": "setRenderPriority (25171800)",
    "keywords": "setRenderPriority (25171800) Other functions have the same name. Check the Disambiguation page to find them. Sets how top the object is. Higher value means the target is more top of the screen. Code Information Name: setRenderPriority Scope: Global PAC Instruction (Binary): 25 17 18 00 Assembly Address in Memory : 0x8912518 Parameters (int *)handle_id (8 bytes) : Handle to set render priority. (int *)priority (8 bytes) : The render priority value to set to the target. For reference, fever gauge render priority is 10000 (0x2710). Example Here is one example in hex: 25 17 18 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: setRenderPriority((int *)iVar0, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08912518(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { (**(code **)(*(int *)(iVar3 + 0x3c) + 0x14))(iVar3 + 0x20,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreplacetextfromint.html": {
    "href": "setreplacetextfromint.html",
    "title": "setReplaceTextFromInt",
    "keywords": "setReplaceTextFromInt Converts from text to string and stores the result string to the magic words list. Code Information Name: setReplaceTextFromInt Scope: Global PAC Instruction (Binary): 25 0a 45 00 Assembly Address in Memory : 0x894d51c Parameters (int)magicword_index (8 bytes) : The X value from \\<NX>. Usually this is 15 (0xF). (int)value (8 bytes) : The integer value to convert to string. Example Here is one example in hex: 25 0a 45 00 / 02 00 00 00 / 0f 00 00 00 / 08 00 00 00 / c2 00 00 00 Which is interpreted as: setReplaceTextFromInt((int)15, ((global)int *)giVar194) And then, display any message with \\<N15>, and then \\<N15> will be replaced to giVar194 value above. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d51c(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined auStack96 [32]; undefined auStack64 [64]; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((-1 < *piVar1) && (*piVar1 < 0x10)) { Message::Number::Number_To_ByteString(auStack96,0x20,&DAT_08a6167c,*puVar2); Message::Write_Value_Final(auStack64,0x40,auStack96); iVar3 = *piVar1; *(undefined4 *)(iVar3 * 8 + 0x8ab93b8) = 0xffffffff; *(undefined *)(iVar3 * 8 + 0x8ab93bc) = 0; iVar3 = Save::Get_Save_BaseAddr(1); Write_NX_Magicword(*(int *)(iVar3 + 0x50) + 0x2b408,*piVar1,auStack64); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactoradventradius.html": {
    "href": "setreqactoradventradius.html",
    "title": "setReqActorAdventRadius",
    "keywords": "setReqActorAdventRadius Decides the distance of the units in same squad, as reqActor scope. The spreading distance is random. Used for planting grass. See also: setAdventRadius Code Information Name: setReqActorAdventRadius Scope: Mission PAC Instruction (Binary): 25 1f 0f 00 Assembly Address in Memory : 0x8b5cc40 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)max_x_spread (8 bytes) : X position of the \"radius\" to spread. (float)max_y_spread (8 bytes) : Y position of the \"radius\" to spread. Note that PSP screen size is 480 x 272. Example Here is one example in hex: 25 1f 0f 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorAdventRadius(((global)int *)giVar26, (int)0, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5cc40(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8)); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b56b78(*puVar3,*puVar4,iVar5,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorcount.html": {
    "href": "setreqactorcount.html",
    "title": "setReqActorCount",
    "keywords": "setReqActorCount Sets amount of the given unit or gimmick, see also setReqActorParam. Code Information Name: setReqActorCount Scope: Mission PAC Instruction (Binary): 25 1f 0a 00 Assembly Address in Memory : 0x8b5c738 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator to set in thoe whole mission. The ID must be unique in same generator, but can use same ID in different generator. (int)amount (8 bytes) : How many units must be duplicated. Example Here is one example in hex: ```25 1f 09 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 8d 00 00 00``` 25 1f 0a 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 06 00 00 00 Which is interpreted as: setReqActorType(((global)int *)giVar26, (int)0, (int)141) setReqActorCount(((global)int *)giVar26, (int)0, (int)6) This creates generatorparamID 141 unit, and multiplies it to 6. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c738(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56828(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactordelaytime.html": {
    "href": "setreqactordelaytime.html",
    "title": "setReqActorDelayTime",
    "keywords": "setReqActorDelayTime Sets respawn delay time of an actor. First spawn is not affected with this. Code Information Name: setReqActorDelayTime Scope: Mission PAC Instruction (Binary): 25 1f 12 00 Assembly Address in Memory : 0x8b5cf88 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)delay_time (8 bytes) : Delay time between previous spawn and next spawn, as seconds. Example Here is one example in hex: 25 1f 12 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorDelayTime(((global)int *)giVar26, (int)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5cf88(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56cc8(*puVar3,iVar4,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorfixposflag.html": {
    "href": "setreqactorfixposflag.html",
    "title": "setReqActorFixPosFlag",
    "keywords": "setReqActorFixPosFlag Determines if the actor is affected by gravity or not. Code Information Name: setReqActorFixPosFlag Scope: Mission PAC Instruction (Binary): 25 1f 1a 00 Assembly Address in Memory : 0x8b5d178 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (bool)can_float (8 bytes) : 0 makes the actor affected by gravity. For units on the structure, set this to 1. Example Here is one example in hex: 25 1f 1a 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorFixPosFlag(((global)int *)giVar26, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d178(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56df0(iVar4,*puVar2,*piVar3 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorhp.html": {
    "href": "setreqactorhp.html",
    "title": "setReqActorHp",
    "keywords": "setReqActorHp Sets current and maximum stamina of the actor manually. Code Information Name: setReqActorHp Scope: Mission PAC Instruction (Binary): 25 1f 28 00 Assembly Address in Memory : 0x8b5d5f0 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)stamina (8 bytes) : Amount of the stamina. This also becomes maximum stamina. Example Here is one example in hex: 25 1f 28 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setReqActorHp(((global)int *)giVar26, (int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d5f0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57080(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactoritemtable.html": {
    "href": "setreqactoritemtable.html",
    "title": "setReqActorItemTable",
    "keywords": "setReqActorItemTable Sets item drop from the specific actor. Code Information Name: setReqActorItemTable Scope: Mission PAC Instruction (Binary): 25 1f 1f 00 Assembly Address in Memory : 0x8b5d390 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)item_table_id (8 bytes) : ID of the Item table, defined from beginAppearItem Example Here is one example in hex: 25 1f 1f 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: setReqActorItemTable(((global)int *)giVar26, (int)0, (int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d390(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56f70(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorlevel.html": {
    "href": "setreqactorlevel.html",
    "title": "setReqActorLevel",
    "keywords": "setReqActorLevel Defines level of an actor. See also: setLevel Code Information Name: setReqActorLevel Scope: Mission PAC Instruction (Binary): 25 1f 0c 00 Assembly Address in Memory : 0x8b5c938 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)level (8 bytes): Level of the actor. Remarks If the level is not set, it will use the level from setQuestLevel. Example Here is one example in hex: 25 1f 0c 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorLevel(((global)int *)giVar26, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c938(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56a08(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactormovepos.html": {
    "href": "setreqactormovepos.html",
    "title": "setReqActorMovePos",
    "keywords": "setReqActorMovePos Please describe how this does work. This didn't work as expected. Code Information Name: setReqActorMovePos Scope: Mission PAC Instruction (Binary): 25 1f 10 00 Assembly Address in Memory : 0x8b5cd58 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)x (8 bytes) : X position of the unit, as PSP pixels. (float)y (8 bytes) : Y position of the unit, as PSP pixels. Example Here is one example in hex: 25 1f 10 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorMovePos(((global)int *)giVar26, (int)0, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5cd58(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8)); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b56be8(*puVar3,*puVar4,iVar5,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactormoveradius.html": {
    "href": "setreqactormoveradius.html",
    "title": "setReqActorMoveRadius",
    "keywords": "setReqActorMoveRadius Please describe how this does work. Somehow this is used for only fixing position. Code Information Name: setReqActorMoveRadius Scope: Mission PAC Instruction (Binary): 25 1f 11 00 Assembly Address in Memory : 0x8b5ce70 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)x (8 bytes) : X movement radius, as PSP pixels. (float)y (8 bytes) : Y movement radius, as PSP pixels. Example Here is one example in hex: 25 1f 11 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorMoveRadius(((global)int *)giVar26, (int)0, (float)0, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5ce70(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8)); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b56c58(*puVar3,*puVar4,iVar5,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorpos.html": {
    "href": "setreqactorpos.html",
    "title": "setReqActorPos",
    "keywords": "setReqActorPos Defines position of a unit as \"reqActor\". Code Information Name: setReqActorPos Scope: Mission PAC Instruction (Binary): 25 1f 0e 00 Assembly Address in Memory : 0x8b5cb28 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)x (8 bytes) : X position of the unit, as PSP pixels, relative to the generator (float)y (8 bytes) : Y position of the unit, as PSP pixels, relative to the generator Note that PSP screen size is 480 x 272. Unit can be grounded (with gravity) even after y value is set to greater than zero. Example Here is one example in hex: 25 1f 0e 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 7a 43 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorPos(((global)int *)giVar26, (int)0, (float)250, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5cb28(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8), *piVar1); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b56ac8(*puVar3,*puVar4,iVar5,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorrenderprio.html": {
    "href": "setreqactorrenderprio.html",
    "title": "setReqActorRenderPrio",
    "keywords": "setReqActorRenderPrio Sets z-position (render priority) of the actor. The higher the value is, the more the top the actor object is. Code Information Name: setReqActorRenderPrio Scope: Mission PAC Instruction (Binary): 25 1f 1d 00 Assembly Address in Memory : 0x8b5d270 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator to set in thoe whole mission. (int/float *)priority (8 bytes) : The render priority value to set to the target. (bool)bVar2 (8 bytes) : Please describe what this does. Might do something with +10000 render priority in certain condition. Example Here is one example in hex: 25 1f 1d 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setReqActorRenderPrio(((global)int *)giVar26, (int)0, (int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d270(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8)); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b56f00(iVar5,*puVar2,*puVar3,*piVar4 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorscale.html": {
    "href": "setreqactorscale.html",
    "title": "setReqActorScale",
    "keywords": "setReqActorScale Sets the size of the enemy. Code Information Name: setReqActorScale Scope: Mission PAC Instruction (Binary): 25 1f 0d 00 Assembly Address in Memory : 0x8b5ca30 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (float)scale (8 bytes) : Scale multiplier, 1 is normal scale. Example Here is one example in hex: 25 1f 0d 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: setReqActorScale(((global)int *)giVar26, (int)0, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5ca30(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56a68(*puVar3,iVar4,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactortotal.html": {
    "href": "setreqactortotal.html",
    "title": "setReqActorTotal",
    "keywords": "setReqActorTotal Sets spawn limit of the squad in the generator. Without this, spawn spawns unit only once without respawning. Code Information Name: setReqActorTotal Scope: Mission PAC Instruction (Binary): 25 1f 0b 00 Assembly Address in Memory : 0x8b5c830 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)maximum_amount (8 bytes) : Maximum times to be respawned. This does not count first spawn. Example Here is one example in hex: 25 1f 0b 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setReqActorTotal(((global)int *)giVar26, (int)0, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c830(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56888(iVar4,*puVar2,*puVar3); FUN_Mission__08b56940(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactortype.html": {
    "href": "setreqactortype.html",
    "title": "setReqActorType",
    "keywords": "setReqActorType Places PVE enemy or gimmick (anything in generatorparam) to a generator. This does not require resource preloading. Code Information Name: setReqActorType Scope: Mission PAC Instruction (Binary): 25 1f 09 00 Assembly Address in Memory : 0x8b5c640 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. The ID must be unique in same generator, but can use same ID in different generator. (int)generatorparam_id (8 bytes) : generatorparam ID of the unit. Example Here is one example in hex: 25 1f 09 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 8d 00 00 00 Which is interpreted as: setReqActorType(((global)int *)giVar26, (int)0, (int)141) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c640(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); // generatorparam id puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8), *piVar1); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { Mission::Enemy::Set_Enemy_Stat(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactoruniqueid.html": {
    "href": "setreqactoruniqueid.html",
    "title": "setReqActorUniqueId",
    "keywords": "setReqActorUniqueId Sets unique actor ID of the actor for the whole mission scope. Code Information Name: setReqActorUniqueId Scope: Mission PAC Instruction (Binary): 25 1f 18 00 Assembly Address in Memory : 0x8b5d080 Parameters (int *)destination (8 bytes) : Variable to store the Mission-level unique ID. (int)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. Example Here is one example in hex: 25 1f 18 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 64 00 00 00 Which is interpreted as: setReqActorUniqueId(((global)int *)giVar26, (int)0, (int)100) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d080(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b56d90(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setreqactorweapon.html": {
    "href": "setreqactorweapon.html",
    "title": "setReqActorWeapon",
    "keywords": "setReqActorWeapon Overwrites equipment of the actor. The default equipment is defined in generatorparam, and this changes the default equipment from there. Code Information Name: setReqActorWeapon Scope: Mission PAC Instruction (Binary): 25 1f 20 00 Assembly Address in Memory : 0x8b5d488 Parameters (int *)generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator to set in thoe whole mission. (int)slot (8 bytes) : Which equipment slot to replace, like helm, weapon or shield slot etc. (int)equipment_id (8 bytes) : Equpiment ID from weaponparam. (int)visual_level (8 bytes) : Only visual level (1~3) of the equipment. For actual stat, see setLevel. Example Here is one example in hex: 25 1f 20 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 4a 01 00 00 / 08 00 00 00 / 58 00 00 00 Which is interpreted as: setReqActorWeapon(((global)int *)giVar26, (int)2, (int)0, (int)330, ((global)int *)giVar88) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d488(int param_1,undefined4 param_2) { int *piVar1; undefined4 *offset; undefined4 *slot; int *equipment_id_addr; undefined4 *puVar2; int base_addr; undefined4 uVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); offset = (undefined4 *)Pac_Get_Param(param_2,1,1,4); slot = (undefined4 *)Pac_Get_Param(param_2,2,1,4); equipment_id_addr = (int *)Pac_Get_Param(param_2,3,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); base_addr = *(int *)(param_1 + 0x10); if (base_addr == 0) { base_addr = 0; } else if (*piVar1 == -1) { base_addr = 0; } else { if (base_addr == 0) { base_addr = 0; } base_addr = Get_BaseAddr_From_Generator(*(undefined4 *)(base_addr + 0x2c8), *piVar1); if (base_addr == 0) { base_addr = 0; } } if (base_addr != 0) { uVar3 = *puVar2; if (*equipment_id_addr - 0x141U < 7) { uVar3 = 0; } overwrite_equipment(base_addr,*offset,*slot,*equipment_id_addr,uVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setretrogradelimit.html": {
    "href": "setretrogradelimit.html",
    "title": "setRetrogradeLimit",
    "keywords": "setRetrogradeLimit Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setRetrogradeLimit Scope: Global PAC Instruction (Binary): 25 16 2f 01 Assembly Address in Memory : 0x89238f0 Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 16 2f 01 / 08 00 00 00 / 65 00 00 00 / 08 00 00 00 / 64 00 00 00 / 40 00 00 00 / 14 00 00 00 Which is interpreted as: setRetrogradeLimit(((global)int *)giVar101, ((global)int *)giVar100, ((global)float *)gfVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089238f0(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 *puVar3; int iVar4; uint uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = *(int *)(iVar4 + 0xf8); if (iVar4 == 0) { iVar4 = 0; } } if (((iVar4 != 0) && (iVar4 = FUN_088a8650(iVar4,*puVar1), iVar4 != 0)) && (iVar4 + 0x170 != 0)) { uVar5 = *puVar2 & 3; if (((int)*puVar2 < 0) && (uVar5 != 0)) { uVar5 = uVar5 - 4; } *(undefined4 *)(uVar5 * 4 + iVar4 + 0x170 + 0xd0) = *puVar3; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsandlevel.html": {
    "href": "setsandlevel.html",
    "title": "setSandLevel",
    "keywords": "setSandLevel Sets the strength of the sandstorm weather. Code Information Name: setSandLevel Scope: Global PAC Instruction (Binary): 25 16 77 00 Assembly Address in Memory : 0x8920d40 Parameters (float)sandstorm_level (8 bytes) : Sandstorm level to set. 0 is no sandstorm, 1 is strongest sandstorm. Example Here is one example in hex: 25 16 77 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setSandLevel((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920d40(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_088fdd78(*puVar1,iVar2 + 0x250); FUN_088fdd78(*puVar1,iVar2 + 0x210); FUN_08900850(0,iVar2 + 0x1b0,9); FUN_08900850(0,iVar2 + 0x1b0,0xd); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsbossgimmickcheck.html": {
    "href": "setsbossgimmickcheck.html",
    "title": "setSBossGimmickCheck",
    "keywords": "setSBossGimmickCheck Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setSBossGimmickCheck Scope: Global PAC Instruction (Binary): 25 21 31 00 Assembly Address in Memory : 0x89b4074 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b4074(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if ((iVar3 != 0) && (*(int *)(iVar3 + 0x54) == 1)) { FUN_089bfbe8(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsbossmoverangecheck.html": {
    "href": "setsbossmoverangecheck.html",
    "title": "setSBossMoveRangeCheck",
    "keywords": "setSBossMoveRangeCheck Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setSBossMoveRangeCheck Scope: Global PAC Instruction (Binary): 25 21 32 00 Assembly Address in Memory : 0x89b4118 Parameters (undefined4)Var0 (8 bytes) (int)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b4118(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if ((iVar3 != 0) && (*(int *)(iVar3 + 0x54) == 1)) { FUN_089bfbe0(iVar3,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setscale.html": {
    "href": "setscale.html",
    "title": "setScale",
    "keywords": "setScale Sets size of the given object with handle. Somehow it doesn't work with player unit. Code Information Name: setScale Scope: Global PAC Instruction (Binary): 25 17 4b 00 Assembly Address in Memory : 0x8916008 Parameters (int *)handle (8 bytes) : The handle of the unit. (float)scale (8 bytes) : Scale to adjust. (float)Var2 (8 bytes) : unused Example Here is one example in hex: 25 17 4b 00 / 08 00 00 00 / a8 00 00 00 / 20 00 00 00 / 14 00 00 00 / 20 00 00 00 / 14 00 00 00 Which is interpreted as: setScale(((global)int *)giVar168, (float *)fVar20, (float *)fVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08916008(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (iVar3 != 0) { FUN_08880c64(*puVar2,iVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setscoredisptype.html": {
    "href": "setscoredisptype.html",
    "title": "setScoreDispType",
    "keywords": "setScoreDispType Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setScoreDispType Scope: Global PAC Instruction (Binary): 25 16 10 01 Assembly Address in Memory : 0x8929178 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 10 01 / 02 00 00 00 / 02 00 00 00 Which is interpreted as: setScoreDispType((int)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08929178(int param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x58); if (iVar3 != 0) { iVar2 = *piVar1; if (iVar2 == 0) { *(undefined4 *)(iVar3 + 0x404) = 0; } else if (iVar2 == 1) { *(undefined4 *)(iVar3 + 0x404) = 1; } else if (iVar2 == 2) { *(undefined4 *)(iVar3 + 0x404) = 2; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setscriptlabeltable.html": {
    "href": "setscriptlabeltable.html",
    "title": "setScriptLabelTable",
    "keywords": "setScriptLabelTable Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setScriptLabelTable Scope: Global PAC Instruction (Binary): 25 10 02 00 Assembly Address in Memory : 0x8909ea4 Parameters (undefined4)Var0 (4 bytes) Example Here is one example in hex: 25 10 02 00 / 2c 00 00 00 Which is interpreted as: setScriptLabelTable(0x2c) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08909ea4(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,0,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_08909c34(*(int *)(param_1 + 0x10),*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setshopiteminfo.html": {
    "href": "setshopiteminfo.html",
    "title": "setShopItemInfo",
    "keywords": "setShopItemInfo Unimplemented. Code Information Name: setShopItemInfo Scope: Azito PAC Instruction (Binary): 25 1c 29 00 Assembly Address in Memory : 0x8b4ff08 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) (Undefined)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4ff08(undefined4 param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); Pac_Get_Param(param_2,2,1,4); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsnowlevel.html": {
    "href": "setsnowlevel.html",
    "title": "setSnowLevel",
    "keywords": "setSnowLevel Sets the snow amount. This works both in hideout and during mission. Code Information Name: setSnowLevel Scope: Global PAC Instruction (Binary): 25 16 73 00 Assembly Address in Memory : 0x8920af8 Parameters (float)amount (8 bytes) : The amount how much the snow falls, the value is between 0~1. 0 means no snow. Example Here is one example in hex: 25 16 73 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setSnowLevel((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920af8(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { Set_Snow(*puVar1,iVar2 + 0x1d0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsounddisablerhtymhit.html": {
    "href": "setsounddisablerhtymhit.html",
    "title": "setSoundDisableRhtymHit",
    "keywords": "setSoundDisableRhtymHit Enables or disables command cancel before mission. This changes system setting:. Code Information Name: setSoundDisableRhtymHit Scope: Global PAC Instruction (Binary): 25 0a 24 00 Assembly Address in Memory : 0x894b8c8 Parameters (int)disable_commandcancel (8 bytes) : 0 to enable command cancel, 1 to disable command cancel. Example Here is one example in hex: 25 0a 24 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setSoundDisableRhtymHit((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b8c8(undefined4 param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar3 = *piVar1; iVar2 = Save::Get_Save_BaseAddr(1); return__0x1c(*(undefined4 *)(iVar2 + 0x50)); iVar2 = Save::Get_Save_BaseAddr(1); *(bool *)(*(int *)(iVar2 + 0x48) + 0x8ae) = iVar3 == 0; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsoundfixbeat.html": {
    "href": "setsoundfixbeat.html",
    "title": "setSoundFixBeat",
    "keywords": "setSoundFixBeat Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setSoundFixBeat Scope: Global PAC Instruction (Binary): 25 0a 25 00 Assembly Address in Memory : 0x894b93c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0a 25 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setSoundFixBeat((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b93c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar3 = *puVar1; iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = return__0x1c(*(undefined4 *)(iVar2 + 0x50)); *(char *)(iVar2 + 0xedac) = (char)uVar3; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsoundlevelcalaccallback.html": {
    "href": "setsoundlevelcalaccallback.html",
    "title": "setSoundLevelCalacCallback",
    "keywords": "setSoundLevelCalacCallback Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setSoundLevelCalacCallback Scope: Global PAC Instruction (Binary): 25 16 af 00 Assembly Address in Memory : 0x892349c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 16 af 00 / 01 00 00 00 / d0 c8 00 00 Which is interpreted as: setSoundLevelCalacCallback((index)51408) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892349c(undefined4 param_1,undefined4 param_2) { undefined4 uVar1; undefined4 *puVar2; uVar1 = FUN_0883bc1c(param_2); puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); func_0x08b7d950(uVar1,*puVar2); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsquadactivity.html": {
    "href": "setsquadactivity.html",
    "title": "setSquadActivity",
    "keywords": "setSquadActivity Sets squad activity from squadactivityparam to given squad. Code Information Name: setSquadActivity Scope: Global PAC Instruction (Binary): 25 16 23 00 Assembly Address in Memory : 0x891bb98 Parameters (int *)handle_id (8 bytes) : Squad handle, obtained from getUnitSquadHandle. (int)command_action (8 bytes) : expected 0~2. 0 is marching, 1 is defending, 2 is attacking. (short)squadactivityparam_id (8 bytes) : squadactivityparam ID to set. Example Here is one example in hex: 25 16 23 00 / 04 00 00 00 / 35 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 0a 00 00 00 Which is interpreted as: setSquadActivity((int *)iVar53, (int)0, (int)10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891bb98(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; short *psVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); psVar3 = (short *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 3)) && (iVar4 != -0x1f0)) { FUN_08956210(iVar4 + 0x474,*puVar2,(int)*psVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsquadbaseposition.html": {
    "href": "setsquadbaseposition.html",
    "title": "setSquadBasePosition",
    "keywords": "setSquadBasePosition Gets squad base position without additional attack movement. Code Information Name: setSquadBasePosition Scope: Global PAC Instruction (Binary): 25 16 41 00 Assembly Address in Memory : 0x891dc68 Parameters (int *)squad_handle (8 bytes) : The squad handle of the squad to set the position. (float)position (8 bytes) : X Position as PSP Pixel in the world, to set the squad base position. Example Here is one example in hex: 25 16 41 00 / 08 00 00 00 / a8 00 00 00 / 20 00 00 00 / 00 00 00 00 Which is interpreted as: setSquadBasePosition(((global)int *)giVar168, (float *)fVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891dc68(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; int iVar4; uint uVar5; int iVar6; uint *puVar7; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (((-1 < *piVar1) && (iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar1,1), iVar3 != 0) ) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { iVar6 = iVar3 + 0x260; FUN_08955e28(iVar6,0); iVar4 = offset__10(iVar6); local_2c = *(undefined4 *)(iVar4 + 4); local_28 = *(undefined4 *)(iVar4 + 8); local_24 = *(undefined4 *)(iVar4 + 0xc); local_30 = *puVar2; FUN_08955db8(iVar6,&local_30); puVar7 = *(uint **)(iVar3 + 0x5c); if ((puVar7[2] ^ *(uint *)(iVar3 + 0x60) | *puVar7 ^ *(uint *)(iVar3 + 0x58) | puVar7[1] ^ *(uint *)(iVar3 + 0x5c)) != 0) { uVar5 = puVar7[2]; while( true ) { if (uVar5 != 0) { FUN_0890b798(uVar5 + 0x4c0,1); } uVar5 = _DAT_00000004; if (puVar7 != (uint *)0x0) { puVar7 = (uint *)puVar7[1]; uVar5 = puVar7[1]; } if ((puVar7[2] ^ *(uint *)(iVar3 + 0x60) | *puVar7 ^ *(uint *)(iVar3 + 0x58) | uVar5 ^ *(uint *)(iVar3 + 0x5c)) == 0) break; uVar5 = puVar7[2]; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsquaddata.html": {
    "href": "setsquaddata.html",
    "title": "setSquadData",
    "keywords": "setSquadData Enables or disables a squad in the player team. Must be called before the unit setup is started. This affects to the whole save. Code Information Name: setSquadData Scope: Global PAC Instruction (Binary): 25 0a 0f 00 Assembly Address in Memory : 0x894a1bc Parameters (int)unit_type (8 bytes) : 0 hero, 1 ton, 2 chin, 3 kan. (int)unknown (8 bytes) : Keep 0 to make this functional. (bool)is_enabled (8 bytes) : 1 enables the squad, 0 disables the squad. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a1bc(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 *puVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar6 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); iVar5 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x1c(*(undefined4 *)(iVar3 + 0x50)); puVar4 = (undefined4 *)(iVar6 * 0x1620 + iVar3 + 0x9500); if ((puVar4 != (undefined4 *)0x0) && (iVar5 == 0)) { *puVar4 = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsquadrenderpriority.html": {
    "href": "setsquadrenderpriority.html",
    "title": "setSquadRenderPriority",
    "keywords": "setSquadRenderPriority Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setSquadRenderPriority Scope: Global PAC Instruction (Binary): 25 16 3c 00 Assembly Address in Memory : 0x891d664 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 3c 00 / 04 00 00 00 / 03 00 00 00 / 02 00 00 00 / d2 0f 00 00 Which is interpreted as: setSquadRenderPriority((int *)iVar3, (int)4050) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d664(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; uint *puVar5; uint uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) { puVar5 = *(uint **)(iVar3 + 0x5c); if ((puVar5[2] ^ *(uint *)(iVar3 + 0x60) | *puVar5 ^ *(uint *)(iVar3 + 0x58) | puVar5[1] ^ *(uint *)(iVar3 + 0x5c)) != 0) { uVar6 = puVar5[2]; while( true ) { if ((uVar6 != 0) && (iVar4 = (**(code **)(*(int *)(uVar6 + 4) + 0x34))(uVar6), iVar4 == 9)) { (**(code **)(*(int *)(uVar6 + 0x3c) + 0x14))(uVar6 + 0x20,*puVar2); } uVar6 = _DAT_00000004; if (puVar5 != (uint *)0x0) { puVar5 = (uint *)puVar5[1]; uVar6 = puVar5[1]; } if ((puVar5[2] ^ *(uint *)(iVar3 + 0x60) | *puVar5 ^ *(uint *)(iVar3 + 0x58) | uVar6 ^ *(uint *)(iVar3 + 0x5c)) == 0) break; uVar6 = puVar5[2]; } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setstagecursor.html": {
    "href": "setstagecursor.html",
    "title": "setStageCursor",
    "keywords": "setStageCursor Moves world map cursor to the certain mission group (field, dungeon). Code Information Name: setStageCursor Scope: Azito PAC Instruction (Binary): 25 1c 19 00 Assembly Address in Memory : 0x8b4f288 Parameters (int)group_id (8 bytes) : Mission Group ID (specific field/dungeon region) to select. Example Here is one example in hex: 25 1c 19 00 / 08 00 00 00 / 1d 00 00 00 Which is interpreted as: setStageCursor(((global)int *)giVar29) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4f288(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x10) + 0x30) + 0x14), iVar2 != 0)) { FUN_Azito__08b585e0(iVar2,*puVar1); *(undefined *)(iVar2 + 0x2c) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setstageparam.html": {
    "href": "setstageparam.html",
    "title": "setStageParam",
    "keywords": "setStageParam Sets background move sensitivity with the camera move. Code Information Name: setStageParam Scope: Global PAC Instruction (Binary): 25 16 5e 00 Assembly Address in Memory : 0x891ff20 Parameters Warning Not all layers are controllable. There is one layer that has fixed camera sensitivity. (float)sky_sensitivity (8 bytes): Sky move sensitivity for field. (float)backobject_sensitivity (8 bytes): background object move sensitivity. (float)middleobject_sensitivity (8 bytes): 2nd frontmost background (e.g. stone/tree in bg) move sensitivity. (bool)skip_specific_bg (8 bytes) : Skip some types of background, keep 0 to render all. (String)stage_name: Name of stage to set the values. Remarks They are predefined in each mission's PAC instructions like this. Use the existing one with cmd_call for smooth experience. For more information, check the related article. 00006D14 25165E00:setStageParam(0.800000011920929, 0.6000000238418579, 0.4000000059604645, 2:0, \"stg001\") 00006D40 25000100:cmd_end() 00006D44 25165E00:setStageParam(0.8999999761581421, 0.6000000238418579, 0.4000000059604645, 2:0, \"stg008\") 00006D70 25000100:cmd_end() 00006D74 25165E00:setStageParam(1.0, 0.800000011920929, 0.6000000238418579, 2:0, \"stg038\") 00006DA0 25000100:cmd_end() ... Example Here is one example in hex: 25 16 5e 00 / 10 00 00 00 / cd cc 4c 3f / 10 00 00 00 / 9a 99 19 3f / 10 00 00 00 / cd cc cc 3e / 02 00 00 00 / 00 00 00 00 / 73 74 67 30 / 30 31 00 00 Which is interpreted as: setStageParam((float)0.8, (float)0.6, (float)0.4, (int)0, \"stg001\") Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ff20(int param_1,undefined4 param_2) { undefined *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined *puVar5; int iVar6; undefined *puVar7; undefined4 local_184; undefined auStack384 [32]; undefined4 local_160; undefined local_15c; undefined4 local_158 [4]; undefined4 local_148; undefined4 local_144; undefined local_100 [4]; undefined auStack252 [252]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); Pac_Get_Param(param_2,3,1,4); puVar5 = &DAT_00000100; puVar7 = local_100; puVar1 = puVar7; while (puVar1 != (undefined *)0x0) { *puVar7 = 0; puVar7 = puVar7 + 1; puVar5 = puVar5 + -1; puVar1 = puVar5; } Pac_Get_StringParam(param_2,local_100); local_160 = 0; local_184 = 0; local_15c = 0; Syscall::Kernel::Kernel_Memset(local_158,0,0x58); local_158[0] = 0x3e99999a; local_148 = 0x3e4ccccd; local_144 = 0x3dcccccd; Syscall::strcpy(auStack384,local_100); local_158[0] = *puVar2; local_148 = *puVar3; local_144 = *puVar4; iVar6 = Message::Char::Magicword_Number_Parser(auStack252); local_15c = iVar6 < 0x24; FUN_088b0514(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118),&local_184); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setstagepriority.html": {
    "href": "setstagepriority.html",
    "title": "setStagePriority",
    "keywords": "setStagePriority This is not functional. Do not use this. Code Information Name: setStagePriority Scope: Global PAC Instruction (Binary): 25 16 85 00 Assembly Address in Memory : 0x89215a0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (String)Var2 Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089215a0(int param_1,undefined4 param_2) { undefined *puVar1; int *piVar2; undefined4 *puVar3; undefined *puVar4; int iVar5; undefined *puVar6; undefined local_100 [256]; piVar2 = (int *)Pac_Get_Param(param_2,0,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar4 = &DAT_00000100; puVar6 = local_100; puVar1 = puVar6; while (puVar1 != (undefined *)0x0) { *puVar6 = 0; puVar6 = puVar6 + 1; puVar4 = puVar4 + -1; puVar1 = puVar4; } Pac_Get_StringParam(param_2,local_100); if (*(int *)(param_1 + 0x10) != 0) { if (*piVar2 < 0x16) { iVar5 = *(int *)(*piVar2 * 4 + *(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x5640); } else { iVar5 = 0; } if (iVar5 != 0) { (**(code **)(*(int *)(iVar5 + 0x3c) + 0x14))(iVar5 + 0x20,*puVar3); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsuperhero.html": {
    "href": "setsuperhero.html",
    "title": "setSuperHero",
    "keywords": "setSuperHero Apply hero squad action to an unit. This does not change model, and does not affect to actual heromode. This affects unit size and camera zooming during heromode. Code Information Name: setSuperHero Scope: Global PAC Instruction (Binary): 25 16 2f 00 Assembly Address in Memory : 0x891ca1c Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)as_hero (8 bytes) : 0 does not apply hero action, 1 does. Example Here is one example in hex: 25 16 2f 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setSuperHero((int *)iVar54, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ca1c(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) && (iVar4 = *piVar2, FUN_088b9df8(iVar3,iVar4 != 0), iVar4 != 0)) { iVar4 = Save::Get_Save_BaseAddr(1); iVar4 = return__0x1c(*(undefined4 *)(iVar4 + 0x50)); FUN_088b9eb8(iVar3,iVar4 + 0xed80); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setsuperherorebornenable.html": {
    "href": "setsuperherorebornenable.html",
    "title": "setSuperHeroRebornEnable",
    "keywords": "setSuperHeroRebornEnable Enable or disable reborn of specific hero or all heroes. Dungeon disables reborn with this. Code Information Name: setSuperHeroRebornEnable Scope: Global PAC Instruction (Binary): 25 16 54 00 Assembly Address in Memory : 0x891f2ac Parameters (int *)handle_id (8 bytes) : Handle of the squad. -1 applies to every hero unit (not enemy DH unit). Handle ID is required for enemy DH unit. (bool)enable_reborn (8 bytes) : 0 to disable hero reborn, otherwise hero can be reborn after certain time. Example Here is one example in hex: 25 16 54 00 / 02 00 00 00 / ff ff ff ff / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setSuperHeroRebornEnable((int)-1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891f2ac(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; int iVar4; undefined4 uVar5; int iVar6; uint uVar7; undefined4 ***pppuVar8; uint uVar9; undefined4 ****ppppuVar10; undefined4 **ppuVar11; int *local_1a4; int *local_1a0; undefined *local_19c; undefined auStack408 [388]; undefined *local_14; undefined4 ****local_10; undefined4 ****local_c; int **local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 < 0) { iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = *(int *)(iVar3 + 0xf8); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { iVar4 = 0; do { uVar5 = FUN_088a8650(iVar3,iVar4); local_19c = &DAT_08a840a0; local_14 = auStack408; piVar1 = (int *)(*(code *)PTR_FUN_08a840a8)(&local_1a4); local_1a4 = piVar1; iVar6 = (**(code **)(local_19c + 0xc))(&local_1a4); local_1a0 = piVar1 + (iVar6 + -1) * 3; piVar1[1] = (int)&local_1a4; *local_1a0 = (int)&local_1a4; uVar9 = 1; uVar7 = (**(code **)(local_19c + 0xc))(&local_1a4); if (1 < uVar7) { do { *piVar1 = (int)(piVar1 + 3); piVar1[4] = (int)piVar1; uVar9 = uVar9 + 1; uVar7 = (**(code **)(local_19c + 0xc))(&local_1a4); piVar1 = piVar1 + 3; } while (uVar9 < uVar7); } local_8 = &local_1a4; local_4 = 0; local_10 = &local_10; local_c = local_10; FUN_088dfd3c(uVar5,0xffffffff,&local_1a4); if ((undefined4 *****)local_10 != &local_10) { pppuVar8 = local_10[2]; ppppuVar10 = local_10; while( true ) { ppuVar11 = pppuVar8[0x285]; iVar6 = Character::Get_Unit_Type(ppuVar11); if (iVar6 == 2) { ppppuVar10 = (undefined4 ****)*ppppuVar10; } else { if (*piVar2 == 0) { FUN_088c54d8(ppuVar11,0); } else { FUN_088c54d8(ppuVar11,1); } ppppuVar10 = (undefined4 ****)*ppppuVar10; } if ((undefined4 *****)ppppuVar10 == &local_10) break; pppuVar8 = ppppuVar10[2]; } } FUN_088de56c(&local_10,0); FUN_088de508(&local_1a4,0); iVar4 = iVar4 + 1; } while (iVar4 < 2); } PAC::PAC_setCmdId(param_2,0); } else { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar1,1); if (((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 3)) && (iVar3 != 0)) { if (*piVar2 == 0) { FUN_088c54d8(iVar3,0); } else { FUN_088c54d8(iVar3,1); } } PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "setsyncvalue.html": {
    "href": "setsyncvalue.html",
    "title": "setSyncValue",
    "keywords": "setSyncValue Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setSyncValue Scope: Global PAC Instruction (Binary): 25 21 1c 00 Assembly Address in Memory : 0x89b32f0 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b32f0(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar4 != 0) { FUN_08977ca4(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setthunderlevel.html": {
    "href": "setthunderlevel.html",
    "title": "setThunderLevel",
    "keywords": "setThunderLevel Sets the thunder frequency. This works both in hideout and during mission. With maximum thunder frequency, thunder hits around once per 6 seconds (1.5 command measurement). Code Information Name: setThunderLevel Scope: Global PAC Instruction (Binary): 25 16 75 00 Assembly Address in Memory : 0x8920c10 Parameters (float *)destination (8 bytes) : Variable to store how frequent the thunder occurs, the value is between 0~1. 0 means no thunder. Example Here is one example in hex: 25 16 75 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setThunderLevel((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920c10(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_088fdd8c(*puVar1,iVar2 + 0x1d0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimerenablesetype.html": {
    "href": "settimerenablesetype.html",
    "title": "setTimerEnableSeType",
    "keywords": "setTimerEnableSeType Sets timer countdown sound during countdown. Related guide: How To: Add A Timer Code Information Name: setTimerEnableSeType Scope: Global PAC Instruction (Binary): 25 16 0f 01 Assembly Address in Memory : 0x89290f4 Parameters (bool)enable_sound (8 bytes) : Does not activate sound if this is zero. Example Here is one example in hex: 25 16 0f 01 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setTimerEnableSeType((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089290f4(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 100), iVar2 != 0)) { *(undefined4 *)(iVar2 + 0x208) = *puVar1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimerpause.html": {
    "href": "settimerpause.html",
    "title": "setTimerPause",
    "keywords": "setTimerPause Pauses or resumes the timer. Code Information Name: setTimerPause Scope: Global PAC Instruction (Binary): 25 16 a2 00 Assembly Address in Memory : 0x8922910 Parameters (bool)is_pause (8 bytes) : 0 resumes the timer, 1 pauses the timer. (bool)display (8 bytes) : 0 hides the timer, 1 still displays the timer. Example Here is one example in hex: 25 16 a2 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setTimerPause((int)1, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922910(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x2c), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 100), iVar3 != 0)) { *(bool *)(iVar3 + 0x1f2) = *piVar1 != 0; *(bool *)(iVar3 + 499) = *piVar2 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimerpos.html": {
    "href": "settimerpos.html",
    "title": "setTimerPos",
    "keywords": "setTimerPos Sets the position of the timer as PSP screen pixels. The timer pivot is on the middle, so it will be center position. Related guide: How To: Add A Timer Code Information Name: setTimerPos Scope: Global PAC Instruction (Binary): 25 16 9f 00 Assembly Address in Memory : 0x8922734 Parameters (float)position_x (8 bytes) : X position to put the timer, as PSP screen pixels on screen. (float)position_y (8 bytes) : Y position to put the timer, as PSP screen pixels on screen. Note that PSP screen size is 480 x 272 and the pivot is on the middle. For example, \"240 x 136\" will put the timer in the middle of the screen. Example Here is one example in hex: 25 16 9f 00 / 10 00 00 00 / 00 00 70 43 / 10 00 00 00 / 00 00 c0 41 Which is interpreted as: setTimerPos((float)240, (float)24) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08922734(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x2c), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 100), iVar3 != 0)) { local_4 = *puVar2; local_8 = *puVar1; FUN_Mission__08b32ec8(iVar3,&local_8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimersize.html": {
    "href": "settimersize.html",
    "title": "setTimerSize",
    "keywords": "setTimerSize Sets the size of the timer. The timer pivot is on the middle, so scales from center. Related guide: How To: Add A Timer Code Information Name: setTimerSize Scope: Global PAC Instruction (Binary): 25 16 a0 00 Assembly Address in Memory : 0x89227e8 Parameters (float)size (8 bytes) : Size of the font as PSP screen pixels. Set as desired height, and width will be scaled accordingly. Note there is still small margin. Example Here is one example in hex: 25 16 a0 00 / 10 00 00 00 / 00 00 00 42 Which is interpreted as: setTimerSize((float)32) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089227e8(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 0x2c), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 100), iVar2 != 0)) { local_8 = *puVar1; local_4 = local_8; func_0x08b32ee0(iVar2,&local_8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimmingscript_250a1a00.html": {
    "href": "settimmingscript_250a1a00.html",
    "title": "setTimmingScript (250a1a00)",
    "keywords": "setTimmingScript (250a1a00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setTimmingScript Scope: Global PAC Instruction (Binary): 25 0a 1a 00 Assembly Address in Memory : 0x894b030 Parameters (uint)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (8 bytes) Example Here is one example in hex: 25 0a 1a 00 / 02 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / e0 00 00 00 Which is interpreted as: setTimmingScript((int)1, (int *)iVar0, (index)224) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894b030(int param_1,undefined4 param_2) { uint *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; undefined4 *puVar5; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (*(int *)(param_1 + 0x10) != 0) { if (*puVar1 < 2) { puVar5 = (undefined4 *)(*(int *)(param_1 + 0x10) + 0x378 + *puVar1 * 8); } else { puVar5 = (undefined4 *)0x0; } uVar4 = *puVar3; *puVar5 = *puVar2; puVar5[1] = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimmingscript_251c0400.html": {
    "href": "settimmingscript_251c0400.html",
    "title": "setTimmingScript (251c0400)",
    "keywords": "setTimmingScript (251c0400) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setTimmingScript Scope: Azito PAC Instruction (Binary): 25 1c 04 00 Assembly Address in Memory : 0x8b4d3a0 Parameters (uint)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (8 bytes) Example Here is one example in hex: 25 1c 04 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 70 03 00 00 Which is interpreted as: setTimmingScript((int)0, (int *)iVar0, (index)880) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4d3a0(int param_1,undefined4 param_2) { uint *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; undefined4 *puVar5; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (*(int *)(param_1 + 0x10) != 0) { if (*puVar1 < 0xf) { puVar5 = (undefined4 *)(*(int *)(param_1 + 0x10) + 0x94 + *puVar1 * 8); } else { puVar5 = (undefined4 *)0x0; } uVar4 = *puVar3; *puVar5 = *puVar2; puVar5[1] = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settimmingscript_int.html": {
    "href": "settimmingscript_int.html",
    "title": "setTimmingScript_Int",
    "keywords": "setTimmingScript_Int Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setTimmingScript_Int Scope: Global PAC Instruction (Binary): 25 17 34 00 Assembly Address in Memory : 0x89143bc Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (4 bytes) Example Here is one example in hex: 25 17 34 00 / 04 00 00 00 / 01 00 00 00 / 04 00 00 00 / 00 00 00 00 / 78 ef 01 00 Which is interpreted as: setTimmingScript_Int((int *)iVar1, (int *)iVar0, 0x1ef78) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089143bc(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); if (*piVar1 != -1) { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 != 0) { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); local_4 = *puVar3; local_8 = *puVar2; (**(code **)(*(int *)(iVar4 + 4) + 0xbc))(iVar4,&local_8); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settipsimageid.html": {
    "href": "settipsimageid.html",
    "title": "setTipsImageId",
    "keywords": "setTipsImageId Sets ID of the tip to display. Code Information Name: setTipsImageId Scope: Global PAC Instruction (Binary): 25 0a 28 00 Assembly Address in Memory : 0x894ba90 Parameters (int)tip_internal_id (8 bytes) : The Tip ID. Note this is not in tip album order. -2 for random tips. Example Here is one example in hex: 25 0a 28 00 / 04 00 00 00 / 14 00 00 00 Which is interpreted as: setTipsImageId((int *)iVar20) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894ba90(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); *(undefined4 *)(*(int *)(iVar2 + 0x58) + 0x28) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settipsselectmask.html": {
    "href": "settipsselectmask.html",
    "title": "setTipsSelectMask",
    "keywords": "setTipsSelectMask Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setTipsSelectMask Scope: Global PAC Instruction (Binary): 25 0a 2e 00 Assembly Address in Memory : 0x894bda8 Parameters (uint)Var0 (8 bytes) (int)Var1 (8 bytes) Example Here is one example in hex: 25 0a 2e 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setTipsSelectMask((int)0, (int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bda8(undefined4 param_1,undefined4 param_2) { uint *puVar1; int *piVar2; int iVar3; int iVar4; uint uVar5; uint uVar6; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Save::Get_Save_BaseAddr(1); iVar4 = *piVar2; uVar5 = *puVar1 >> 5; if (uVar5 < 4) { uVar6 = *puVar1 & 0x1f; puVar1 = (uint *)(*(int *)(iVar3 + 0x58) + 0x14 + uVar5 * 4); uVar5 = *puVar1 & ~(1 << uVar6); *puVar1 = uVar5; *puVar1 = uVar5 | (uint)(iVar4 != 0) << uVar6; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settipsselectmaskmulti.html": {
    "href": "settipsselectmaskmulti.html",
    "title": "setTipsSelectMaskMulti",
    "keywords": "setTipsSelectMaskMulti Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setTipsSelectMaskMulti Scope: Global PAC Instruction (Binary): 25 0a 2f 00 Assembly Address in Memory : 0x894be70 Parameters (int)Var0 (8 bytes) (int)Var1 (4 bytes) (uint...)Vars2 (>= 4 bytes) ... means any amounts of parameter. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894be70(undefined4 param_1,undefined4 param_2) { int *piVar1; int *piVar2; int iVar3; uint *puVar4; int iVar5; uint uVar6; uint uVar7; int iVar8; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,0,1); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = *(int *)(iVar3 + 0x58); iVar8 = 0; if (0 < *piVar2) { do { puVar4 = (uint *)Pac_Get_Param(param_2,2,0,4); uVar7 = *puVar4; if ((int)uVar7 < 0) { iVar5 = *piVar2; } else { iVar5 = *piVar1; if (uVar7 >> 5 < 4) { puVar4 = (uint *)(iVar3 + 0x14 + (uVar7 >> 5) * 4); uVar6 = *puVar4 & ~(1 << (uVar7 & 0x1f)); *puVar4 = uVar6; *puVar4 = uVar6 | (uint)(iVar5 != 0) << (uVar7 & 0x1f); } iVar5 = *piVar2; } iVar8 = iVar8 + 1; } while (iVar8 < iVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settitletimmingscript.html": {
    "href": "settitletimmingscript.html",
    "title": "setTitleTimmingScript",
    "keywords": "setTitleTimmingScript Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setTitleTimmingScript Scope: Title PAC Instruction (Binary): 25 13 02 00 Assembly Address in Memory : 0x8ac0b20 Parameters (uint)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (8 bytes) Example Here is one example in hex: 25 13 02 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 / 01 00 00 00 / 64 00 00 00 Which is interpreted as: setTitleTimmingScript((int)0, (int *)iVar0, (index)100) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Title__08ac0b20(int param_1,undefined4 param_2) { uint *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 uVar4; int iVar5; undefined4 *puVar6; int iVar7; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar7 = *(int *)(param_1 + 0x10); iVar5 = iVar7; if (iVar7 == 0) { iVar5 = 0; } if (iVar5 != 0) { if (iVar7 == 0) { iVar7 = 0x47bc; } else { iVar7 = iVar7 + 0x47bc; } if (*puVar1 < 4) { puVar6 = (undefined4 *)(iVar7 + *puVar1 * 8); } else { puVar6 = (undefined4 *)0x0; } uVar4 = *puVar3; *puVar6 = *puVar2; puVar6[1] = uVar4; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "settrooptype.html": {
    "href": "settrooptype.html",
    "title": "setTroopType",
    "keywords": "setTroopType Sets the troop type for the interaction. Code Information Name: setTroopType Scope: Mission PAC Instruction (Binary): 25 1f 19 00 Assembly Address in Memory : 0x8b5c478 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)troop_type (8 bytes) : The troop type to set. Example Here is one example in hex: 25 1f 19 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 04 00 00 00 Which is interpreted as: setTroopType(((global)int *)giVar26, (int)4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5c478(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else if (*piVar1 == -1) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar3 + 0x2c8)); if (iVar3 == 0) { iVar3 = 0; } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x2c) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlactivity_2516d700.html": {
    "href": "setunitctrlactivity_2516d700.html",
    "title": "setUnitCtrlActivity (2516d700)",
    "keywords": "setUnitCtrlActivity (2516d700) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUnitCtrlActivity Scope: Global PAC Instruction (Binary): 25 16 d7 00 Assembly Address in Memory : 0x8926100 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926100(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; int iVar3; undefined4 uVar4; undefined4 uVar5; undefined4 uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar6 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar5 = *puVar1; iVar2 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),uVar4,1); if ((iVar2 != 0) && (iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2), iVar3 == 3)) { FUN_08956210(iVar2 + 0x474,uVar6,(int)(short)uVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlactivity_251f1c00.html": {
    "href": "setunitctrlactivity_251f1c00.html",
    "title": "setUnitCtrlActivity (251f1c00)",
    "keywords": "setUnitCtrlActivity (251f1c00) Other functions have the same name. Check the Disambiguation page to find them. Sets squad action to a unit. This defines animation only. Unit attack works with actual action type. Code Information Name: setUnitCtrlActivity Scope: Mission PAC Instruction (Binary): 25 1f 1c 00 Assembly Address in Memory : 0x8b5dc78 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)command_id (8 bytes) : Command ID of it, but range of 0~2 (march, defend, attack) or nothing (-1). (int)sqaudactivity_id (8 bytes) : ID from squadActivityParam. Warning The AI dark heroes squadactivityparam ID is different from player dark heroes. Check SquadActivityParam ID table to assign the proper ID. Example Here is one example in hex: 25 1f 1c 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / d4 05 00 00 Which is interpreted as: setUnitCtrlActivity(((global)int *)giVar26, (int)2, (int)0, (int)1492) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5dc78(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8), *piVar1); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b57328(iVar5,*puVar2,*puVar3,*puVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrladventposx.html": {
    "href": "setunitctrladventposx.html",
    "title": "setUnitCtrlAdventPosX",
    "keywords": "setUnitCtrlAdventPosX Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUnitCtrlAdventPosX Scope: Mission PAC Instruction (Binary): 25 1f 2a 00 Assembly Address in Memory : 0x8b5e5b0 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 1f 2a 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / 03 00 00 00 / 10 00 00 00 / 00 00 fa 44 Which is interpreted as: setUnitCtrlAdventPosX((int *)iVar0, (int)3, (float)2000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e5b0(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (-1 < *piVar1) { iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57168(*puVar3,iVar4,*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlattackmoveaddparam.html": {
    "href": "setunitctrlattackmoveaddparam.html",
    "title": "setUnitCtrlAttackMoveAddParam",
    "keywords": "setUnitCtrlAttackMoveAddParam Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUnitCtrlAttackMoveAddParam Scope: Mission PAC Instruction (Binary): 25 1f 22 00 Assembly Address in Memory : 0x8b5e078 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 1f 22 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 05 00 00 00 Which is interpreted as: setUnitCtrlAttackMoveAddParam(((global)int *)giVar26, (int)2, (int)5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e078(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b576c8(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlcurrentacttype_2516d800.html": {
    "href": "setunitctrlcurrentacttype_2516d800.html",
    "title": "setUnitCtrlCurrentActType (2516d800)",
    "keywords": "setUnitCtrlCurrentActType (2516d800) Other functions have the same name. Check the Disambiguation page to find them. Sets what the unit is currently doing by Squad Handle. Code Information Name: setUnitCtrlCurrentActType Scope: Global PAC Instruction (Binary): 25 16 d8 00 Assembly Address in Memory : 0x89261dc Parameters (int *)handle_id (8 bytes) : Squad handle, obtained from e.g. getUnitSquadHandle. (int)command_id (8 bytes) : Command ID to perform now. The action is limited to march/defend/attack or nothing (-1). Example Here is one example in hex: 25 16 d8 00 / 08 00 00 00 / a8 00 00 00 / 04 00 00 00 / 02 00 00 00 Which is interpreted as: setUnitCtrlCurrentActType(((global)int *)giVar168, (int *)iVar2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089261dc(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; int iVar3; undefined4 uVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar5 = *puVar1; iVar2 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),uVar4,1); if ((iVar2 != 0) && (iVar3 = (**(code **)(*(int *)(iVar2 + 4) + 0x34))(iVar2), iVar3 == 3)) { FUN_089562cc(iVar2 + 0x474,uVar5); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlcurrentacttype_251f2700.html": {
    "href": "setunitctrlcurrentacttype_251f2700.html",
    "title": "setUnitCtrlCurrentActType (251f2700)",
    "keywords": "setUnitCtrlCurrentActType (251f2700) Other functions have the same name. Check the Disambiguation page to find them. Sets what the unit is currently doing by given Generator and ID in the generator. Code Information Name: setUnitCtrlCurrentActType Scope: Mission PAC Instruction (Binary): 25 1f 27 00 Assembly Address in Memory : 0x8b5df80 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)command_id (8 bytes) : Command ID to perform now. The action is limited to march/defend/attack or nothing (-1). Example Here is one example in hex: 25 1f 27 00 / 04 00 00 00 / 2b 00 00 00 / 04 00 00 00 / 2a 00 00 00 / 04 00 00 00 / 30 00 00 00 Which is interpreted as: setUnitCtrlCurrentActType((int *)iVar43, (int *)iVar42, (int *)iVar48) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5df80(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8), *piVar1); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57578(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlenable.html": {
    "href": "setunitctrlenable.html",
    "title": "setUnitCtrlEnable",
    "keywords": "setUnitCtrlEnable Enables or disables controlling the unit. Code Information Name: setUnitCtrlEnable Scope: Global PAC Instruction (Binary): 25 16 3e 00 Assembly Address in Memory : 0x891d928 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (bool)can_control (8 bytes) : 0 is disabling the control, and other values enables controlling the unit. Example Here is one example in hex: 25 16 3e 00 / 04 00 00 00 / 36 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setUnitCtrlEnable((int *)iVar54, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891d928(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { FUN_088f5148(iVar3 + 0x170,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlgimmick.html": {
    "href": "setunitctrlgimmick.html",
    "title": "setUnitCtrlGimmick",
    "keywords": "setUnitCtrlGimmick Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUnitCtrlGimmick Scope: Mission PAC Instruction (Binary): 25 1f 24 00 Assembly Address in Memory : 0x8b5e268 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 1f 24 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 83 00 00 00 Which is interpreted as: setUnitCtrlGimmick(((global)int *)giVar26, (int)0, (int)131) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e268(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Pool(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57828(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlmode.html": {
    "href": "setunitctrlmode.html",
    "title": "setUnitCtrlMode",
    "keywords": "setUnitCtrlMode Decides controlling type. Code Information Name: setUnitCtrlMode Scope: Mission PAC Instruction (Binary): 25 1f 17 00 Assembly Address in Memory : 0x8b5db80 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)mode_id (8 bytes) : Expected 0~7. Other values crash. mode_id Spawned from far away March (or initial acttype) Auto Attack 0 Yes Yes Yes 1, 3, 5 Yes No Yes 2 Yes No Yes 4 Yes No No 6 Yes Yes If in watchArea 7 No No Yes Example Here is one example in hex: 25 1f 17 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 06 00 00 00 Which is interpreted as: setUnitCtrlMode(((global)int *)giVar26, (int)0, (int)6) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5db80(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); //used in 0896C330 iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b571f0(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlmoveenable.html": {
    "href": "setunitctrlmoveenable.html",
    "title": "setUnitCtrlMoveEnable",
    "keywords": "setUnitCtrlMoveEnable Enables or disables moving (marching, position adjusting before attacking). Doesn't block movement from attack itself (e.g. ragewolf going back during heromode). Code Information Name: setUnitCtrlMoveEnable Scope: Global PAC Instruction (Binary): 25 16 f5 00 Assembly Address in Memory : 0x8927028 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (bool)enable_move (8 bytes) : 0 makes unit immovable, 1 allows the unit to move. Example Here is one example in hex: 25 16 f5 00 / 04 00 00 00 / 2d 00 00 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setUnitCtrlMoveEnable((int *)iVar45, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927028(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { FUN_088f51c4(iVar3 + 0x170,*piVar2 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlrangeracttype.html": {
    "href": "setunitctrlrangeracttype.html",
    "title": "setUnitCtrlRangerActType",
    "keywords": "setUnitCtrlRangerActType Sets automatic enemy unit action when the unit sees a target. This is used for PVE bonedeths. Code Information Name: setUnitCtrlRangerActType Scope: Mission PAC Instruction (Binary): 25 1f 21 00 Assembly Address in Memory : 0x8b5de88 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)command_id (8 bytes) : Command ID to perform after being spawned. The action is limited to march/defend/attack or nothing (-1). Example Here is one example in hex: 25 1f 21 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 Which is interpreted as: setUnitCtrlRangerActType(((global)int *)giVar26, (int)2, (int)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5de88(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57510(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlskill.html": {
    "href": "setunitctrlskill.html",
    "title": "setUnitCtrlSkill",
    "keywords": "setUnitCtrlSkill Adds a set skill or class skill to a reqActor PVE unit. Note this does not automatically load the skill effect and the skill effect must be loaded manually. Code Information Name: setUnitCtrlSkill Scope: Mission PAC Instruction (Binary): 25 1f 31 00 Assembly Address in Memory : 0x8b5ed18 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)skill_id (8 bytes) : ID of the class skill or set skill to give to the unit. Example Here is one example in hex: 25 1f 31 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 04 00 00 00 / 02 00 00 00 / bc 00 00 00 Which is interpreted as: setUnitCtrlSkill(((global)int *)giVar26, (int)4, (int)188) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5ed18(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57948(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlspring.html": {
    "href": "setunitctrlspring.html",
    "title": "setUnitCtrlSpring",
    "keywords": "setUnitCtrlSpring Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUnitCtrlSpring Scope: Mission PAC Instruction (Binary): 25 1f 2d 00 Assembly Address in Memory : 0x8b5e8c8 Parameters (int)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (int)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e8c8(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int *piVar3; undefined4 *puVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else if (*piVar1 == -1) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar5 + 0x2c8)); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { FUN_Mission__08b578d0(*puVar4,iVar5,*puVar2,*piVar3 != 0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlstartacttype.html": {
    "href": "setunitctrlstartacttype.html",
    "title": "setUnitCtrlStartActType",
    "keywords": "setUnitCtrlStartActType Sets first action of an unit after being spawned. Code Information Name: setUnitCtrlStartActType Scope: Mission PAC Instruction (Binary): 25 1f 23 00 Assembly Address in Memory : 0x8b5dd90 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)command_id (8 bytes) : Command ID to perform after being spawned. The action is limited to march/defend/attack or nothing (-1). Example Here is one example in hex: 25 1f 23 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 Which is interpreted as: setUnitCtrlStartActType(((global)int *)giVar26, (int)2, (int)2) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5dd90(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b574a8(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrltimingscript_int.html": {
    "href": "setunitctrltimingscript_int.html",
    "title": "setUnitCtrlTimingScript_Int",
    "keywords": "setUnitCtrlTimingScript_Int Calls a script when an unit is in certain condition (e.g. enemy on sight or being killed). If things must be happened after object is completely deleted, use setDeathCall. The address tends to start with getEthnicID and compare the values. Used for small enemy units' bubble speech (bo-bo-bone, karmen great pataponponpon etc.). Code Information Name: setUnitCtrlTimingScript_Int Scope: Mission PAC Instruction (Binary): 25 1f 26 00 Assembly Address in Memory : 0x8b5e360 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (MemoryAddress)pac_address (8 bytes) : Memory address that contains start of the PAC, obtained from getPack. (Address)address (8 bytes): Address to call when the unit is dead. Example Here is one example in hex: 25 1f 26 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 08 00 00 00 / 5b 00 00 00 / 01 00 00 00 / 0c f6 01 00 Which is interpreted as: setUnitCtrlTimingScript_Int(((global)int *)giVar26, (int)0, ((global)int *)giVar91, (index)0x1f60c) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e360(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; int iVar6; undefined4 uVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); iVar6 = *(int *)(param_1 + 0x10); if (iVar6 == 0) { iVar6 = 0; } else if (*piVar1 == -1) { iVar6 = 0; } else { if (iVar6 == 0) { iVar6 = 0; } iVar6 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar6 + 0x2c8)); if (iVar6 == 0) { iVar6 = 0; } } if (iVar6 != 0) { iVar5 = FUN_Mission__08b59d98(iVar6,*piVar2); if (iVar5 == 1) { iVar5 = *piVar2; } else { if ((iVar5 != 5) && (iVar5 != 2)) goto LAB_Mission__08b5e488; iVar5 = *piVar2; } uVar7 = *puVar4; iVar6 = iVar6 + iVar5 * 8; *(undefined4 *)(iVar6 + 0x688) = *puVar3; *(undefined4 *)(iVar6 + 0x68c) = uVar7; } LAB_Mission__08b5e488: PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitctrlwatcharea.html": {
    "href": "setunitctrlwatcharea.html",
    "title": "setUnitCtrlWatchArea",
    "keywords": "setUnitCtrlWatchArea Defines march up distance from the player position after being spawned. The player position during enemy spawn decides their marching position. This sets distance from the player position. Code Information Name: setUnitCtrlWatchArea Scope: Mission PAC Instruction (Binary): 25 1f 1e 00 Assembly Address in Memory : 0x8b5e170 Parameters (int* )generator_handle (8 bytes) : Handle of the generator, obtained from create or getHandle. (int)in_generator_id (8 bytes) : ID in the generator. (int)distance (8 bytes) : Distance to march, offset from the player position. Example Here is one example in hex: 25 1f 1e 00 / 08 00 00 00 / 1a 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 19 00 00 00 Which is interpreted as: setUnitCtrlWatchArea(((global)int *)giVar26, (int)0, (int)25) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5e170(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = *(int *)(param_1 + 0x10); if (iVar4 == 0) { iVar4 = 0; } else if (*piVar1 == -1) { iVar4 = 0; } else { if (iVar4 == 0) { iVar4 = 0; } iVar4 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar4 + 0x2c8)); if (iVar4 == 0) { iVar4 = 0; } } if (iVar4 != 0) { FUN_Mission__08b57730(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitdata.html": {
    "href": "setunitdata.html",
    "title": "setUnitData",
    "keywords": "setUnitData Enables or disables a unit in the player team. Must be called before the unit setup is started. This affects to the whole save. Works only when the squad of the unit is active. If the unit is disabled with this, the unit is still unlocked, but disappears. Code Information Name: setUnitData Scope: Global PAC Instruction (Binary): 25 0a 11 00 Assembly Address in Memory : 0x894a468 Parameters (int)unit_type (8 bytes) : 0 hero, 1 ton, 2 chin, 3 kan. (int)unknown (8 bytes) : Keep 0 to make this functional. (int)class_id (8 bytes) : ID of the class to enable/disable. (int)unknown (8 bytes) : Keep 0 to make this functional. (bool)is_enabled (8 bytes) : 1 enables the unit, 0 disables the unit. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894a468(undefined4 param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; undefined4 *puVar4; int iVar5; int iVar6; int iVar7; int iVar8; int iVar9; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar9 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,1,1,4); iVar8 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,2,1,4); iVar7 = *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,3,1,4); iVar6 = *piVar1; puVar2 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x1c(*(undefined4 *)(iVar3 + 0x50)); iVar5 = 0; iVar3 = iVar9 * 0x1620 + iVar3 + 0x9500; puVar4 = (undefined4 *)0x0; if (iVar3 != 0) { iVar5 = iVar3 + iVar8 * 0x84 + 0x14; } if (iVar5 != 0) { puVar4 = (undefined4 *)(iVar5 + iVar7 * 0x34 + 0x18); } if ((puVar4 != (undefined4 *)0x0) && (iVar6 == 0)) { *puVar4 = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitdeadmotion.html": {
    "href": "setunitdeadmotion.html",
    "title": "setUnitDeadMotion",
    "keywords": "setUnitDeadMotion Sets the motion when an unit is dead. Works only with an unit. Code Information Name: setUnitDeadMotion Scope: Global PAC Instruction (Binary): 25 16 da 00 Assembly Address in Memory : 0x8926384 Parameters (int *)unit_handle (8 bytes) : Handle of the unit to set the motion when being dead. (int)action_id (8 bytes) : ID of the action for the unit to perform when the unit is dead. Example Here is one example in hex: 25 16 da 00 / 04 00 00 00 / 15 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setUnitDeadMotion((int *)iVar21, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926384(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { FUN_088b8dcc(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setunitmotionindex.html": {
    "href": "setunitmotionindex.html",
    "title": "setUnitMotionIndex",
    "keywords": "setUnitMotionIndex Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUnitMotionIndex Scope: Global PAC Instruction (Binary): 25 16 27 00 Assembly Address in Memory : 0x891bea8 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 27 00 / 04 00 00 00 / 04 00 00 00 Which is interpreted as: setUnitMotionIndex((int *)iVar4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891bea8(int param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; int iVar4; int iVar5; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); uVar2 = FUN_088a8650(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xf8),0); uVar2 = FUN_088df588(uVar2,0); iVar3 = FUN_088c5348(uVar2,0); if ((((iVar3 != 0) && (iVar3 = *(int *)(iVar3 + 200), iVar3 != 0)) && (iVar5 = *piVar1, -1 < iVar5)) && (iVar4 = FUN_0888ead0(iVar3), iVar5 < iVar4)) { FUN_0888eaa8(iVar3,*piVar1,1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setupadddungeonwall.html": {
    "href": "setupadddungeonwall.html",
    "title": "setupAddDungeonWall",
    "keywords": "setupAddDungeonWall Add Dungeon wall or dungeon related gimmick (environment cellings etc). Code Information Name: setupAddDungeonWall Scope: Global PAC Instruction (Binary): 25 16 66 00 Assembly Address in Memory : 0x89204a4 Parameters (int)gimmick_type (8 bytes) : See below. (int)bind_identifier (8 bytes) : Any unique identifier, this can be used for setting up setGateInfo. If the gimmick has no function, set to -1. gimmick_type gimmick 0x1~0x4 celling (higher value = lower celling) 0x14 breakable door 0x15 door that requires key 0x17 iron door (opens from up to down) 0x18 iron door (opens from down to up) 0x1f ??? 0x20 back of the dungeon (stones) Remarks This adds gimmicks only and does not do any interaction. For interaction, see setGateInfo. Example Here is one example in hex: 25 16 66 00 / 02 00 00 00 / 15 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setupAddDungeonWall((int)21, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089204a4(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { FUN_08972658(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x4320,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setupdatedefaultcamera.html": {
    "href": "setupdatedefaultcamera.html",
    "title": "setUpdateDefaultCamera",
    "keywords": "setUpdateDefaultCamera Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUpdateDefaultCamera Scope: Global PAC Instruction (Binary): 25 16 01 01 Assembly Address in Memory : 0x8928158 Parameters (int)Var0 (8 bytes) Example Here is one example in hex: 25 16 01 01 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: setUpdateDefaultCamera((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08928158(int param_1,undefined4 param_2) { int *piVar1; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); if (*(int *)(param_1 + 0x10) != 0) { *(bool *)(*(int *)(*(int *)(param_1 + 0x10) + 0xd8) + 0x25e8) = *piVar1 != 0; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setupdungeoncomment.html": {
    "href": "setupdungeoncomment.html",
    "title": "setupDungeonComment",
    "keywords": "setupDungeonComment Sets dungeon info in floor decision dialog (when finished a floor). Code Information Name: setupDungeonComment Scope: Global PAC Instruction (Binary): 25 16 ec 00 Assembly Address in Memory : 0x8926a78 Parameters (int)message_address (8 bytes) : Message ID from message address table in the PAC file. Details on: about message table. Example Here is one example in hex: 25 16 ec 00 / ff ff ff ff Which is interpreted as: setupDungeonComment(0xffffffff) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08926a78(int param_1,undefined4 param_2) { int *piVar1; undefined4 uVar2; int iVar3; int iVar4; int iVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,0,4); iVar6 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c); if (iVar6 != 0) { iVar5 = *piVar1; if (iVar5 < 0) { uVar2 = 0; } else { iVar3 = FUN_0883bc1c(param_2); iVar4 = Save::Get_Save_BaseAddr(1); uVar2 = Message::Get_MsgAddr_With_FullID(iVar4 + 0x98,*(undefined4 *)(iVar3 + iVar5)); } (**(code **)(*(int *)(iVar6 + 4) + 0x48))(iVar6,uVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setupenddungeonwall.html": {
    "href": "setupenddungeonwall.html",
    "title": "setupEndDungeonWall",
    "keywords": "setupEndDungeonWall Ends dungeon wall setup, expected to be calle after bunch of e.g.setupAddDungeonWall. Code Information Name: setupEndDungeonWall Scope: Global PAC Instruction (Binary): 25 16 67 00 Assembly Address in Memory : 0x8920530 Parameters This function is parameterless. Example Here is one example in hex: 25 16 67 00 Which is interpreted as: setupEndDungeonWall() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920530(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { FUN_08972690(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x4320); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setupstartdungeonwall.html": {
    "href": "setupstartdungeonwall.html",
    "title": "setupStartDungeonWall",
    "keywords": "setupStartDungeonWall Start to setup dungeon wall, some setup instructions e.g.setupAddDungeonWall is called after this. Code Information Name: setupStartDungeonWall Scope: Global PAC Instruction (Binary): 25 16 65 00 Assembly Address in Memory : 0x8920464 Parameters This function is parameterless. Example Here is one example as disassembled code: 00000914 25166500:setupStartDungeonWall() 00000918 25166600:setupAddDungeonWall(2:20, 2:FFFFFFFF) //back of the base position 0000092C 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) //celling 00000940 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) //celling 00000954 25000700:cmd_mov(8:48, 80020.0) 00000968 25000700:cmd_mov(8:4A, 3393.0) 0000097C 25002B00:cmd_flgMov(2:E93, 2:D41) 00000990 25000300:cmd_call(1:D804) 00000998 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) //more celling elements 000009AC 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) //... 00000AC4 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) //until here 00000AD8 25000700:cmd_mov(8:48, 80021.0) 00000AEC 25166600:setupAddDungeonWall(2:14, 8:48) 00000B00 2516BD00:setGateInfo(2:0, 8:46, 2:0, 8:48) 00000B24 2516BD00:setGateInfo(2:0, 8:46, 2:1, 2:1) 00000B48 2516BD00:setGateInfo(2:0, 8:46, 2:2, 1:BD4) 00000B6C 25000C00:cmd_inc(8:46) 00000B78 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) 00000B8C 25166600:setupAddDungeonWall(2:1, 2:FFFFFFFF) 00000BA0 25166600:setupAddDungeonWall(2:1F, 2:FFFFFFFF) 00000BB4 25166700:setupEndDungeonWall() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920464(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { FUN_089725f0(*(int *)(*(int *)(param_1 + 0x10) + 0x118) + 0x4320); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setupunit.html": {
    "href": "setupunit.html",
    "title": "setupUnit",
    "keywords": "setupUnit Loads unit settings, e.g. character, equipment information, and skills. applyUnit after this is required to apply this setup. Code Information Name: setupUnit Scope: Global PAC Instruction (Binary): 25 16 33 00 Assembly Address in Memory : 0x891cc84 Parameters This function is parameterless. Example Here is one example in hex: 25 16 33 00 Which is interpreted as: setupUnit() 0005AD2C 25120200:setMissionTimmingScript(2:2, 4:0, 1:5DD04) 0005DD04 25000300:cmd_call(1:5DD3C) 0005DD3C 25000300:cmd_call(1:1C4) 000001C4 25000300:cmd_call(1:986C) 0000986C 25000700:cmd_mov(8:67, 0.0) 00009880 25161F00:addTroop(8:68, 8:67) 00009894 25162000:setAppearancePosition(8:68, 0.0) 000098A8 25162100:setRebornPosition(8:68, 0.0) 000098BC 25000700:cmd_mov(8:73, 1.0) 000098D0 25161F00:addTroop(8:74, 8:73) ... 0000994C 25001700:cmd_ifEQ(8:18, 3.0, 1:999C) //gamemode check 00009964 25001700:cmd_ifEQ(8:18, 4.0, 1:999C) 0000997C 25001700:cmd_ifEQ(8:18, 5.0, 1:999C) 00009994 25000300:cmd_call(1:5D84) //addSquad() and setPlayerId() 0000999C 25163300:setupUnit() 000099A0 25163100:applyUnit() ... Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891cc84(int param_1,undefined4 param_2) { int iVar1; int iVar2; int iVar3; int iVar4; int iVar5; iVar1 = *(int *)(param_1 + 0x10); if (iVar1 == 0) { iVar1 = 0; } else { if (iVar1 == 0) { iVar1 = 0; } iVar1 = *(int *)(iVar1 + 0xf8); if (iVar1 == 0) { iVar1 = 0; } } if (iVar1 != 0) { iVar2 = Get_Some_Flag(1); iVar2 = *(int *)(iVar2 + 0x44); switch(*(undefined4 *)(iVar2 + 0x530)) { case 1: case 2: case 3: case 5: iVar1 = FUN_088a8650(iVar1,0); if (iVar1 != 0) { Mission::Init_Mission(iVar1); } break; case 4: iVar5 = 0; do { iVar3 = FUN_088a8650(iVar1,iVar5); if (iVar3 != 0) { Mission::Init_Mission(iVar3); iVar4 = *(int *)(iVar2 + 0x54c); if ((iVar4 == 4) || (iVar4 == 3)) { FUN_088dde2c(iVar3,1); } } iVar5 = iVar5 + 1; } while (iVar5 < 2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setuserfogalpha.html": {
    "href": "setuserfogalpha.html",
    "title": "setUserFogAlpha",
    "keywords": "setUserFogAlpha Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUserFogAlpha Scope: Global PAC Instruction (Binary): 25 17 63 00 Assembly Address in Memory : 0x8918028 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (float)Var2 (8 bytes) Example Here is one example in hex: 25 17 63 00 / 04 00 00 00 / 36 00 00 00 / 10 00 00 00 / 00 00 80 bf / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setUserFogAlpha((int *)iVar54, (float)-1, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08918028(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; float *pfVar3; int iVar4; int iVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); pfVar3 = (float *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if ((iVar4 != 0) && (iVar5 = (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4), iVar5 == 9)) { FUN_088c26ac(*puVar2,*pfVar3 * 30.0,0xbf800000,iVar4); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setuserscript.html": {
    "href": "setuserscript.html",
    "title": "setUserScript",
    "keywords": "setUserScript Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setUserScript Scope: Global PAC Instruction (Binary): 25 19 0f 00 Assembly Address in Memory : 0x8941e14 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (Address)address (4 bytes) Example Here is one example in hex: 25 19 0f 00 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 01 00 00 00 / ac 5f 07 00 Which is interpreted as: setUserScript((int *)iVar0, (int *)iVar1, 0x75fac) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941e14(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,0,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { FUN_088cade0(iVar4,*puVar2,*puVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setvector.html": {
    "href": "setvector.html",
    "title": "setVector",
    "keywords": "setVector Sets force direction to the model. This does not change the force. For consistent velocity, consider using another method. Code Information Name: setVector Scope: Global PAC Instruction (Binary): 25 17 13 00 Assembly Address in Memory : 0x8911f84 Parameters (int *)handle_id (8 bytes) : The target handle to give the force. (float)direction_x (8 bytes) : X direction of the force. (float)direction_y (8 bytes) : Y Direction of the force. Example Here is one example in hex: 25 17 13 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 3f / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setVector((int *)iVar0, (float)0.5, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08911f84(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; int iVar4; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); if (param_1 == 0) { iVar4 = 0; } else { iVar4 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } if (iVar4 == 0) { iVar4 = 0; } else { iVar4 = *(int *)(iVar4 + 200); if (iVar4 == 0) { iVar4 = 0; } } } if (iVar4 != 0) { local_c = *puVar3; local_10 = *puVar2; local_8 = 0; local_4 = 0; FUN_0888e270(iVar4,&local_10,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setvectorfluctuationangle.html": {
    "href": "setvectorfluctuationangle.html",
    "title": "setVectorFluctuationAngle",
    "keywords": "setVectorFluctuationAngle Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setVectorFluctuationAngle Scope: Global PAC Instruction (Binary): 25 17 15 00 Assembly Address in Memory : 0x89121d8 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 17 15 00 / 04 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 68 41 / 10 00 00 00 / 00 00 a0 40 Which is interpreted as: setVectorFluctuationAngle((int *)iVar0, (float)0, (float)14.5, (float)5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089121d8(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); if (param_1 == 0) { iVar5 = 0; } else { iVar5 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*puVar1,1); if (iVar5 == 0) { iVar5 = 0; } if (iVar5 == 0) { iVar5 = 0; } else { iVar5 = *(int *)(iVar5 + 200); if (iVar5 == 0) { iVar5 = 0; } } } if (iVar5 != 0) { local_c = *puVar3; local_10 = *puVar2; local_8 = 0; local_4 = 0; FUN_0888e2bc(*puVar4,iVar5,&local_10,0); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setversus03rank.html": {
    "href": "setversus03rank.html",
    "title": "setVersus03Rank",
    "keywords": "setVersus03Rank Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setVersus03Rank Scope: Global PAC Instruction (Binary): 25 16 32 01 Assembly Address in Memory : 0x8927f40 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 32 01 / 04 00 00 00 / 01 00 00 00 / 08 00 00 00 / 9c 00 00 00 Which is interpreted as: setVersus03Rank((int *)iVar1, ((global)int *)giVar156) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08927f40(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x58), iVar3 != 0)) { FUN_089efa64(iVar3,*puVar1,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setversus03rankforce.html": {
    "href": "setversus03rankforce.html",
    "title": "setVersus03RankForce",
    "keywords": "setVersus03RankForce Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setVersus03RankForce Scope: Global PAC Instruction (Binary): 25 16 34 01 Assembly Address in Memory : 0x89280a4 Parameters This function is parameterless. Example Here is one example in hex: 25 16 34 01 Which is interpreted as: setVersus03RankForce() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089280a4(int param_1,undefined4 param_2) { int iVar1; if (((*(int *)(param_1 + 0x10) != 0) && (iVar1 = *(int *)(*(int *)(param_1 + 0x10) + 0x2d8), iVar1 != 0)) && (*(int *)(iVar1 + 0x58) != 0)) { FUN_089efad8(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setversusrule.html": {
    "href": "setversusrule.html",
    "title": "setVersusRule",
    "keywords": "setVersusRule Sets Versus type. This affects PVE enemies' behaviour and attack layer. This is also called in PVP field. Code Information Name: setVersusRule Scope: Global PAC Instruction (Binary): 25 16 1c 00 Assembly Address in Memory : 0x891ab18 Parameters (int)versus_type (8 bytes) : Type of the versus. 0 is no VS type, 1 is Head-on, 2 is Missile Battle, 3 is Racing Alley, 4 is Hellgate (unused). Example Here is one example in hex: 25 16 1c 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: setVersusRule((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891ab18(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Get_Some_Flag(1); *(undefined4 *)(*(int *)(iVar2 + 0x44) + 0x54c) = *puVar1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setversusstatusflag.html": {
    "href": "setversusstatusflag.html",
    "title": "setVersusStatusFlag",
    "keywords": "setVersusStatusFlag Not known, and it isn't used anywhere, but if the flag is 1, the player deals 2x damage. The flag is always initialised as zero programatically while loading the mission. Code Information Name: setVersusStatusFlag Scope: Global PAC Instruction (Binary): 25 16 ee 00 Assembly Address in Memory : 0x8925250 Parameters (int *)handle_id (8 bytes) : Unit handle, obtained from getUnitHandle. (int)flag (8 bytes) : Expected 0~2. If the flag is 1, the player deals 2x damage. Please describe what this is meant for. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08925250(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); iVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if ((iVar3 != 0) && (iVar4 = (**(code **)(*(int *)(iVar3 + 4) + 0x34))(iVar3), iVar4 == 9)) { if (*piVar2 == 2) { *(undefined4 *)(iVar3 + 0x152c) = 2; } else if (*piVar2 == 1) { *(undefined4 *)(iVar3 + 0x152c) = 1; } else { *(undefined4 *)(iVar3 + 0x152c) = 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setversusstring.html": {
    "href": "setversusstring.html",
    "title": "setVersusString",
    "keywords": "setVersusString Displays VS status Message on the ground. Code Information Name: setVersusString Scope: Global PAC Instruction (Binary): 25 16 f6 00 Assembly Address in Memory : 0x89270e4 Parameters (int)iVar0 (8 bytes) : Set 2 to make it visible. (int)iVar1 (8 bytes) : Set to 0. (int *)handle_id (8 bytes) : Unit handle from getUnitHandle, just set this to -1. (Address)message_address (4 bytes) : Message to display. This is message ID from message address table in the PAC file. Details on: about message table. (int)red (8 bytes) : Red colour of the text, in range of 0~255. (int)green (8 bytes) : Green colour of the text, in range of 0~255. (int)blue (8 bytes) : Blue colour of the text, in range of 0~255. Example Here is one example in hex: 25 16 f6 00 / 02 00 00 00 / 02 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff ff ff ff / 74 14 07 00 / 02 00 00 00 / ff 00 00 00 / 02 00 00 00 / ff 00 00 00 / 02 00 00 00 / ff 00 00 00 Which is interpreted as: setVersusString((int)2, (int)0, (int)-1, 0x71474, (int)255, (int)255, (int)255) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089270e4(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; int *piVar4; uint *puVar5; int *piVar6; int *piVar7; int iVar8; int iVar9; int iVar10; uint uVar11; int iVar12; int iVar13; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,0,4); puVar5 = (uint *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); piVar7 = (int *)Pac_Get_Param(param_2,6,1,4); iVar13 = *piVar4; if (iVar13 < 0) { iVar13 = 0; } else { iVar8 = FUN_0883bc1c(param_2); iVar9 = Save::Get_Save_BaseAddr(1); iVar13 = Message::Get_MsgAddr_With_FullID(iVar9 + 0x98,*(undefined4 *)(iVar8 + iVar13)); } iVar12 = *(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x68); iVar9 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar3,1); iVar8 = 0; if ((iVar9 != 0) && (iVar10 = (**(code **)(*(int *)(iVar9 + 4) + 0x34))(iVar9), iVar10 == 10)) { iVar8 = iVar9; } if (((iVar13 != 0) && (iVar12 != 0)) && ((iVar8 != 0 || (*piVar1 == 2)))) { uVar11 = *piVar7 << 0x10 | *puVar5 | *piVar6 << 8 | 0xff000000; if (*piVar1 == 2) { iVar8 = func_0x08b36458(iVar12); if (iVar8 != 0) { // normal vs messages below VS::Render_VS_Message(iVar8,iVar13,uVar11,2,0); } } else if (*piVar1 == 1) { iVar9 = func_0x08b36460(iVar12,*puVar2); if (iVar9 != 0) { VS::Render_VS_Message(iVar9,iVar13,uVar11,1,iVar8); } } else { iVar9 = func_0x08b36450(iVar12); if (iVar9 != 0) { VS::Render_VS_Message(iVar9,iVar13,uVar11,0,iVar8); } } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setversusstringtypescore.html": {
    "href": "setversusstringtypescore.html",
    "title": "setVersusStringTypeScore",
    "keywords": "setVersusStringTypeScore Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setVersusStringTypeScore Scope: Global PAC Instruction (Binary): 25 16 30 01 Assembly Address in Memory : 0x892737c Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (uint)Var4 (8 bytes) (int)Var5 (8 bytes) (int)Var6 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892737c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; uint *puVar5; int *piVar6; int *piVar7; int iVar8; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (uint *)Pac_Get_Param(param_2,4,1,4); piVar6 = (int *)Pac_Get_Param(param_2,5,1,4); piVar7 = (int *)Pac_Get_Param(param_2,6,1,4); if ((*(int *)(*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x2c) + 0x68) != 0) && (iVar8 = func_0x08b36488(), iVar8 != 0)) { local_4 = *puVar4; local_8 = *puVar3; func_0x08b35780(iVar8,*puVar1,*puVar2,*piVar7 << 0x10 | *puVar5 | *piVar6 << 8 | 0xff000000); func_0x08b360d0(iVar8,&local_8); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setwakeuptype.html": {
    "href": "setwakeuptype.html",
    "title": "setWakeUpType",
    "keywords": "setWakeUpType Determines if the enemy takes action automatically or not. Code Information Name: setWakeUpType Scope: Global PAC Instruction (Binary): 25 21 38 00 Assembly Address in Memory : 0x89b44b0 Parameters (int)reqactor_id (8 bytes) : Unique ID of the reqactor. (bool)is_wakeup (8 bytes) : 1 wake up the enemy, 0 does not. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b44b0(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } else { if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 == 0) { iVar3 = 0; } else { iVar3 = FUN_0896d6e0(*(undefined4 *)(iVar3 + 0x708)); if (iVar3 == 0) { iVar3 = 0; } } } if (iVar3 != 0) { *(undefined4 *)(iVar3 + 0x598) = *puVar2; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setwindcolor.html": {
    "href": "setwindcolor.html",
    "title": "setWindColor",
    "keywords": "setWindColor Defines wind colour. For example, tailwind colour uses this. Code Information Name: setWindColor Scope: Global PAC Instruction (Binary): 25 16 e2 00 Assembly Address in Memory : 0x89268c8 Parameters (int)red (8 bytes) : Red, in range of 0~255. (int)green (8 bytes) : Green, in range of 0~255. (int)blue (8 bytes) : Blue, in range of 0~255. (int)alpha (8 bytes) : (Supposed to be) alpha in range of 0~255, but does not work. Example Here is one example in hex: 25 16 e2 00 / 02 00 00 00 / ff 00 00 00 / 02 00 00 00 / 83 00 00 00 / 02 00 00 00 / 30 00 00 00 / 02 00 00 00 / ff 00 00 00 Which is interpreted as: setWindColor((int)255, (int)131, (int)48, (int)255) This defines the tailwind colour. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089268c8(int param_1,undefined4 param_2) { int *piVar1; int *piVar2; int *piVar3; int *piVar4; int iVar5; float local_10; float local_c; float local_8; float local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); piVar3 = (int *)Pac_Get_Param(param_2,2,1,4); piVar4 = (int *)Pac_Get_Param(param_2,3,1,4); iVar5 = *(int *)(param_1 + 0x10); if (iVar5 == 0) { iVar5 = 0; } else { if (iVar5 == 0) { iVar5 = 0; } iVar5 = *(int *)(iVar5 + 0x118); if (iVar5 == 0) { iVar5 = 0; } } if (iVar5 != 0) { local_4 = (float)*piVar4 * 0.003921569; local_8 = (float)*piVar3 * 0.003921569; local_c = (float)*piVar2 * 0.003921569; local_10 = (float)*piVar1 * 0.003921569; FUN_088fddf0(iVar5 + 0x250,&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setwinddirection.html": {
    "href": "setwinddirection.html",
    "title": "setWindDirection",
    "keywords": "setWindDirection Sets the direction of the wind. This represents direction only and does nothing with power or wind's existence. Code Information Name: setWindDirection Scope: Global PAC Instruction (Binary): 25 16 70 00 Assembly Address in Memory : 0x89208ec Parameters (float *)direction (8 bytes) : Wind direction. Expected -1 or 1. -1 means headwind and 1 means tailwind (Same with reversed direction too). DO NOT set zero to remove wind (Making zero will cause weird background effect). For removing wind, use setWindLevel. Example Here is one example in hex: 25 16 70 00 / 10 00 00 00 / 00 00 80 bf Which is interpreted as: setWindDirection((float)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089208ec(int param_1,undefined4 param_2) { float *pfVar1; int iVar2; float fVar3; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { fVar3 = *pfVar1; FUN_088fdddc(iVar2 + 0x250,(int)fVar3); FUN_088fdddc(iVar2 + 0x210,(int)fVar3); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setwindlevel.html": {
    "href": "setwindlevel.html",
    "title": "setWindLevel",
    "keywords": "setWindLevel Sets the wind strength. This works both in hideout and during mission. Code Information Name: setWindLevel Scope: Global PAC Instruction (Binary): 25 16 71 00 Assembly Address in Memory : 0x8920998 Parameters (float *)destination (8 bytes) : Strength of the wind, the value is between 0~1. 0 means no wind. DO NOT set stength to negative for changing direction (it will remove wind). For direction, use setWindDirection. Example Here is one example in hex: 25 16 71 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: setWindLevel((float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920998(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = *(int *)(iVar2 + 0x118); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_088fddc8(*puVar1,iVar2 + 0x250); FUN_088fddc8(*puVar1,iVar2 + 0x210); FUN_08900850(0,iVar2 + 0x1b0,9); FUN_08900850(0,iVar2 + 0x1b0,0xd); FUN_08900850(0,iVar2 + 0x1b0,0x10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setworkvalue.html": {
    "href": "setworkvalue.html",
    "title": "setWorkValue",
    "keywords": "setWorkValue Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setWorkValue Scope: Global PAC Instruction (Binary): 25 19 0d 00 Assembly Address in Memory : 0x8941c28 Parameters (undefined4)Var0 (8 bytes) (uint)Var1 (8 bytes) (undefined4)Var2 (8 bytes) Example Here is one example in hex: 25 19 0d 00 / 04 00 00 00 / 40 00 00 00 / 02 00 00 00 / 00 00 00 00 / 04 00 00 00 / 00 00 00 00 Which is interpreted as: setWorkValue((int *)iVar64, (int)0, (int *)iVar0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08941c28(int param_1,undefined4 param_2) { undefined4 *puVar1; uint *puVar2; undefined4 *puVar3; int iVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); iVar4 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*puVar1,1); if (iVar4 == 0) { iVar4 = 0; } else if (iVar4 == 0) { iVar4 = 0; } else { (**(code **)(*(int *)(iVar4 + 4) + 0x34))(iVar4); } if (iVar4 != 0) { if (*puVar2 < 4) { *(undefined4 *)(*puVar2 * 4 + iVar4 + 0x8e0) = *puVar3; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "setworldinfo.html": {
    "href": "setworldinfo.html",
    "title": "setWorldInfo",
    "keywords": "setWorldInfo Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: setWorldInfo Scope: Global PAC Instruction (Binary): 25 16 05 00 Assembly Address in Memory : 0x89192b0 Parameters (Undefined)Var0 (8 bytes) (Undefined)Var1 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089192b0(int param_1,undefined4 param_2) { Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); if (*(int *)(param_1 + 0x10) != 0) { Save::Get_Save_BaseAddr(1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "shootmissile.html": {
    "href": "shootmissile.html",
    "title": "shootMissile",
    "keywords": "shootMissile Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: shootMissile Scope: Global PAC Instruction (Binary): 25 16 3d 01 Assembly Address in Memory : 0x892b030 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) Example Here is one example in hex: 25 16 3d 01 / 04 00 00 00 / 00 00 00 00 / 04 00 00 00 / 0a 00 00 00 Which is interpreted as: shootMissile((int *)iVar0, (int *)iVar10) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892b030(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = func_0x08b2acc0(*(undefined4 *)(*(int *)(iVar3 + 0x2c) + 0x54),*puVar1), iVar3 != 0)) { FUN_08a4e45c(iVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "showdialogex.html": {
    "href": "showdialogex.html",
    "title": "showDialogEx",
    "keywords": "showDialogEx Opens dialogue. Not all dialogs use this, part of the in-game dialogs (e.g. in barracks) are hardcoded. This pauses pac instruction execution until the choice is done. Code Information Name: showDialogEx Scope: Global PAC Instruction (Binary): 25 03 0d 00 Assembly Address in Memory : 0x892d788 Parameters (int *)result (8 bytes) : Variable to store the result, as a choice index. -1 is still selecting. (int)position_x (8 bytes) : X position to put the dialog, as PSP screen pixels on screen. Set as 0xE0 to put middle of the screen. (int)position_y (8 bytes) : Y position to put the dialog, as PSP screen pixels on screen. Set as 0x88 to put middle of the screen. Note that PSP screen size is 480 x 272 and the pivot is on the middle. (Address)message_address (4 bytes) : Message to display as main text. This is message ID from message address table in the PAC file. Details on: about message table. (int)close_button_Id (8 bytes) : Input Button ID to cancel and close the window. Keep 0x200 to cancel with ◯ button. (int)default_choice (8 bytes) : Choice index to select by default. (bool)has_title (8 bytes) : Set 0 to hide the title bar (The red text above the main text). Actually, it uses message from 0x8a60080, but nothing writes to there, which results no title. (bool)left_choices_text_align (8 bytes) : Set 0 to align the choice texts to the center. (int)choice_amount (4 bytes) : Choice amount to display. (int...)choices_message_id (>= 4 bytes) : Choice message IDs to display, from above to below. This is message ID from message address table in the PAC file. Details on: about message table. ... means any amounts of parameter. Warning choice_amount must match to the amount of the choice_message_id or it will cause unexpected behaviour. About the Choice Index Choice index starts from zero, from choice above to below. For example, for typical Yes/No dialog, Yes is 0 and No is 1. Example Here is one example in hex: 25 03 0d 00 / 04 00 00 00 / 00 00 00 00 / 02 00 00 00 / f0 00 00 00 / 02 00 00 00 / 88 00 00 00 / f0 e6 05 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / 00 00 00 00 / 01 00 00 00 / f4 e6 05 00 / 25 00 07 00 Which is interpreted as: showDialogEx((int *)iVar0, (int)240, 0x2, 0x5e6f0, (int)0, (int)0, (int)1, 0x2, 0x1, 0x5e6f4, 0x70025) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892d788(int param_1,undefined4 param_2) { char cVar1; short sVar2; int iVar3; int iVar4; int iVar5; undefined4 *puVar6; int *piVar7; int *piVar8; int *piVar9; int *piVar10; int *piVar11; int *piVar12; uint *puVar13; int *piVar14; int iVar15; int iVar16; undefined *puVar17; float *pfVar18; undefined4 *puVar19; undefined4 *puVar20; undefined *puVar21; uint uVar22; undefined4 uVar23; uint uVar24; int iVar25; undefined4 *puVar26; float local_48; float local_44; undefined4 local_40; undefined4 local_3c; undefined4 local_38; undefined4 local_34; undefined4 local_30; int *local_2c; int local_28; short *local_24; undefined4 local_20 [8]; iVar3 = Get_Execution_Pause_Phase(param_2); iVar4 = Save::Get_Save_BaseAddr(1); puVar26 = (undefined4 *)(param_1 + 0x1c); iVar5 = FUN_08a1ee38(*(undefined4 *)(param_1 + 0x1c)); FUN_08a1ee40(*puVar26); if (iVar3 == 0) { iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); if (-1 < (int)((uint)*(byte *)(*(int *)(iVar3 + 4) + 0x75) << 0x1d)) { iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); puVar6 = (undefined4 *)&DAT_00000020; *(byte *)(*(int *)(iVar3 + 4) + 0x75) = *(byte *)(*(int *)(iVar3 + 4) + 0x75) | 4; puVar19 = local_20; puVar20 = puVar19; while (puVar20 != (undefined4 *)0x0) { *(undefined *)puVar19 = 0; puVar19 = (undefined4 *)((int)puVar19 + 1); puVar6 = (undefined4 *)((int)puVar6 + -1); puVar20 = puVar6; } puVar19 = (undefined4 *)Pac_Get_Param(param_2,0xf,1,4); piVar7 = (int *)Pac_Get_Param(param_2,1,1,4); piVar8 = (int *)Pac_Get_Param(param_2,2,1,4); piVar9 = (int *)Pac_Get_Param(param_2,3,0,4); piVar10 = (int *)Pac_Get_Param(param_2,4,1,4); // default choice puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); piVar11 = (int *)Pac_Get_Param(param_2,6,1,4); piVar12 = (int *)Pac_Get_Param(param_2,7,1,4); puVar13 = (uint *)Pac_Get_Param(param_2,8,0,4); uVar24 = DAT_08a70d04; if ((int)*puVar13 < (int)DAT_08a70d04) { uVar24 = *puVar13; } iVar3 = 0; if (0 < (int)uVar24) { puVar20 = local_20; do { piVar14 = (int *)Pac_Get_Param(param_2,9,0,4); iVar25 = *piVar14; if (iVar25 < 0) { *puVar20 = 0; } else { iVar15 = FUN_0883bc1c(param_2); iVar16 = Save::Get_Save_BaseAddr(1); uVar23 = Message::Get_MsgAddr_With_FullID (iVar16 + 0x98,*(undefined4 *)(iVar15 + iVar25)); *puVar20 = uVar23; } iVar3 = iVar3 + 1; puVar20 = puVar20 + 1; } while (iVar3 < (int)uVar24); } iVar3 = *piVar10; *(int *)(param_1 + 0x30) = iVar3; iVar25 = FUN_08877b6c(1); iVar25 = FUN_08836f88(iVar25 + 0x10); if (iVar3 == 0) { *(byte *)(*(int *)(iVar25 + 4) + 0x79) = *(byte *)(*(int *)(iVar25 + 4) + 0x79) & 0x7f; } else { *(byte *)(*(int *)(iVar25 + 4) + 0x79) = *(byte *)(*(int *)(iVar25 + 4) + 0x79) | 0x80; } iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x79) = *(byte *)(*(int *)(iVar3 + 4) + 0x79) | 0x40; *puVar19 = 0xffffffff; if (*piVar11 == 0) { puVar17 = &DAT_08a60084; } else { puVar17 = (undefined *)Message::Get_MsgAddr_With_FullID(iVar4 + 0x98,0x302f9); } iVar3 = *piVar9; if (iVar3 < 0) { puVar21 = (undefined *)0x0; } else { iVar4 = FUN_0883bc1c(param_2); iVar25 = Save::Get_Save_BaseAddr(1); puVar21 = (undefined *) Message::Get_MsgAddr_With_FullID(iVar25 + 0x98,*(undefined4 *)(iVar4 + iVar3)); } if (puVar21 == (undefined *)0x0) { puVar17 = &DAT_08a60084; puVar21 = puVar17; } FUN_0892de9c(&local_30,iVar5); local_40 = 0x41400000; local_3c = 0x41400000; local_38 = 0x40e00000; local_34 = 0x40a00000; FUN_0885b580(local_28,&local_38,&local_40); if (local_28 != 0) { *local_24 = *local_24 + -1; if (local_24 == (short *)0x0) { sVar2 = 0; } else { sVar2 = *local_24; } if (sVar2 == 0) { (**(code **)(*local_2c + 0xc))(local_2c,local_28,local_24,local_30); FUN_0892e358(local_28,local_30); } } *(bool *)(iVar5 + 0xd30) = *piVar12 != 0; FUN_08930c1c(iVar5,puVar17,puVar21,0); uVar22 = 0; if (uVar24 != 0) { puVar20 = local_20; do { Message::Dialog::Dialog_Write_Message(iVar5,*puVar20); uVar22 = uVar22 + 1; puVar20 = puVar20 + 1; } while (uVar22 < uVar24); } FUN_08931324(iVar5); pfVar18 = (float *)FUN_08931dcc(iVar5); local_44 = (float)*piVar8 - pfVar18[1] * 0.5; local_48 = (float)*piVar7 - *pfVar18 * 0.5; FUN_08931c9c(iVar5,&local_48); FUN_08a1edb8(*puVar26,1,*puVar6,0); Pause_Execution(param_2,1); iVar3 = *(int *)(*(int *)(param_1 + 0x24) + 0x14); _DAT_08ab9524 = puVar19; if (iVar3 != 0) { *(undefined *)(iVar3 + 0x60) = 0; } } } else if (iVar3 == 1) { iVar3 = FUN_08851bec(); uVar23 = *(undefined4 *)(iVar3 + 0x10c); iVar4 = *(int *)(*(int *)(param_1 + 0x24) + 0x14); iVar3 = Get_addr_0xd20_Data(iVar5); if (iVar3 == 0) { iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x75) = *(byte *)(*(int *)(iVar3 + 4) + 0x75) & 0xfb; PAC::PAC_setCmdId(param_2,0); if (iVar4 != 0) { *(undefined *)(iVar4 + 0x60) = 1; } } else { iVar3 = Message::Dialog::Is_Answered(iVar5); if (iVar3 == 0) { if ((*(int *)(param_1 + 0x30) != 0) && (cVar1 = FUN_08852c04(uVar23), cVar1 != '\\0')) { if (_DAT_08ab9524 == (undefined4 *)0x0) { *(undefined4 *)(param_1 + 0x30) = 0; } else { *_DAT_08ab9524 = 0xffffffff; *(undefined4 *)(param_1 + 0x30) = 0; } FUN_08a1edb8(*puVar26,0,0xffffffff,0); FUN_08a1ee08(*puVar26); iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x79) = *(byte *)(*(int *)(iVar3 + 4) + 0x79) & 0x7f; iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x79) = *(byte *)(*(int *)(iVar3 + 4) + 0x79) & 0xbf; iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x75) = *(byte *)(*(int *)(iVar3 + 4) + 0x75) & 0xfb; PAC::PAC_setCmdId(param_2,0); if (iVar4 != 0) { *(undefined *)(iVar4 + 0x60) = 1; } } } else { if (_DAT_08ab9524 == (undefined4 *)0x0) { uVar23 = *puVar26; } else { uVar23 = FUN_089319fc(iVar5); *_DAT_08ab9524 = uVar23; uVar23 = *puVar26; } FUN_08a1edb8(uVar23,0,0xffffffff,0); FUN_08a1ee08(*puVar26); iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x79) = *(byte *)(*(int *)(iVar3 + 4) + 0x79) & 0x7f; iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x79) = *(byte *)(*(int *)(iVar3 + 4) + 0x79) & 0xbf; iVar3 = FUN_08877b6c(1); iVar3 = FUN_08836f88(iVar3 + 0x10); *(byte *)(*(int *)(iVar3 + 4) + 0x75) = *(byte *)(*(int *)(iVar3 + 4) + 0x75) & 0xfb; PAC::PAC_setCmdId(param_2,0); if (iVar4 != 0) { *(undefined *)(iVar4 + 0x60) = 1; } } } } return; }"
  },
  "spawn.html": {
    "href": "spawn.html",
    "title": "spawn",
    "keywords": "spawn Creates all enemies from the certain generator. Used after getHandle. Code Information Name: spawn Scope: Mission PAC Instruction (Binary): 25 1f 13 00 Assembly Address in Memory : 0x8b5d830 Parameters (int *)handle (8 bytes) : The handle of the generator to instantiate. Example Here is one example in hex: 25 1f 13 00 / 08 00 00 00 / 1a 00 00 00 Which is interpreted as: spawn(((global)int *)giVar26) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Mission__08b5d830(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else if (*piVar1 == -1) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = Get_BaseAddr_From_Generator(*(undefined4 *)(iVar2 + 0x2c8)); if (iVar2 == 0) { iVar2 = 0; } } if (iVar2 != 0) { FUN_Mission__08b57c00(iVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "squadhandletounituid.html": {
    "href": "squadhandletounituid.html",
    "title": "squadHandleToUnitUid",
    "keywords": "squadHandleToUnitUid Gets unique reqActor ID from a squad. Code Information Name: squadHandleToUnitUid Scope: Global PAC Instruction (Binary): 25 21 30 00 Assembly Address in Memory : 0x89b3fdc Parameters (int *)squad_handle (8 bytes) : The squad handle to get the unique reqActor ID. (int *)destination (8 bytes) : Variable to store the unique UID. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3fdc(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); *puVar2 = 0xffffffff; iVar3 = Is_Valid_SquadHandle(param_1,*puVar1); if (iVar3 != 0) { *puVar2 = *(undefined4 *)(*(int *)(iVar3 + 0x7c) + 0xa08); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "start.html": {
    "href": "start.html",
    "title": "start",
    "keywords": "start Starts the gameplay. Follows after multi_battleGoAHead. They are defined separately for single play and multiplay. Code Information Name: start Scope: Global PAC Instruction (Binary): 25 0c 1e 00 Assembly Address in Memory : 0x89711d8 Parameters (int)Var0 (8 bytes) : Please describe what this does. Example Here is one example in hex: 25 0c 1e 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: start((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089711d8(int param_1,undefined4 param_2) { int *piVar1; int iVar2; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar2 != 0) { if (*(char *)(iVar2 + 0x3f74) == '\\0') { func_0x08b5f500(iVar2,*piVar1 == 0,1); iVar2 = *(int *)(param_1 + 0x10); } else { iVar2 = *(int *)(param_1 + 0x10); } if ((((iVar2 != 0) && (*(int *)(iVar2 + 0x2b8) != 0)) && (iVar2 = *(int *)(*(int *)(iVar2 + 0x2b8) + 0x2c), iVar2 != 0)) && (iVar2 = *(int *)(iVar2 + 100), iVar2 != 0)) { *(undefined *)(iVar2 + 0x20c) = 1; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startautocommandkey.html": {
    "href": "startautocommandkey.html",
    "title": "startAutoCommandKey",
    "keywords": "startAutoCommandKey Start performing the command sequence that was set from addAutoCommandKey. Code Information Name: startAutoCommandKey Scope: Global PAC Instruction (Binary): 25 0c 10 00 Assembly Address in Memory : 0x8970b04 Parameters (undefined4)Var0 (8 bytes) : Please describe. Example Here is one example in hex: 25 0c 10 00 / 02 00 00 00 / ff ff ff ff Which is interpreted as: startAutoCommandKey((int)-1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08970b04(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if (iVar2 != 0) { func_0x08b746d8(iVar2 + 8,*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startfade.html": {
    "href": "startfade.html",
    "title": "startFade",
    "keywords": "startFade Provides fade-in or fade-out effect. For smooth scene change, use with getFadeRate. Code Information Name: startFade Scope: Global PAC Instruction (Binary): 25 16 86 00 Assembly Address in Memory : 0x8921688 Parameters (int)z_priority (8 bytes) : z-index (render priority), higher goes more top. (float)fade_time (8 bytes) : Fade time as seconds. (float)red (8 bytes) : Red colour of the fade screen, in range of 0~1. (float)green (8 bytes) : Green colour of the fade screen, in range of 0~1. (float)blue (8 bytes) : Blue colour of the fade screen, in range of 0~1. (float)alpha (8 bytes) : Alpha of the fade screen, 1 for fade-out and 0 for fade-in. Remarks Note this fades from current fade screen. For example, for pure fade-in effect, alpha 1 with fade_time 0 must be defined first: startFade((int)900012, (float)0, (float)0, (float)0, (float)0, (float)1) //fade in preheat startFade((int)900012, (float)0.3, (float)0, (float)0, (float)0, (float)0) //fade in Example Here is one example in hex: 25 16 86 00 / 02 00 00 00 / ac bb 0d 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: startFade((int)900012, (float)0, (float)0, (float)0, (float)0, (float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08921688(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; undefined4 *puVar5; undefined4 *puVar6; int iVar7; int iVar8; int iVar9; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); if ((*(int *)(param_1 + 0x10) != 0) && (iVar8 = *(int *)(*(int *)(param_1 + 0x10) + 200), iVar8 != 0)) { iVar9 = *piVar1; iVar7 = (**(code **)(*(int *)(iVar8 + 0x1c) + 0x10))(iVar8); if (iVar9 == iVar7) { local_4 = *puVar6; } else { (**(code **)(*(int *)(iVar8 + 0x1c) + 0x14))(iVar8,iVar9); local_4 = *puVar6; } local_8 = *puVar5; local_c = *puVar4; local_10 = *puVar3; FUN_089926b0(*puVar2,iVar8,&local_10); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startgame.html": {
    "href": "startgame.html",
    "title": "startGame",
    "keywords": "startGame Starts to play the game. Followed after isGoGame. Code Information Name: startGame Scope: Global PAC Instruction (Binary): 25 16 6b 00 Assembly Address in Memory : 0x8920714 Parameters This function is parameterless. Example Here is one example in hex: 25 16 6b 00 Which is interpreted as: startGame() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08920714(int param_1,undefined4 param_2) { if (*(int *)(param_1 + 0x10) != 0) { FUN_0889dda8(); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startintroevent.html": {
    "href": "startintroevent.html",
    "title": "startIntroEvent",
    "keywords": "startIntroEvent Mark the countdown as performable between story. This sets only flag, and multi_battleGoAHead after this is required for countdown. This does nothing with real multi countdown. Code Information Name: startIntroEvent Scope: Global PAC Instruction (Binary): 25 16 3f 01 Assembly Address in Memory : 0x892b190 Parameters This function is parameterless. Example Here is one example in hex: 25 16 3f 01 Which is interpreted as: startIntroEvent() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892b190(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x5c); if (iVar1 != 0) { *(undefined *)(iVar1 + 0x23) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startscreenfog.html": {
    "href": "startscreenfog.html",
    "title": "startScreenFog",
    "keywords": "startScreenFog Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: startScreenFog Scope: Global PAC Instruction (Binary): 25 16 18 01 Assembly Address in Memory : 0x8929c5c Parameters (Undefined)Var0 (8 bytes) : Unused (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) (float)Var4 (8 bytes) Example Here is one example in hex: 25 16 18 01 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / f0 d8 ff ff / 02 00 00 00 / 03 10 00 00 / 02 00 00 00 / 05 10 00 00 / 20 00 00 00 / 0b 00 00 00 Which is interpreted as: startScreenFog((int)0, (int)0xf0d8ffff, (int)4099, (int)4101, (float *)fVar11) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08929c5c(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; float *pfVar4; undefined4 local_40; undefined4 local_3c; undefined4 local_38; undefined4 local_30; undefined4 local_2c; undefined4 local_28; undefined4 local_24; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_10; Pac_Get_Param(param_2,0,1,4); puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,4,1,4); local_30 = DAT_08a70be0; local_2c = DAT_08a70be4; local_28 = DAT_08a70be8; local_24 = DAT_08a70bec; local_20 = DAT_08a70bf0; local_1c = DAT_08a70bf4; local_18 = DAT_08a70bf8; local_14 = DAT_08a70bfc; local_10 = DAT_08a70c00; local_40 = *puVar2; local_3c = *puVar3; local_38 = *puVar1; if (DAT_08a70c10 < *pfVar4) { pfVar4 = &DAT_08a70c10; } FUN_089803c4(*pfVar4,*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x2b8) + 0x3c) + 0x2a0,&local_40 ); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startsetupstage.html": {
    "href": "startsetupstage.html",
    "title": "startSetupStage",
    "keywords": "startSetupStage Declares definition of certain stage group with the given ID. Paired with endSetupStage. Used when there is scene change with background change (Pandora family). Called just before starting stage setup through addStage, thus called in 2nd phase of mission loading. More information in How To: Setup Stages. Code Information Name: startSetupStage Scope: Global PAC Instruction (Binary): 25 16 5b 00 Assembly Address in Memory : 0x891fd68 Parameters (int)stage_index (8 bytes) : Index of the stage in the mission. Used by applyStage. Remarks This is paired with endSetupStage until the setup is completely done. Example Here is one example in hex: 25 16 5b 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: startSetupStage((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0891fd68(int param_1,undefined4 param_2) { undefined4 *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); FUN_088b03e0(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x118),*puVar1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startsummonmode.html": {
    "href": "startsummonmode.html",
    "title": "startSummonMode",
    "keywords": "startSummonMode Starts summon manually from a specific player side. Code Information Name: startSummonMode Scope: Global PAC Instruction (Binary): 25 0c 28 00 Assembly Address in Memory : 0x8971704 Parameters (int *)handle_id (8 bytes) : Unit handle to summon, obtained from getUnitHandle. (uint)score (8 bytes) : The summon score. Example Here is one example in hex: 25 0c 28 00 / 04 00 00 00 / 2c 00 00 00 / 02 00 00 00 / 80 96 98 00 Which is interpreted as: startSummonMode((int *)iVar44, (int)10000000) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08971704(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; undefined4 uVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (-1 < *piVar1) { uVar3 = Find_Target_By_HandleID(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0xe8),*piVar1,1); func_0x08b5f5c0(*(undefined4 *)(*(int *)(param_1 + 0x10) + 0x158),uVar3,*puVar2); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "startsyncgameflag.html": {
    "href": "startsyncgameflag.html",
    "title": "startSyncGameFlag",
    "keywords": "startSyncGameFlag Mark as the player started to join the other's hideout. Code Information Name: startSyncGameFlag Scope: Azito PAC Instruction (Binary): 25 1c 26 00 Assembly Address in Memory : 0x8b4fdb0 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 26 00 Which is interpreted as: startSyncGameFlag() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fdb0(int param_1,undefined4 param_2) { int iVar1; iVar1 = *(int *)(*(int *)(*(int *)(param_1 + 0x10) + 500) + 0x6c); if (iVar1 == 0) { PAC::PAC_setCmdId(param_2,0); } else { if ((*(int *)(*(int *)(*(int *)(param_1 + 0x10) + 0x214) + 0x38) != 0) && (*(char *)(iVar1 + 0x28) == '\\0')) { FUN_Azito__08b545d8(); } PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "starttimer.html": {
    "href": "starttimer.html",
    "title": "startTimer",
    "keywords": "startTimer Intialises and enables the timer. Related guide: How To: Add A Timer Code Information Name: startTimer Scope: Global PAC Instruction (Binary): 25 16 9d 00 Assembly Address in Memory : 0x89225d4 Parameters (float)time (8 bytes) : Time to set to the timer, as seconds. (bool)is_incremental (8 bytes) : If it is zero, the timer will decrease. Otherwise, it will increase. Example Here is one example in hex: 25 16 9d 00 / 10 00 00 00 / 00 00 f0 41 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: startTimer((float)30, (int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089225d4(int param_1,undefined4 param_2) { float *pfVar1; int *piVar2; int iVar3; pfVar1 = (float *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); if ((((*(int *)(param_1 + 0x10) != 0) && (iVar3 = *(int *)(*(int *)(param_1 + 0x10) + 0x2b8), iVar3 != 0)) && (iVar3 = *(int *)(iVar3 + 0x2c), iVar3 != 0)) && (*(int *)(iVar3 + 100) != 0)) { if (*piVar2 == 0) { if (*pfVar1 != -1.0) { func_0x08b32d90(); } } else { func_0x08b32df8(*pfVar1); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "stop.html": {
    "href": "stop.html",
    "title": "stop",
    "keywords": "stop There are few functions with the same name: stop (250b0300) (Global) stop (250c1f00) (Global)"
  },
  "stop_250b0300.html": {
    "href": "stop_250b0300.html",
    "title": "stop (250b0300)",
    "keywords": "stop (250b0300) Other functions have the same name. Check the Disambiguation page to find them. Stops currently playing sound/music. Code Information Name: stop Scope: Global PAC Instruction (Binary): 25 0b 03 00 Assembly Address in Memory : 0x896f918 Parameters (int)sgd_id (8 bytes) : ID of the Atrac or the Sound Effect. (float)fade_time (8 bytes) : Crossfade time, as seconds (float)Var2 (8 bytes) : Please describe what this does. Seems like value between 0 and 1. Example Here is one example in hex: 25 0b 03 00 / 02 00 00 00 / f6 00 50 50 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 3f Which is interpreted as: stop((int)1347420406, (float)0, (float)0.5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896f918(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); FUN_088eb0a8(*puVar2,*puVar3,*(int *)(param_1 + 0x14) + 0x60,*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "stop_250c1f00.html": {
    "href": "stop_250c1f00.html",
    "title": "stop (250c1f00)",
    "keywords": "stop (250c1f00) Other functions have the same name. Check the Disambiguation page to find them. Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: stop Scope: Global PAC Instruction (Binary): 25 0c 1f 00 Assembly Address in Memory : 0x897128c Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0c 1f 00 / 10 00 00 00 / 00 00 80 3f Which is interpreted as: stop((float)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0897128c(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(*(int *)(param_1 + 0x10) + 0x158); if ((iVar2 != 0) && (*(char *)(iVar2 + 0x3f74) != '\\0')) { func_0x08b5f570(*puVar1); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "stopmotion.html": {
    "href": "stopmotion.html",
    "title": "stopMotion",
    "keywords": "stopMotion Stop the animation. Please describe difference from pauseMotion. Code Information Name: stopMotion Scope: Global PAC Instruction (Binary): 25 17 3a 00 Assembly Address in Memory : 0x8914c6c Parameters (int *)handle_id (8 bytes) : The target handle. (float)fVar1 (8 bytes) : Does nothing, can keep as zero. Example Here is one example in hex: 25 17 3a 00 / 04 00 00 00 / 36 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: stopMotion((int *)iVar54, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08914c6c(int param_1,undefined4 param_2) { int *piVar1; int iVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar2 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar2 == 0) { iVar2 = 0; } if (((iVar2 != 0) && (iVar2 = *(int *)(iVar2 + 200), iVar2 != 0)) && (iVar3 = *(int *)(iVar2 + 0x1e8), iVar3 != 0)) { *(undefined *)(iVar2 + 0xb9) = 1; FUN_08980a8c(iVar3); *(undefined *)(iVar3 + 0xb9) = 0; } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "stopmove.html": {
    "href": "stopmove.html",
    "title": "stopMove",
    "keywords": "stopMove Stops the movement from the movePosition Code Information Name: stopMove Scope: Global PAC Instruction (Binary): 25 17 3d 00 Assembly Address in Memory : 0x8915100 Parameters (int *)handle (8 bytes) : Handle value to stop the moving. (float)delay (8 bytes) : Delay time as seconds before stopping. Example Here is one example in hex: 25 17 3d 00 / 08 00 00 00 / 5b 00 00 00 / 10 00 00 00 / 00 00 00 00 Which is interpreted as: stopMove(((global)int *)giVar91, (float)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08915100(int param_1,undefined4 param_2) { int *piVar1; undefined4 *puVar2; int iVar3; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); if (*piVar1 != -1) { iVar3 = Find_Target_By_HandleID(*(undefined4 *)(param_1 + 0x14),*piVar1,1); if (iVar3 == 0) { iVar3 = 0; } if (((iVar3 != 0) && (*(int *)(iVar3 + 200) != 0)) && (*(int *)(*(int *)(iVar3 + 200) + 0x1ec) != 0)) { FUN_0898426c(*puVar2); } } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "syncreadarcfile.html": {
    "href": "syncreadarcfile.html",
    "title": "syncReadArcFile",
    "keywords": "syncReadArcFile Loads resource synchronously. For loading resource, use readArcFile instead. Note that resource is loaded asynchrnously because reading them takes time, resulting bottleneck of the performance. Code Information Name: syncReadArcFile Scope: Global PAC Instruction (Binary): 25 09 0a 00 Assembly Address in Memory : 0x8948f30 Parameters (int)resource_type_id (8 bytes) : See the resource type table below. If not sure, set it to 2 (Loadinggroup_Scene). (String)resource_name : Resource name to read. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_08948f30(undefined4 param_1,undefined4 param_2) { char *pcVar1; undefined4 *puVar2; char *pcVar3; undefined4 uVar4; int iVar5; char *pcVar6; char local_100 [256]; puVar2 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); pcVar3 = &DAT_00000100; pcVar6 = local_100; pcVar1 = pcVar6; while (pcVar1 != (char *)0x0) { *pcVar6 = '\\0'; pcVar6 = pcVar6 + 1; pcVar3 = pcVar3 + -1; pcVar1 = pcVar3; } Pac_Get_StringParam(param_2,local_100); uVar4 = FUN_08883830(local_100); iVar5 = FUN_08843148(local_100,uVar4); if (iVar5 == 0) { uVar4 = FUN_0884a440(1); Data::Load_File_From_Bnd(uVar4,local_100,FUN_08882250,*puVar2,0,0,1,0,0,0); PAC::PAC_setCmdId(param_2,0); } else { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "sysytemmessage.html": {
    "href": "sysytemmessage.html",
    "title": "sysytemMessage",
    "keywords": "sysytemMessage Displays a message on the center of the screen, e.g. \"Time's up!\" in tutorial. Code Information Name: sysytemMessage Scope: Global PAC Instruction (Binary): 25 03 04 00 Assembly Address in Memory : 0x892bbd8 Parameters (float)position_x (8 bytes) : X Position of the text as PSP pixels. 0 is leftmost of the screen. (float)position_y (8 bytes) : Y Position of the text as PSP pixels. 0 is topmost of the screen. (float)scale (8 bytes) : Scale the text as PSP pixels. (float)appear_time (8 bytes) : Speed of the appear animation, as seconds. (float)display_time (8 bytes) : Time to show the text, as seconds. The display time includs animation time. For example, if animation is 2 seconds and display is 1.5 seconds, the text will disappear before the animation is done. (float)disappear_time (8 bytes) : Supposed to be, but doesn't work. (int)anim_type (8 bytes) : Value in range of 0~3. This instruction won't work with incorrect range of this value. 0 wipe from left to right (seems anim speed doesn't affect), 1 scale + fade, 2 somehow broken, 3 fade in only (Address)message_id (4 bytes) : The text message ID. This is message ID from message address table in the PAC file. Details on: about message table. Note that the PSP screen size is 480 x 272. The text anchor is on X center, Y top. Remarks If callSysMsg or callSysMsgLabel is called, this sysytemMessage will be disappeared. Example Here is one example in hex: 25 03 04 00 / 10 00 00 00 / 00 00 70 43 / 10 00 00 00 / 00 00 c8 42 / 10 00 00 00 / 00 00 90 41 / 10 00 00 00 / 9a 99 99 3e / 10 00 00 00 / 00 00 38 41 / 10 00 00 00 / 9a 99 99 3e / 02 00 00 00 / 00 00 00 00 / 08 e6 05 00 Which is interpreted as: sysytemMessage((float)240, (float)100, (float)18, (float)0.3, (float)11.5, (float)0.3, (int)0, 0x5e608) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892bbd8(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4, undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; float *pfVar4; float *pfVar5; float *pfVar6; int *piVar7; int *piVar8; int iVar9; int iVar10; undefined4 *puVar11; uint uVar12; undefined4 filepath; int iVar13; undefined4 uVar14; float fVar15; undefined4 local_a0; undefined4 local_9c; undefined4 local_98; undefined4 local_94; undefined4 local_90; undefined4 local_8c; undefined4 local_88; undefined4 local_84; undefined4 local_80; undefined4 local_7c; undefined4 local_78; undefined4 local_74; undefined4 local_70; undefined4 local_6c; undefined4 local_68; undefined4 local_64; undefined auStack96 [64]; undefined auStack32 [32]; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); pfVar5 = (float *)Pac_Get_Param(param_2,4,1,4); pfVar6 = (float *)Pac_Get_Param(param_2,5,1,4); piVar7 = (int *)Pac_Get_Param(param_2,6,1,4); piVar8 = (int *)Pac_Get_Param(param_2,7,0,4); FUN_0892d470(param_1); iVar13 = *piVar8; if (iVar13 < 0) { uVar14 = 0; } else { iVar9 = FUN_0883bc1c(param_2); iVar10 = Save::Get_Save_BaseAddr(1); uVar14 = Message::Get_MsgAddr_With_FullID(iVar10 + 0x98,*(undefined4 *)(iVar9 + iVar13)); } iVar13 = *piVar7; if (iVar13 == 3) { if (ABS(*pfVar4) < 0.001) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x34c) = 0; } else { *(float *)(*(int *)(param_1 + 0x2c) + 0x34c) = *pfVar4; } if (ABS(*pfVar4) < 0.001) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x350) = 0; } else { *(float *)(*(int *)(param_1 + 0x2c) + 0x350) = *pfVar4; } if (ABS(*pfVar6) < 0.001) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x354) = 0; } else { *(float *)(*(int *)(param_1 + 0x2c) + 0x354) = *pfVar6; } *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x338) = 0; FUN_08935148(*(undefined4 *)(param_1 + 0x2c),3); *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a0) = 1; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a4) = 2; local_98 = *puVar3; local_94 = local_98; FUN_089350e8(*(undefined4 *)(param_1 + 0x2c),&local_98); FUN_089353d0(*(undefined4 *)(param_1 + 0x2c),param_1 + 0x23c); FUN_089352a0(*(undefined4 *)(param_1 + 0x2c),uVar14,0); fVar15 = *pfVar5 * 4800.0; if (fVar15 < 2.147484e+09) { uVar12 = (uint)fVar15; } else { uVar12 = (int)(fVar15 - 2.147484e+09) | 0xffff8000; } *(uint *)(*(int *)(param_1 + 0x2c) + 0x358) = uVar12; local_9c = *puVar2; local_a0 = *puVar1; FUN_08939140(*(undefined4 *)(param_1 + 0x2c),&local_a0); uVar14 = *puVar2; iVar13 = *(int *)(param_1 + 0x2c); *(undefined4 *)(iVar13 + 0x170) = *puVar1; *(undefined4 *)(iVar13 + 0x174) = uVar14; (**(code **)(*(int *)(*(int *)(param_1 + 0x2c) + 0x32c) + 0x14)) (*(int *)(param_1 + 0x2c) + 0x310,*(undefined4 *)(param_1 + 0x244)); } else if (iVar13 == 2) { filepath = 4; puVar11 = (undefined4 *)Pac_Get_Param(param_2,7,1); Data::Load_from_path(auStack32,&DAT_08a6007c,*puVar11,filepath,param_5,param_6,param_7,param_8); FUN_088740fc(param_1 + 0x34,uVar14,0x100); Message::Write_Value_Final(auStack96,0x40,auStack32); FUN_088740a0(param_1 + 0x34,auStack96,0x100); *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x34c) = 0; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x354) = 0x3e800000; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a0) = 0; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a4) = 0; FUN_08935148(*(undefined4 *)(param_1 + 0x2c),3); local_88 = *puVar3; local_84 = local_88; FUN_089350e8(*(undefined4 *)(param_1 + 0x2c),&local_88); FUN_089353d0(*(undefined4 *)(param_1 + 0x2c),param_1 + 0x23c); FUN_089352a0(*(undefined4 *)(param_1 + 0x2c),param_1 + 0x34,0); FUN_08939168(*(undefined4 *)(param_1 + 0x2c),1); fVar15 = *pfVar5 * 4800.0; if (fVar15 < 2.147484e+09) { uVar12 = (uint)fVar15; } else { uVar12 = (int)(fVar15 - 2.147484e+09) | 0xffff8000; } *(uint *)(*(int *)(param_1 + 0x2c) + 0x358) = uVar12; local_8c = *puVar2; local_90 = *puVar1; FUN_08939140(*(undefined4 *)(param_1 + 0x2c),&local_90); uVar14 = *puVar2; iVar13 = *(int *)(param_1 + 0x2c); *(undefined4 *)(iVar13 + 0x170) = *puVar1; *(undefined4 *)(iVar13 + 0x174) = uVar14; (**(code **)(*(int *)(*(int *)(param_1 + 0x2c) + 0x32c) + 0x14)) (*(int *)(param_1 + 0x2c) + 0x310,*(undefined4 *)(param_1 + 0x244)); } else if (iVar13 == 1) { if (ABS(*pfVar4) < 0.001) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x34c) = 0; } else { *(float *)(*(int *)(param_1 + 0x2c) + 0x34c) = *pfVar4; } if (ABS(*pfVar4) < 0.001) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x350) = 0; } else { *(float *)(*(int *)(param_1 + 0x2c) + 0x350) = *pfVar4; } if (ABS(*pfVar4) < 0.001) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x354) = 0; } else { *(float *)(*(int *)(param_1 + 0x2c) + 0x354) = *pfVar4; } *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x338) = 0; FUN_08935148(*(undefined4 *)(param_1 + 0x2c),3); *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a0) = 1; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a4) = 1; local_78 = *puVar3; local_74 = local_78; FUN_089350e8(*(undefined4 *)(param_1 + 0x2c),&local_78); FUN_089353d0(*(undefined4 *)(param_1 + 0x2c),param_1 + 0x23c); FUN_089352a0(*(undefined4 *)(param_1 + 0x2c),uVar14,0); fVar15 = *pfVar5 * 4800.0; if (fVar15 < 2.147484e+09) { uVar12 = (uint)fVar15; } else { uVar12 = (int)(fVar15 - 2.147484e+09) | 0xffff8000; } *(uint *)(*(int *)(param_1 + 0x2c) + 0x358) = uVar12; local_7c = *puVar2; local_80 = *puVar1; FUN_08939140(*(undefined4 *)(param_1 + 0x2c),&local_80); uVar14 = *puVar2; iVar13 = *(int *)(param_1 + 0x2c); *(undefined4 *)(iVar13 + 0x170) = *puVar1; *(undefined4 *)(iVar13 + 0x174) = uVar14; (**(code **)(*(int *)(*(int *)(param_1 + 0x2c) + 0x32c) + 0x14)) (*(int *)(param_1 + 0x2c) + 0x310,*(undefined4 *)(param_1 + 0x244)); } else if (iVar13 == 0) { *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x34c) = 0; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x354) = 0x3e800000; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a0) = 0; FUN_08935148(*(undefined4 *)(param_1 + 0x2c),3); *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a4) = 0; local_68 = *puVar3; local_64 = local_68; FUN_089350e8(*(undefined4 *)(param_1 + 0x2c),&local_68); FUN_089353d0(*(undefined4 *)(param_1 + 0x2c),param_1 + 0x23c); FUN_089352a0(*(undefined4 *)(param_1 + 0x2c),uVar14,0); FUN_08939168(*(undefined4 *)(param_1 + 0x2c),1); fVar15 = *pfVar5 * 4800.0; if (fVar15 < 2.147484e+09) { uVar12 = (uint)fVar15; } else { uVar12 = (int)(fVar15 - 2.147484e+09) | 0xffff8000; } *(uint *)(*(int *)(param_1 + 0x2c) + 0x358) = uVar12; local_6c = *puVar2; local_70 = *puVar1; FUN_08939140(*(undefined4 *)(param_1 + 0x2c),&local_70); uVar14 = *puVar2; iVar13 = *(int *)(param_1 + 0x2c); *(undefined4 *)(iVar13 + 0x170) = *puVar1; *(undefined4 *)(iVar13 + 0x174) = uVar14; (**(code **)(*(int *)(*(int *)(param_1 + 0x2c) + 0x32c) + 0x14)) (*(int *)(param_1 + 0x2c) + 0x310,*(undefined4 *)(param_1 + 0x244)); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "sysytemmessagedirectlocalizecategory.html": {
    "href": "sysytemmessagedirectlocalizecategory.html",
    "title": "sysytemMessageDirectLocalizeCategory",
    "keywords": "sysytemMessageDirectLocalizeCategory Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: sysytemMessageDirectLocalizeCategory Scope: Global PAC Instruction (Binary): 25 03 05 00 Assembly Address in Memory : 0x892c388 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (float)Var3 (8 bytes) (undefined4)Var4 (8 bytes) (undefined4)Var5 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892c388(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; float *pfVar4; undefined4 *puVar5; undefined4 *puVar6; int iVar7; undefined4 uVar8; uint uVar9; float fVar10; undefined4 local_10; undefined4 local_c; undefined4 local_8; undefined4 local_4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); pfVar4 = (float *)Pac_Get_Param(param_2,3,1,4); puVar5 = (undefined4 *)Pac_Get_Param(param_2,4,1,4); puVar6 = (undefined4 *)Pac_Get_Param(param_2,5,1,4); FUN_0892d470(param_1); iVar7 = Save::Get_Save_BaseAddr(1); *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x34c) = 0; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x354) = 0x3e800000; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a0) = 0; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a4) = 0; *(undefined4 *)(*(int *)(param_1 + 0x2c) + 0x1a4) = 1; local_8 = *puVar3; local_4 = local_8; FUN_089350e8(*(undefined4 *)(param_1 + 0x2c),&local_8); FUN_089353d0(*(undefined4 *)(param_1 + 0x2c),param_1 + 0x23c); uVar8 = Message::Get_Message(iVar7 + 0x98,*puVar5,*puVar6); FUN_089352a0(*(undefined4 *)(param_1 + 0x2c),uVar8,0); fVar10 = *pfVar4 * 4800.0; if (fVar10 < 2.147484e+09) { uVar9 = (uint)fVar10; } else { uVar9 = (int)(fVar10 - 2.147484e+09) | 0xffff8000; } *(uint *)(*(int *)(param_1 + 0x2c) + 0x358) = uVar9; local_c = *puVar2; local_10 = *puVar1; FUN_08939140(*(undefined4 *)(param_1 + 0x2c),&local_10); uVar8 = *puVar2; iVar7 = *(int *)(param_1 + 0x2c); *(undefined4 *)(iVar7 + 0x170) = *puVar1; *(undefined4 *)(iVar7 + 0x174) = uVar8; (**(code **)(*(int *)(*(int *)(param_1 + 0x2c) + 0x32c) + 0x14)) (*(int *)(param_1 + 0x2c) + 0x310,*(undefined4 *)(param_1 + 0x244)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "text_setreplacecolor.html": {
    "href": "text_setreplacecolor.html",
    "title": "text_setReplaceColor",
    "keywords": "text_setReplaceColor Sets colour of some magic word texts. Code Information Name: text_setReplaceColor Scope: Global PAC Instruction (Binary): 25 0a 37 00 Assembly Address in Memory : 0x894cc70 Parameters (int)magicword_index (8 bytes) : The X value from \\<NX>. (int)red (8 bytes) : Red value of the text colour, in range of 0~255. (int)green (8 bytes) : Green value of the text colour, in range of 0~255. (int)blue (8 bytes) : Blue value of the text colour, in range of 0~255. (int)alpha (8 bytes) : Alpha value of the text colour, in range of 0~255. If any of RGBA is -1, this will reset the colour to default. Example Here is one example in hex: 25 0a 37 00 / 02 00 00 00 / 01 00 00 00 / 02 00 00 00 / ff 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / ff 00 00 00 Which is interpreted as: text_setReplaceColor((int)1, (int)255, (int)0, (int)0, (int)255) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cc70(undefined4 param_1,undefined4 param_2) { int *piVar1; uint *puVar2; uint *puVar3; uint *puVar4; int *piVar5; int iVar6; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); puVar3 = (uint *)Pac_Get_Param(param_2,2,1,4); puVar4 = (uint *)Pac_Get_Param(param_2,3,1,4); piVar5 = (int *)Pac_Get_Param(param_2,4,1,4); if (((((int)*puVar2 < 0) || ((int)*puVar3 < 0)) || ((int)*puVar4 < 0)) || (*piVar5 < 0)) { iVar6 = *piVar1 * 8; *(undefined4 *)(iVar6 + 0x8ab93b8) = 0xffffffff; *(undefined *)(iVar6 + 0x8ab93bc) = 0; } else { iVar6 = *piVar1 * 8; *(uint *)(iVar6 + 0x8ab93b8) = *piVar5 << 0x18 | (*puVar4 & 0xff) << 0x10 | *puVar2 & 0xff | (*puVar3 & 0xff) << 8; *(undefined *)(iVar6 + 0x8ab93bc) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "text_setreplacetext.html": {
    "href": "text_setreplacetext.html",
    "title": "text_setReplaceText",
    "keywords": "text_setReplaceText Replaces magic word text to something else. Code Information Name: text_setReplaceText Scope: Global PAC Instruction (Binary): 25 0a 36 00 Assembly Address in Memory : 0x894cbb4 Parameters (int)magicword_index (8 bytes) : The X value from \\<NX>. (Address)message_address : Message Address in PAC file. Do not make message too long or it might cause issue with message displaying, it might fit max 32 letters (not tested). Example Here is one example in hex: 25 0a 36 00 / 02 00 00 00 / 01 00 00 00 / d4 e5 05 00 Which is interpreted as: text_setReplaceText((int)1, 0x5e5d4) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cbb4(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; int iVar4; int iVar5; undefined4 uVar6; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); piVar2 = (int *)Pac_Get_Param(param_2,0,0,4); iVar5 = *piVar2; if (iVar5 < 0) { uVar6 = 0; } else { iVar3 = FUN_0883bc1c(param_2); iVar4 = Save::Get_Save_BaseAddr(1); uVar6 = Message::Get_MsgAddr_With_FullID(iVar4 + 0x98,*(undefined4 *)(iVar3 + iVar5)); } iVar5 = Save::Get_Save_BaseAddr(1); Write_NX_Magicword(*(int *)(iVar5 + 0x50) + 0x2b408,*puVar1,uVar6); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "totilte.html": {
    "href": "totilte.html",
    "title": "toTilte",
    "keywords": "toTilte Move to the title menu. Code Information Name: toTilte Scope: Azito PAC Instruction (Binary): 25 1c 28 00 Assembly Address in Memory : 0x8b4fea0 Parameters This function is parameterless. Example Here is one example in hex: 25 1c 28 00 Which is interpreted as: toTilte() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_Azito__08b4fea0(int param_1,undefined4 param_2) { undefined4 uVar1; int iVar2; uVar1 = Save::Get_Save_BaseAddr(1); uVar1 = Save::Get_BaseAddr__0x78(uVar1,1); iVar2 = FUN_089482b0(uVar1); *(undefined *)(iVar2 + 0x354) = 1; FUN_Azito__08aca818(*(undefined4 *)(*(int *)(param_1 + 0x10) + 500)); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unituidtosquadhandle.html": {
    "href": "unituidtosquadhandle.html",
    "title": "unitUidToSquadHandle",
    "keywords": "unitUidToSquadHandle Use getUnitSquadHandle for stability. Code Information Name: unitUidToSquadHandle Scope: Global PAC Instruction (Binary): 25 21 2f 00 Assembly Address in Memory : 0x89b3f34 Parameters (int)reqactor_id (8 bytes) : Unique ID of the reqactor. (int *)destination (8 bytes) : Variable to store the squad handle. Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b3f34(int param_1,undefined4 param_2) { undefined4 *puVar1; int *piVar2; int iVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); piVar2 = (int *)Pac_Get_Param(param_2,1,1,4); *piVar2 = -1; iVar3 = *(int *)(param_1 + 0x10); if (iVar3 == 0) { iVar3 = 0; } iVar3 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar3 + 0xf8),*puVar1); if (iVar3 != 0) { *piVar2 = (int)*(short *)(iVar3 + 0x78); } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unlockbgm.html": {
    "href": "unlockbgm.html",
    "title": "unlockBGM",
    "keywords": "unlockBGM Unlocks a selectable theme. Part of the debug mode. Code Information Name: unlockBGM Scope: Global PAC Instruction (Binary): 25 0a 41 00 Assembly Address in Memory : 0x894d298 Parameters (int)bgm_id (8 bytes) : The theme ID to unlock. Example Here is one example in hex: 25 0a 41 00 / 02 00 00 00 / 01 00 00 00 Which is interpreted as: unlockBGM((int)1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d298(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; undefined4 uVar3; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); uVar3 = return__0x285a8(*(undefined4 *)(iVar2 + 0x50)); FUN_08a33e0c(uVar3,*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unlockmedenshopitem.html": {
    "href": "unlockmedenshopitem.html",
    "title": "unlockMedenShopItem",
    "keywords": "unlockMedenShopItem Adds an item to the current Meden shop. Code Information Name: unlockMedenShopItem Scope: Global PAC Instruction (Binary): 25 0a 43 00 Assembly Address in Memory : 0x894d40c Parameters (int)item_id (8 bytes) : ID of the item. (int)scale (8 bytes) : If equipment, level of the item. If regular item, stocks. -1 makes infinite stock. (int)cost (8 bytes) : How much does the item cost as Ka-ching. Example Here is one example in hex: 25 0a 43 00 / 04 00 00 00 / 14 00 00 00 / 04 00 00 00 / 15 00 00 00 / 04 00 00 00 / 16 00 00 00 Which is interpreted as: unlockMedenShopItem((int *)iVar20, (int *)iVar21, (int *)iVar22) This is how to unlock equipment in Meden shop item with getGfpData: 00062560 250A0700:getGfpData(4:16, 2:9, 2:0, 4:14, 2:0) 0006258C 25000A00:cmd_mul(4:16, 4:17) 000625A0 250A4300:unlockMedenShopItem(4:14, 4:15, 4:16) 000625BC 25000100:cmd_end() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d40c(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 uVar2; undefined4 uVar3; undefined4 uVar4; undefined4 uVar5; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); uVar5 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); uVar4 = *puVar1; puVar1 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); uVar3 = *puVar1; uVar2 = Save::Get_Save_BaseAddr(1); FUN_08851518(uVar2,uVar5,uVar4,uVar3); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unlockshopitem.html": {
    "href": "unlockshopitem.html",
    "title": "unlockShopItem",
    "keywords": "unlockShopItem Supposed to add hoshipon item in the hoshipon shop, but doesn't work. Code Information Name: unlockShopItem Scope: Global PAC Instruction (Binary): 25 0a 3d 00 Assembly Address in Memory : 0x894cfb4 Parameters (int)Var0 (8 bytes) (uint)shopitemparam_id (8 bytes) : The shopitemparam ID of the item. Example Here is one example in hex: 25 0a 3d 00 / 02 00 00 00 / 00 00 00 00 / 02 00 00 00 / bd 01 00 00 Which is interpreted as: unlockShopItem((int)0, (int)445) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894cfb4(undefined4 param_1,undefined4 param_2) { int *piVar1; uint *puVar2; int iVar3; uint uVar4; uint uVar5; uint *puVar6; int iVar7; piVar1 = (int *)Pac_Get_Param(param_2,0,1,4); iVar7 = *piVar1; puVar2 = (uint *)Pac_Get_Param(param_2,1,1,4); iVar3 = Save::Get_Save_BaseAddr(1); iVar3 = return__0x285a8(*(undefined4 *)(iVar3 + 0x50)); if (iVar7 == 0) { iVar3 = iVar3 + 0x1554; } else { iVar3 = iVar3 + 0x1598; } uVar4 = *puVar2 >> 5; if (uVar4 < 0x11) { puVar6 = (uint *)(iVar3 + uVar4 * 4); uVar5 = 1 << (*puVar2 & 0x1f); uVar4 = *puVar6 & ~uVar5; *puVar6 = uVar4; *puVar6 = uVar4 | uVar5; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unlockteamcard.html": {
    "href": "unlockteamcard.html",
    "title": "unlockTeamCard",
    "keywords": "unlockTeamCard Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: unlockTeamCard Scope: Global PAC Instruction (Binary): 25 0a 3f 00 Assembly Address in Memory : 0x894d1b8 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0a 3f 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: unlockTeamCard((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d1b8(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = return__0x1c(*(undefined4 *)(iVar2 + 0x50)); FUN_089cd428(iVar2 + 0xf1ac,*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unlockteamflag.html": {
    "href": "unlockteamflag.html",
    "title": "unlockTeamFlag",
    "keywords": "unlockTeamFlag Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: unlockTeamFlag Scope: Global PAC Instruction (Binary): 25 0a 40 00 Assembly Address in Memory : 0x894d228 Parameters (undefined4)Var0 (8 bytes) Example Here is one example in hex: 25 0a 40 00 / 02 00 00 00 / 00 00 00 00 Which is interpreted as: unlockTeamFlag((int)0) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894d228(undefined4 param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); iVar2 = return__0x1c(*(undefined4 *)(iVar2 + 0x50)); FUN_089cd4d4(iVar2 + 0xf1ac,*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "unlocktipsimageid.html": {
    "href": "unlocktipsimageid.html",
    "title": "unlockTipsImageId",
    "keywords": "unlockTipsImageId Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: unlockTipsImageId Scope: Global PAC Instruction (Binary): 25 0a 2a 00 Assembly Address in Memory : 0x894bc10 Parameters (uint)Var0 (8 bytes) Example Usage not found for this function. Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bc10(undefined4 param_1,undefined4 param_2) { uint *puVar1; int iVar2; uint uVar3; uint uVar4; puVar1 = (uint *)Pac_Get_Param(param_2,0,1,4); iVar2 = Save::Get_Save_BaseAddr(1); uVar3 = *puVar1; iVar2 = *(int *)(iVar2 + 0x58) + 4; if (((int)uVar3 < 0) || (0x80 < uVar3)) { Syscall::Kernel::Kernel_Memset(iVar2,0,0x10); PAC::PAC_setCmdId(param_2,0); } else { if (uVar3 >> 5 < 4) { puVar1 = (uint *)(iVar2 + (uVar3 >> 5) * 4); uVar4 = 1 << (uVar3 & 0x1f); uVar3 = *puVar1 & ~uVar4; *puVar1 = uVar3; *puVar1 = uVar3 | uVar4; } PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "unlocktipsimagenosave.html": {
    "href": "unlocktipsimagenosave.html",
    "title": "unlockTipsImageNoSave",
    "keywords": "unlockTipsImageNoSave Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: unlockTipsImageNoSave Scope: Global PAC Instruction (Binary): 25 0a 2b 00 Assembly Address in Memory : 0x894bcd8 Parameters This function is parameterless. Example Here is one example in hex: 25 0a 2b 00 Which is interpreted as: unlockTipsImageNoSave() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894bcd8(undefined4 param_1,undefined4 param_2) { int iVar1; iVar1 = Save::Get_Save_BaseAddr(1); *(undefined *)(*(int *)(iVar1 + 0x58) + 0x24) = 1; PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "volume.html": {
    "href": "volume.html",
    "title": "volume",
    "keywords": "volume Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: volume Scope: Global PAC Instruction (Binary): 25 0b 05 00 Assembly Address in Memory : 0x896fa68 Parameters (undefined4)Var0 (8 bytes) (undefined4)Var1 (8 bytes) (undefined4)Var2 (8 bytes) (undefined4)Var3 (8 bytes) Example Here is one example in hex: 25 0b 05 00 / 02 00 00 00 / 02 00 90 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 00 00 / 10 00 00 00 / 00 00 a0 40 Which is interpreted as: volume((int)9437186, (float)0, (float)0, (float)5) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0896fa68(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); FUN_088eb2dc(*puVar3,*puVar4,*puVar2,*(int *)(param_1 + 0x14) + 0x60,*puVar1,1); PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "waitreading.html": {
    "href": "waitreading.html",
    "title": "waitReading",
    "keywords": "waitReading Description goes here. This page is automatically generated and not reviewed yet. Remove this text if this page is fully reviewed. Code Information Name: waitReading Scope: Global PAC Instruction (Binary): 25 09 11 00 Assembly Address in Memory : 0x894935c Parameters This function is parameterless. Example Here is one example in hex: 25 09 11 00 Which is interpreted as: waitReading() Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0894935c(undefined4 param_1,undefined4 param_2) { char cVar1; int iVar2; iVar2 = FUN_08842ef4(1); cVar1 = DLC::Get_Loading_Status(*(undefined4 *)(iVar2 + 0x28),0); if (cVar1 == '\\0') { PAC::PAC_setCmdId(param_2,0); } return; }"
  },
  "wakeupforce.html": {
    "href": "wakeupforce.html",
    "title": "wakeUpForce",
    "keywords": "wakeUpForce Forcefully activates the enemy move (wake up). Code Information Name: wakeUpForce Scope: Global PAC Instruction (Binary): 25 21 39 00 Assembly Address in Memory : 0x89b4580 Parameters (int)reqactor_id (8 bytes) : Unique ID of the reqactor. Example Here is one example in hex: 25 21 39 00 / 08 00 00 00 / ca 00 00 00 Which is interpreted as: wakeUpForce(((global)int *)giVar202) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_089b4580(int param_1,undefined4 param_2) { undefined4 *puVar1; int iVar2; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); iVar2 = *(int *)(param_1 + 0x10); if (iVar2 == 0) { iVar2 = 0; } else { if (iVar2 == 0) { iVar2 = 0; } iVar2 = Get_Squad_From_ReqUniqueID(*(undefined4 *)(iVar2 + 0xf8),*puVar1); if (iVar2 == 0) { iVar2 = 0; } else { iVar2 = FUN_0896d6e0(*(undefined4 *)(iVar2 + 0x708)); if (iVar2 == 0) { iVar2 = 0; } } } if (iVar2 != 0) { *(undefined *)(iVar2 + 0x59c) = 1; } PAC::PAC_setCmdId(param_2,0); return; }"
  },
  "worldtoscreenpos.html": {
    "href": "worldtoscreenpos.html",
    "title": "worldToScreenPos",
    "keywords": "worldToScreenPos Gets from world position (e.g. position in Mission field) to screen position (position in UI). Code Information Name: worldToScreenPos Scope: Global PAC Instruction (Binary): 25 16 24 01 Assembly Address in Memory : 0x892a620 Parameters (float)world_x (8 bytes) : X posiiton in the field/world, as psp pixel unit. (float)world_y (8 bytes) : Y position in the field/world, as psp pixel unit. (float *)screen_x (8 bytes) : Variable to store the converted X screen position, as psp pixel unit. (float *)screen_y (8 bytes) : Variable to store the converted Y screen position, as psp pixel unit. Example Here is one example in hex: 25 16 24 01 / 10 00 00 00 / 00 80 8e 44 / 10 00 00 00 / 00 00 00 00 / 20 00 00 00 / 00 00 00 00 / 20 00 00 00 / 01 00 00 00 Which is interpreted as: worldToScreenPos((float)1140, (float)0, (float *)fVar0, (float *)fVar1) Code Ths PAC instruction calls this function (Decompiled by Ghidra): void FUN_0892a620(int param_1,undefined4 param_2) { undefined4 *puVar1; undefined4 *puVar2; undefined4 *puVar3; undefined4 *puVar4; int iVar5; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; undefined4 local_10; undefined4 local_c; puVar1 = (undefined4 *)Pac_Get_Param(param_2,0,1,4); puVar2 = (undefined4 *)Pac_Get_Param(param_2,1,1,4); puVar3 = (undefined4 *)Pac_Get_Param(param_2,2,1,4); puVar4 = (undefined4 *)Pac_Get_Param(param_2,3,1,4); local_1c = *puVar2; local_20 = *puVar1; local_14 = 0x3f800000; local_18 = 0; local_10 = 0; local_c = 0; if ((*(int *)(param_1 + 0x10) != 0) && (iVar5 = FUN_0889e54c(), iVar5 != 0)) { iVar5 = FUN_0889e54c(*(undefined4 *)(param_1 + 0x10)); FUN_08910268(iVar5 + 0x450,&local_10,&local_20); } *puVar3 = local_10; *puVar4 = local_c; PAC::PAC_setCmdId(param_2,0); return; }"
  }
}